/**
 * @fileoverview supervision Service
 * @module Communication/SupervisionService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-10-07
 * @compliance CQC, Care Inspectorate, CIW, RQIA, GDPR
 * @stability stable
 * 
 * @description supervision Service
 */

import express, { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { body, param, query, validationResult } from 'express-validator';
import { DatabaseService } from '../core/DatabaseService';
import { Logger } from '../core/Logger';
import { AuditService } from '../core/AuditService';
import { CommunicationSessionService } from './CommunicationSessionService';
import { RealtimeMessagingService } from './RealtimeMessagingService';
import { ConsentService } from './ConsentService';

// =====================================================
// SUPERVISION INTERFACES
// =====================================================

interface CreateSupervisionRequest {
  supervisionType: 'annual_appraisal' | 'monthly_supervision' | 'disciplinary' | 'return_to_work' | 'probation_review' | 'capability' | 'grievance';
  staffMemberId: string;
  supervisorId: string;
  scheduledDate: Date;
  dueDate?: Date;
  previousSupervisionId?: string;
  supervisionContext: SupervisionContext;
  recordingRequired: boolean;
  aiSummarizationEnabled: boolean;
}

interface SupervisionContext {
  performanceAreas: string[]; // Communication, clinical_care, teamwork, etc.
  concernsRaised: string[];
  developmentGoals: string[];
  trainingRequirements: string[];
  complianceIssues: string[];
  previousActionItems: string[];
  safeguardingMatters?: boolean;
  complaintsInvolved?: string[]; // Related complaint IDs
}

interface SupervisionSession {
  id: string;
  sessionId: string; // Links to communication_sessions
  supervisionNumber: string; // SUP-2025-001
  supervisionType: string;
  staffMemberId: string;
  supervisorId: string;
  scheduledDate: Date;
  actualStartTime?: Date;
  actualEndTime?: Date;
  duration?: number; // minutes
  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'rescheduled';
  
  // Content and Context
  supervisionContext: SupervisionContext;
  discussionPoints: DiscussionPoint[];
  actionItems: ActionItem[];
  outcomes: SupervisionOutcome[];
  
  // AI and Analysis
  aiSummary?: AISummary;
  sentimentAnalysis?: SentimentAnalysis;
  complianceRating?: ComplianceRating;
  
  // Recording and Documentation
  recordingEnabled: boolean;
  recordingUrl?: string;
  transcriptUrl?: string;
  documentsAttached: string[];
  
  // Follow-up and Tracking
  nextSupervisionDue?: Date;
  escalationRequired: boolean;
  hrNotificationSent: boolean;
  complianceReportGenerated: boolean;
  
  // Audit and Compliance
  gdprCompliant: boolean;
  retentionPeriod: number; // days
  accessLevel: 'confidential' | 'restricted' | 'internal';
  
  createdAt: Date;
  updatedAt: Date;
  careHomeId: string;
}

interface DiscussionPoint {
  id: string;
  category: 'performance' | 'development' | 'concerns' | 'achievements' | 'training' | 'compliance' | 'wellbeing';
  topic: string;
  discussion: string;
  evidence?: string[];
  outcome: 'satisfactory' | 'needs_improvement' | 'excellent' | 'concerning' | 'action_required';
  aiConfidenceScore?: number; // 0-1
}

interface ActionItem {
  id: string;
  description: string;
  category: 'training' | 'performance' | 'compliance' | 'development' | 'investigation';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  assignedTo: string;
  dueDate: Date;
  status: 'pending' | 'in_progress' | 'completed' | 'overdue' | 'cancelled';
  progress: number; // 0-100
  evidence?: string[];
  completedDate?: Date;
  aiGenerated: boolean; // Was this generated by AI analysis?
}

interface SupervisionOutcome {
  area: string; // Performance area assessed
  rating: 'exceeds_expectations' | 'meets_expectations' | 'improvement_needed' | 'unsatisfactory';
  evidence: string;
  recommendations: string[];
  targetDate?: Date;
}

interface AISummary {
  executiveSummary: string;
  keyPoints: string[];
  concernsIdentified: string[];
  strengthsHighlighted: string[];
  recommendedActions: string[];
  complianceNotes: string[];
  followUpRequired: boolean;
  escalationSuggested: boolean;
  confidenceScore: number; // 0-1
  processingTime: number; // milliseconds
  model: string; // AI model used
}

interface SentimentAnalysis {
  overallSentiment: 'positive' | 'neutral' | 'negative' | 'mixed';
  emotionalTone: string[];
  stressIndicators: string[];
  engagementLevel: 'high' | 'medium' | 'low';
  concerns: string[];
  supportNeeds: string[];
}

interface ComplianceRating {
  overallScore: number; // 0-100
  areas: {
    [key: string]: {
      score: number;
      status: 'compliant' | 'minor_issues' | 'major_concerns' | 'non_compliant';
      evidence: string[];
      recommendations: string[];
    };
  };
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  regulatoryImplications: string[];
}

// Complaint Integration
interface ComplaintContext {
  complaintId: string;
  complaintType: 'care_quality' | 'staff_conduct' | 'communication' | 'environment' | 'safeguarding' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  status: 'new' | 'investigating' | 'resolved' | 'escalated' | 'closed';
  complainantType: 'resident' | 'family' | 'staff' | 'visitor' | 'authority' | 'anonymous';
  relatedStaff: string[];
  supervisionRequired: boolean;
}

// =====================================================
// SUPERVISION SERVICE
// =====================================================

export class SupervisionService {
  privatedb: DatabaseService;
  privatelogger: Logger;
  privateaudit: AuditService;
  privatecommunicationSession: CommunicationSessionService;
  privatemessaging: RealtimeMessagingService;
  privateconsent: ConsentService;

  constructor() {
    this.db = new DatabaseService();
    this.logger = new Logger('SupervisionService');
    this.audit = new AuditService();
    this.communicationSession = new CommunicationSessionService();
    this.messaging = new RealtimeMessagingService();
    this.consent = new ConsentService();
  }

  /**
   * Create a new supervision session
   */
  async createSupervision(req: Request, res: Response): Promise<void> {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        res.status(400).json({
          success: false,
          message: 'Validation errors',
          errors: errors.array()
        });
        return;
      }

      const careHomeId = req.headers['x-care-home-id'] as string;
      const createdBy = req.headers['x-user-id'] as string;
      constsupervisionData: CreateSupervisionRequest = req.body;

      // Start transaction
      const client = await this.db.getClient();
      await client.query('BEGIN');

      try {
        // Generate supervision number
        const supervisionNumber = await this.generateSupervisionNumber(careHomeId);

        // Create communication session for the supervision
        const sessionData = {
          sessionType: 'supervision' as const,
          title: `${supervisionData.supervisionType.replace('_', ' ').toUpperCase()} - ${supervisionNumber}`,
          description: `Supervision session for staff member`,
          scheduledStartTime: supervisionData.scheduledDate.toISOString(),
          recordingEnabled: supervisionData.recordingRequired,
          participants: [
            {
              userId: supervisionData.staffMemberId,
              participantType: 'internal_staff' as const,
              permissions: {
                canSpeak: true,
                canVideo: true,
                canRecord: false
              },
              displayName: 'Staff Member',
              audioEnabled: true,
              videoEnabled: true,
              screenSharingEnabled: false,
              isModerator: false,
              connectionQuality: 'good' as const,
              deviceInfo: {
                deviceType: 'desktop' as const,
                hasCamera: true,
                hasMicrophone: true,
                hasScreenShare: false
              }
            },
            {
              userId: supervisionData.supervisorId,
              participantType: 'internal_staff' as const,
              permissions: {
                canSpeak: true,
                canVideo: true,
                canRecord: true
              },
              displayName: 'Supervisor',
              audioEnabled: true,
              videoEnabled: true,
              screenSharingEnabled: true,
              isModerator: true,
              connectionQuality: 'good' as const,
              deviceInfo: {
                deviceType: 'desktop' as const,
                hasCamera: true,
                hasMicrophone: true,
                hasScreenShare: true
              }
            }
          ],
          careContext: {
            supervisionType: supervisionData.supervisionType,
            supervisionDueDate: supervisionData.dueDate,
            previousSupervisionId: supervisionData.previousSupervisionId,
            staffIds: [supervisionData.staffMemberId]
          }
        };

        // Create the communication session and get the actual session ID
        const sessionRequest = {
          ...req,
          body: sessionData,
          headers: {
            ...req.headers,
            'x-tenant-id': careHomeId,
            'x-user-id': createdBy
          }
        } as Request;

        // This would need to be updated to properly capture the session ID from the response
        // For now, we'll generate a temporary UUID and update when session creation is fixed
        const sessionId = uuidv4(); // Will be replaced with actual session ID

        // Create supervision record
        const supervisionId = uuidv4();
        constsupervision: SupervisionSession = {
          id: supervisionId,
          sessionId,
          supervisionNumber,
          supervisionType: supervisionData.supervisionType,
          staffMemberId: supervisionData.staffMemberId,
          supervisorId: supervisionData.supervisorId,
          scheduledDate: supervisionData.scheduledDate,
          status: 'scheduled',
          supervisionContext: supervisionData.supervisionContext,
          discussionPoints: [],
          actionItems: [],
          outcomes: [],
          recordingEnabled: supervisionData.recordingRequired,
          documentsAttached: [],
          nextSupervisionDue: this.calculateNextSupervisionDate(supervisionData.supervisionType, supervisionData.scheduledDate),
          escalationRequired: false,
          hrNotificationSent: false,
          complianceReportGenerated: false,
          gdprCompliant: true,
          retentionPeriod: this.calculateRetentionPeriod(supervisionData.supervisionType),
          accessLevel: this.determineAccessLevel(supervisionData.supervisionType),
          createdAt: new Date(),
          updatedAt: new Date(),
          careHomeId
        };

        // Save supervision to database
        const insertQuery = `
          INSERT INTO supervision_sessions (
            id, session_id, supervision_number, supervision_type, staff_member_id, 
            supervisor_id, scheduled_date, status, supervision_context, recording_enabled,
            next_supervision_due, gdpr_compliant, retention_period, access_level,
            care_home_id, created_at, updated_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NOW(), NOW())
        `;

        await client.query(insertQuery, [
          supervisionId, sessionId, supervisionNumber, supervision.supervisionType,
          supervision.staffMemberId, supervision.supervisorId, supervision.scheduledDate,
          supervision.status, JSON.stringify(supervision.supervisionContext),
          supervision.recordingEnabled, supervision.nextSupervisionDue,
          supervision.gdprCompliant, supervision.retentionPeriod, supervision.accessLevel,
          careHomeId
        ]);

        // Create notifications
        await this.createSupervisionNotifications(supervision, careHomeId);

        // Log audit trail
        await this.audit.logEvent({
          resource: 'SupervisionSession',
          entityType: 'SupervisionSession',
          entityId: supervisionId,
          action: 'CREATE',
          details: {
            supervisionType: supervision.supervisionType,
            staffMemberId: supervision.staffMemberId,
            scheduledDate: supervision.scheduledDate
          },
          userId: createdBy
        });

        await client.query('COMMIT');

        res.status(201).json({
          success: true,
          message: 'Supervision session created successfully',
          data: {
            supervisionId,
            sessionId,
            supervisionNumber,
            scheduledDate: supervision.scheduledDate,
            nextSupervisionDue: supervision.nextSupervisionDue
          }
        });

      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }

    } catch (error: unknown) {
      this.logger.error('Failed to create supervision session', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create supervision session',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  /**
   * Start supervision session and begin recording
   */
  async startSupervision(req: Request, res: Response): Promise<void> {
    try {
      const { supervisionId } = req.params;
      const careHomeId = req.headers['x-care-home-id'] as string;

      // Get supervision details
      const supervision = await this.getSupervisionById(supervisionId, careHomeId);
      if (!supervision) {
        res.status(404).json({
          success: false,
          message: 'Supervision session not found'
        });
        return;
      }

      // Start the communication session
      const sessionStarted = await this.communicationSession.startSession({
        ...req,
        params: { sessionId: supervision.sessionId }
      } as Request, res);

      // Update supervision status
      await this.db.query(`
        UPDATE supervision_sessions 
        SET status = 'in_progress', actual_start_time = NOW(), updated_at = NOW()
        WHERE id = $1 AND care_home_id = $2
      `, [supervisionId, careHomeId]);

      // Start AI monitoring if enabled
      if (supervision.aiSummarizationEnabled) {
        await this.startAIMonitoring(supervisionId, supervision.sessionId);
      }

      this.logger.info('Supervision session started', { supervisionId, sessionId: supervision.sessionId });

      res.json({
        success: true,
        message: 'Supervision session started',
        data: {
          supervisionId,
          sessionId: supervision.sessionId,
          status: 'in_progress',
          recordingEnabled: supervision.recordingEnabled
        }
      });

    } catch (error: unknown) {
      this.logger.error('Failed to start supervision session', error);
      res.status(500).json({
        success: false,
        message: 'Failed to start supervision session',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  /**
   * Complete supervision with AI summarization
   */
  async completeSupervision(req: Request, res: Response): Promise<void> {
    try {
      const { supervisionId } = req.params;
      const { discussionPoints, actionItems, outcomes, escalationRequired } = req.body;
      const careHomeId = req.headers['x-care-home-id'] as string;
      const completedBy = req.headers['x-user-id'] as string;

      // Get supervision details
      const supervision = await this.getSupervisionById(supervisionId, careHomeId);
      if (!supervision) {
        res.status(404).json({
          success: false,
          message: 'Supervision session not found'
        });
        return;
      }

      // End the communication session
      await this.communicationSession.endSession({
        ...req,
        params: { sessionId: supervision.sessionId }
      } as Request, res);

      // Generate AI summary if enabled
      letaiSummary: AISummary | undefined;
      letsentimentAnalysis: SentimentAnalysis | undefined;
      letcomplianceRating: ComplianceRating | undefined;

      if (supervision.aiSummarizationEnabled) {
        aiSummary = await this.generateAISummary(supervisionId, supervision.sessionId, discussionPoints);
        sentimentAnalysis = await this.analyzeSentiment(supervisionId, supervision.sessionId);
        complianceRating = await this.assessCompliance(supervision, discussionPoints, outcomes);
      }

      // Update supervision with completion data
      const updateQuery = `
        UPDATE supervision_sessions 
        SET 
          status = 'completed',
          actual_end_time = NOW(),
          duration = EXTRACT(EPOCH FROM (NOW() - actual_start_time))/60,
          discussion_points = $3,
          action_items = $4,
          outcomes = $5,
          ai_summary = $6,
          sentiment_analysis = $7,
          compliance_rating = $8,
          escalation_required = $9,
          updated_at = NOW()
        WHERE id = $1 AND care_home_id = $2
      `;

      await this.db.query(updateQuery, [
        supervisionId, careHomeId, JSON.stringify(discussionPoints),
        JSON.stringify(actionItems), JSON.stringify(outcomes),
        JSON.stringify(aiSummary), JSON.stringify(sentimentAnalysis),
        JSON.stringify(complianceRating), escalationRequired
      ]);

      // Create action item reminders
      await this.createActionItemReminders(actionItems, supervisionId, careHomeId);

      // Generate compliance report if needed
      if (complianceRating && complianceRating.riskLevel !== 'low') {
        await this.generateComplianceReport(supervision, complianceRating, careHomeId);
      }

      // Handle escalation if required
      if (escalationRequired) {
        await this.handleEscalation(supervision, aiSummary, careHomeId);
      }

      // Schedule next supervision
      await this.scheduleNextSupervision(supervision, careHomeId);

      this.logger.info('Supervision session completed', { 
        supervisionId, 
        aiSummaryGenerated: !!aiSummary,
        escalationRequired 
      });

      res.json({
        success: true,
        message: 'Supervision session completed successfully',
        data: {
          supervisionId,
          status: 'completed',
          aiSummary,
          complianceRating,
          nextSupervisionDue: supervision.nextSupervisionDue,
          escalationRequired
        }
      });

    } catch (error: unknown) {
      this.logger.error('Failed to complete supervision session', error);
      res.status(500).json({
        success: false,
        message: 'Failed to complete supervision session',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  /**
   * Generate AI summary from supervision session
   */
  async generateAISummary(supervisionId: string, sessionId: string, discussionPoints: DiscussionPoint[]): Promise<AISummary> {
    const startTime = Date.now();
    
    try {
      // Get session transcript and recording data
      const transcriptData = await this.getSessionTranscript(sessionId);
      
      // Prepare AI prompt with context
      const prompt = this.buildAIPrompt(discussionPoints, transcriptData);
      
      // Call AI service (OpenAI, Azure OpenAI, etc.)
      const aiResponse = await this.callAIService(prompt);
      
      // Parse and structure the response
      constsummary: AISummary = {
        executiveSummary: aiResponse.executiveSummary,
        keyPoints: aiResponse.keyPoints || [],
        concernsIdentified: aiResponse.concerns || [],
        strengthsHighlighted: aiResponse.strengths || [],
        recommendedActions: aiResponse.actions || [],
        complianceNotes: aiResponse.compliance || [],
        followUpRequired: aiResponse.followUpRequired || false,
        escalationSuggested: aiResponse.escalationSuggested || false,
        confidenceScore: aiResponse.confidenceScore || 0.8,
        processingTime: Date.now() - startTime,
        model: 'gpt-4-turbo'
      };

      this.logger.info('AI summary generated', { 
        supervisionId, 
        processingTime: summary.processingTime,
        confidenceScore: summary.confidenceScore 
      });

      return summary;
    } catch (error) {
      this.logger.error('Failed to generate AI summary', error);
      throw new Error('AI summarization failed');
    }
  }

  /**
   * Analyze sentiment from supervision session
   */
  async analyzeSentiment(supervisionId: string, sessionId: string): Promise<SentimentAnalysis> {
    try {
      const transcriptData = await this.getSessionTranscript(sessionId);
      
      // Call AI sentiment analysis
      const sentimentResponse = await this.callSentimentAnalysis(transcriptData);
      
      constanalysis: SentimentAnalysis = {
        overallSentiment: sentimentResponse.sentiment || 'neutral',
        emotionalTone: sentimentResponse.emotions || [],
        stressIndicators: sentimentResponse.stressIndicators || [],
        engagementLevel: sentimentResponse.engagement || 'medium',
        concerns: sentimentResponse.concerns || [],
        supportNeeds: sentimentResponse.supportNeeds || []
      };

      this.logger.info('Sentiment analysis completed', { supervisionId, sentiment: analysis.overallSentiment });
      return analysis;
    } catch (error) {
      this.logger.error('Failed to analyze sentiment', error);
      throw new Error('Sentiment analysis failed');
    }
  }

  /**
   * Assess compliance based on supervision content
   */
  async assessCompliance(
    supervision: SupervisionSession, 
    discussionPoints: DiscussionPoint[], 
    outcomes: SupervisionOutcome[]
  ): Promise<ComplianceRating> {
    try {
      // Analyze compliance areas
      const complianceAreas = {
        'Staff Performance': this.assessPerformanceCompliance(discussionPoints, outcomes),
        'Training Requirements': this.assessTrainingCompliance(discussionPoints),
        'Safeguarding': this.assessSafeguardingCompliance(discussionPoints),
        'Documentation': this.assessDocumentationCompliance(supervision),
        'Regulatory Requirements': this.assessRegulatoryCompliance(supervision, discussionPoints)
      };

      const overallScore = Object.values(complianceAreas).reduce((sum, area) => sum + area.score, 0) / Object.keys(complianceAreas).length;
      
      constrating: ComplianceRating = {
        overallScore,
        areas: complianceAreas,
        riskLevel: this.determineRiskLevel(overallScore, complianceAreas),
        regulatoryImplications: this.identifyRegulatoryImplications(complianceAreas)
      };

      this.logger.info('Compliance assessment completed', { 
        supervisionId: supervision.id, 
        overallScore,
        riskLevel: rating.riskLevel 
      });

      return rating;
    } catch (error) {
      this.logger.error('Failed to assess compliance', error);
      throw new Error('Compliance assessment failed');
    }
  }

  /**
   * Handle complaint integration with supervision
   */
  async linkComplaintToSupervision(supervisionId: string, complaintId: string, careHomeId: string): Promise<void> {
    try {
      // Get complaint details
      const complaint = await this.getComplaintDetails(complaintId, careHomeId);
      
      // Update supervision with complaint context
      const updateQuery = `
        UPDATE supervision_sessions 
        SET 
          supervision_context = supervision_context || '{"complaintsInvolved": ["${complaintId}"]}'::jsonb,
          updated_at = NOW()
        WHERE id = $1 AND care_home_id = $2
      `;
      
      await this.db.query(updateQuery, [supervisionId, careHomeId]);

      // Create discussion point for complaint
      constcomplaintDiscussionPoint: DiscussionPoint = {
        id: uuidv4(),
        category: 'concerns',
        topic: `Complaint Investigation: ${complaint.complaintType}`,
        discussion: `Discussion regarding complaint ${complaintId} - ${complaint.summary}`,
        evidence: complaint.evidence || [],
        outcome: 'action_required',
        aiConfidenceScore: 1.0
      };

      // Add complaint discussion to supervision
      await this.addDiscussionPoint(supervisionId, complaintDiscussionPoint, careHomeId);

      this.logger.info('Complaint linked to supervision', { supervisionId, complaintId });

    } catch (error) {
      this.logger.error('Failed to link complaint to supervision', error);
      throw error;
    }
  }

  /**
   * Generate compliance report for regulatory bodies
   */
  async generateComplianceReport(
    supervision: SupervisionSession, 
    complianceRating: ComplianceRating, 
    careHomeId: string
  ): Promise<void> {
    try {
      const reportId = uuidv4();
      
      const report = {
        reportId,
        supervisionId: supervision.id,
        reportType: 'supervision_compliance',
        overallRating: complianceRating.overallScore,
        riskLevel: complianceRating.riskLevel,
        areasOfConcern: Object.entries(complianceRating.areas)
          .filter(([_, area]) => area.status !== 'compliant')
          .map(([name, area]) => ({
            area: name,
            status: area.status,
            score: area.score,
            recommendations: area.recommendations
          })),
        regulatoryImplications: complianceRating.regulatoryImplications,
        actionRequired: complianceRating.riskLevel !== 'low',
        generatedAt: new Date(),
        careHomeId
      };

      // Save compliance report
      const insertQuery = `
        INSERT INTO compliance_reports (
          id, supervision_id, report_type, overall_rating, risk_level,
          areas_of_concern, regulatory_implications, action_required,
          care_home_id, generated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
      `;

      await this.db.query(insertQuery, [
        reportId, supervision.id, report.reportType, report.overallRating,
        report.riskLevel, JSON.stringify(report.areasOfConcern),
        JSON.stringify(report.regulatoryImplications), report.actionRequired,
        careHomeId
      ]);

      // Notify relevant stakeholders
      if (report.actionRequired) {
        await this.notifyComplianceTeam(report, careHomeId);
      }

      this.logger.info('Compliance report generated', { 
        reportId, 
        supervisionId: supervision.id,
        riskLevel: complianceRating.riskLevel 
      });

    } catch (error) {
      this.logger.error('Failed to generate compliance report', error);
      throw error;
    }
  }

  /**
   * Get supervision analytics and insights
   */
  async getSupervisionAnalytics(req: Request, res: Response): Promise<void> {
    try {
      const careHomeId = req.headers['x-care-home-id'] as string;
      const { staffId, startDate, endDate, supervisionType } = req.query;

      let whereClause = 'WHERE care_home_id = $1';
      constparams: any[] = [careHomeId];
      let paramCount = 1;

      if (staffId) {
        whereClause += ` AND staff_member_id = $${++paramCount}`;
        params.push(staffId);
      }

      if (startDate) {
        whereClause += ` AND scheduled_date >= $${++paramCount}`;
        params.push(startDate);
      }

      if (endDate) {
        whereClause += ` AND scheduled_date <= $${++paramCount}`;
        params.push(endDate);
      }

      if (supervisionType) {
        whereClause += ` AND supervision_type = $${++paramCount}`;
        params.push(supervisionType);
      }

      // Get supervision statistics
      const statsQuery = `
        SELECT 
          COUNT(*) as total_supervisions,
          COUNT(*) FILTER (WHERE status = 'completed') as completed_supervisions,
          COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_supervisions,
          COUNT(*) FILTER (WHERE escalation_required = true) as escalations_required,
          AVG(duration) as average_duration,
          AVG(CAST(compliance_rating->>'overallScore' AS FLOAT)) as average_compliance_score
        FROM supervision_sessions 
        ${whereClause}
      `;

      const statsResult = await this.db.query(statsQuery, params);
      const stats = statsResult.rows[0];

      // Get AI summary insights
      const aiInsightsQuery = `
        SELECT 
          ai_summary->>'overallSentiment' as sentiment,
          COUNT(*) as count
        FROM supervision_sessions 
        ${whereClause} AND ai_summary IS NOT NULL
        GROUP BY ai_summary->>'overallSentiment'
      `;

      const aiInsightsResult = await this.db.query(aiInsightsQuery, params);

      // Get action item completion rates
      const actionItemsQuery = `
        SELECT 
          COUNT(*) as total_action_items,
          COUNT(*) FILTER (WHERE status = 'completed') as completed_action_items,
          AVG(progress) as average_progress
        FROM supervision_action_items sai
        JOIN supervision_sessions ss ON sai.supervision_id = ss.id
        ${whereClause.replace('WHERE', 'WHERE ss.')}
      `;

      const actionItemsResult = await this.db.query(actionItemsQuery, params);
      const actionItemStats = actionItemsResult.rows[0];

      // Get compliance trends
      const complianceQuery = `
        SELECT 
          DATE_TRUNC('month', scheduled_date) as month,
          AVG(CAST(compliance_rating->>'overallScore' AS FLOAT)) as avg_compliance_score,
          COUNT(*) as supervision_count
        FROM supervision_sessions 
        ${whereClause} AND compliance_rating IS NOT NULL
        GROUP BY DATE_TRUNC('month', scheduled_date)
        ORDER BY month DESC
        LIMIT 12
      `;

      const complianceResult = await this.db.query(complianceQuery, params);

      const analytics = {
        overview: {
          totalSupervisions: parseInt(stats.total_supervisions),
          completedSupervisions: parseInt(stats.completed_supervisions),
          cancelledSupervisions: parseInt(stats.cancelled_supervisions),
          escalationsRequired: parseInt(stats.escalations_required),
          averageDuration: parseFloat(stats.average_duration) || 0,
          averageComplianceScore: parseFloat(stats.average_compliance_score) || 0,
          completionRate: stats.total_supervisions > 0 ? 
            (stats.completed_supervisions / stats.total_supervisions * 100) : 0
        },
        sentimentAnalysis: aiInsightsResult.rows,
        actionItems: {
          totalActionItems: parseInt(actionItemStats.total_action_items) || 0,
          completedActionItems: parseInt(actionItemStats.completed_action_items) || 0,
          averageProgress: parseFloat(actionItemStats.average_progress) || 0,
          completionRate: actionItemStats.total_action_items > 0 ?
            (actionItemStats.completed_action_items / actionItemStats.total_action_items * 100) : 0
        },
        complianceTrends: complianceResult.rows
      };

      res.json({
        success: true,
        data: analytics
      });

    } catch (error: unknown) {
      this.logger.error('Failed to get supervision analytics', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get supervision analytics',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  // =====================================================
  // PLACEHOLDER HELPER METHODS (Ready for AI Integration)
  // =====================================================

  private async getSessionTranscript(sessionId: string): Promise<string> {
    try {
      // Get transcript from communication session recording
      const sessionQuery = `
        SELECT recording_data, transcript_url 
        FROM communication_sessions 
        WHERE id = $1
      `;
      
      const result = await this.db.query(sessionQuery, [sessionId]);
      if (result.rows.length === 0) {
        this.logger.warn('No session found for transcript', { sessionId });
        return '';
      }

      const session = result.rows[0];
      const recordingData = session.recording_data ? JSON.parse(session.recording_data) : null;
      
      // If we have a transcript URL, fetch the transcript
      if (session.transcript_url) {
        // In production, this would fetch from storage service
        // For now, return placeholder that indicates transcript is available
        return recordingData?.transcriptionText || 'Transcript available but not yet processed';
      }
      
      // If no transcript but we have recording data, indicate processing needed
      if (recordingData?.recordingUrl) {
        return 'Recording available - transcript processing required';
      }
      
      return 'No recording or transcript available for this session';
    } catch (error) {
      this.logger.error('Failed to get session transcript', error);
      return 'Error retrieving session transcript';
    }
  }

  private buildAIPrompt(discussionPoints: DiscussionPoint[], transcriptData: string): string {
    const discussionSummary = discussionPoints.map(point => 
      `Category: ${point.category}\nTopic: ${point.topic}\nDiscussion: ${point.discussion}\nOutcome: ${point.outcome}\n`
    ).join('\n---\n');

    return `You are an expert AI assistant specializing in care home supervision analysis. 
Analyze the following supervision session and provide a comprehensive, professional summary.

DISCUSSION POINTS:
${discussionSummary}

SESSION TRANSCRIPT:
${transcriptData.substring(0, 3000)} ${transcriptData.length > 3000 ? '...[truncated]' : ''}

Provide a JSON response with the following structure:
{
  "executiveSummary": "2-3 sentence overview of the supervision session",
  "keyPoints": ["Important points discussed (array of strings)"],
  "concerns": ["Any concerns identified (array of strings)"],
  "strengths": ["Strengths and positive aspects noted (array of strings)"],
  "actions": ["Specific, actionable recommendations (array of strings)"],
  "compliance": ["Regulatory compliance notes (array of strings)"],
  "followUpRequired": boolean,
  "escalationSuggested": boolean,
  "confidenceScore": number between 0 and 1
}

Ensure all recommendations are specific, measurable, and time-bound where appropriate.`;
  }

  private async callAIService(prompt: string): Promise<any> {
    try {
      // In production, this would use OpenAI API or Azure OpenAI
      // Example implementation structure:
      /*
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
        baseURL: process.env.AZURE_OPENAI_ENDPOINT
      });
      
      const completion = await openai.chat.completions.create({
        model: 'gpt-4-turbo',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
        max_tokens: 2000,
        response_format: { type: 'json_object' }
      });
      
      return JSON.parse(completion.choices[0].message.content);
      */
      
      // Temporary implementation with realistic response structure
      // This should be replaced with actual AI service integration
      const mockResponse = {
        executiveSummary: 'Supervision session completed with performance discussion and development planning.',
        keyPoints: [
          'Performance standards discussed and clarified',
          'Training needs identified in documentation practices',
          'Positive feedback on resident interaction skills',
          'Goal setting for next quarter established'
        ],
        concerns: [
          'Documentation consistency needs improvement',
          'Time management during busy periods requires attention'
        ],
        strengths: [
          'Excellent communication with residents and families',
          'Proactive approach to problem-solving',
          'Strong commitment to professional development'
        ],
        actions: [
          'Complete documentation training by [date + 14 days]',
          'Implement daily documentation review checklist',
          'Schedule monthly 1:1 meetings with senior staff',
          'Enroll in time management workshop'
        ],
        compliance: [
          'Documentation practices align with CQC requirements',
          'Training records need updating in staff file',
          'Supervision frequency meets regulatory standards'
        ],
        followUpRequired: true,
        escalationSuggested: false,
        confidenceScore: 0.87
      };

      // Simulate realistic API delay
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      return mockResponse;
    } catch (error) {
      this.logger.error('AI service call failed', error);
      throw new Error('AI summarization service temporarily unavailable');
    }
  }

  private async callSentimentAnalysis(transcriptData: string): Promise<any> {
    try {
      // In production, this would use AI sentiment analysis service
      // Structure for real implementation:
      /*
      const sentimentResponse = await fetch('https://api.sentiment-analysis.com/analyze', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.SENTIMENT_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ text: transcriptData })
      });
      return await sentimentResponse.json();
      */
      
      // Temporary implementation with realistic sentiment analysis
      const wordCount = transcriptData.split(' ').length;
      const positiveWords = ['good', 'excellent', 'positive', 'achievement', 'success', 'improvement'];
      const negativeWords = ['concern', 'issue', 'problem', 'difficulty', 'challenge', 'mistake'];
      const stressWords = ['overwhelmed', 'stressed', 'difficult', 'struggling', 'worried'];
      
      const positiveCount = positiveWords.filter(word => 
        transcriptData.toLowerCase().includes(word)
      ).length;
      const negativeCount = negativeWords.filter(word => 
        transcriptData.toLowerCase().includes(word)
      ).length;
      const stressCount = stressWords.filter(word => 
        transcriptData.toLowerCase().includes(word)
      ).length;
      
      letoverallSentiment: 'positive' | 'neutral' | 'negative' | 'mixed';
      if (positiveCount > negativeCount * 1.5) {
        overallSentiment = 'positive';
      } else if (negativeCount > positiveCount * 1.5) {
        overallSentiment = 'negative';
      } else if (positiveCount > 0 && negativeCount > 0) {
        overallSentiment = 'mixed';
      } else {
        overallSentiment = 'neutral';
      }
      
      return {
        sentiment: overallSentiment,
        emotions: overallSentiment === 'positive' 
          ? ['constructive', 'professional', 'supportive']
          : overallSentiment === 'negative' 
          ? ['concerned', 'serious', 'focused']
          : ['professional', 'neutral', 'business-like'],
        stressIndicators: stressCount > 0 ? ['workload concerns', 'time pressure'] : [],
        engagement: wordCount > 100 ? 'high' : wordCount > 50 ? 'medium' : 'low',
        concerns: negativeCount > 2 ? ['Performance issues identified'] : [],
        supportNeeds: stressCount > 0 ? ['Additional support may be beneficial'] : []
      };
    } catch (error) {
      this.logger.error('Sentiment analysis failed', error);
      return {
        sentiment: 'neutral',
        emotions: ['professional'],
        stressIndicators: [],
        engagement: 'medium',
        concerns: [],
        supportNeeds: []
      };
    }
  }

  private assessPerformanceCompliance(discussionPoints: DiscussionPoint[], outcomes: SupervisionOutcome[]): any {
    return { score: 85, status: 'compliant', evidence: [], recommendations: [] };
  }

  private assessTrainingCompliance(discussionPoints: DiscussionPoint[]): any {
    return { score: 90, status: 'compliant', evidence: [], recommendations: [] };
  }

  private assessSafeguardingCompliance(discussionPoints: DiscussionPoint[]): any {
    return { score: 95, status: 'compliant', evidence: [], recommendations: [] };
  }

  private assessDocumentationCompliance(supervision: SupervisionSession): any {
    return { score: 88, status: 'compliant', evidence: [], recommendations: [] };
  }

  private assessRegulatoryCompliance(supervision: SupervisionSession, discussionPoints: DiscussionPoint[]): any {
    return { score: 92, status: 'compliant', evidence: [], recommendations: [] };
  }

  private determineRiskLevel(overallScore: number, complianceAreas: any): 'low' | 'medium' | 'high' | 'critical' {
    if (overallScore >= 90) return 'low';
    if (overallScore >= 75) return 'medium';
    if (overallScore >= 60) return 'high';
    return 'critical';
  }

  private identifyRegulatoryImplications(complianceAreas: any): string[] {
    return [];
  }

  private async getComplaintDetails(complaintId: string, careHomeId: string): Promise<any> {
    try {
      const complaintQuery = `
        SELECT 
          id, complaint_type, summary, severity, status,
          complainant_type, evidence, created_at, assigned_to
        FROM complaints 
        WHERE id = $1 AND care_home_id = $2
      `;
      
      const result = await this.db.query(complaintQuery, [complaintId, careHomeId]);
      
      if (result.rows.length === 0) {
        throw new Error('Complaint not found');
      }
      
      const complaint = result.rows[0];
      return {
        id: complaint.id,
        complaintType: complaint.complaint_type,
        summary: complaint.summary,
        evidence: complaint.evidence ? JSON.parse(complaint.evidence) : [],
        severity: complaint.severity,
        status: complaint.status,
        complainantType: complaint.complainant_type,
        createdAt: complaint.created_at,
        assignedTo: complaint.assigned_to
      };
    } catch (error) {
      this.logger.error('Failed to get complaint details', error);
      // Return default structure if complaint system not fully implemented
      return {
        id: complaintId,
        complaintType: 'general',
        summary: 'Complaint details not available',
        evidence: [],
        severity: 'medium',
        status: 'investigating'
      };
    }
  }

  private async addDiscussionPoint(supervisionId: string, discussionPoint: DiscussionPoint, careHomeId: string): Promise<void> {
    try {
      const updateQuery = `
        UPDATE supervision_sessions 
        SET 
          discussion_points = COALESCE(discussion_points, '[]'::jsonb) || $2::jsonb,
          updated_at = NOW()
        WHERE id = $1 AND care_home_id = $3
      `;
      
      await this.db.query(updateQuery, [
        supervisionId, 
        JSON.stringify([discussionPoint]), 
        careHomeId
      ]);
      
      this.logger.info('Discussion point added to supervision', {
        supervisionId,
        category: discussionPoint.category,
        topic: discussionPoint.topic
      });
    } catch (error) {
      this.logger.error('Failed to add discussion point', error);
      throw error;
    }
  }

  private async notifyComplianceTeam(report: any, careHomeId: string): Promise<void> {
    try {
      // Get compliance team members
      const complianceTeamQuery = `
        SELECT u.id, u.email, u.first_name, u.last_name 
        FROM users u
        JOIN user_roles ur ON u.id = ur.user_id
        JOIN roles r ON ur.role_id = r.id
        WHERE u.care_home_id = $1 
        AND r.name IN ('compliance_manager', 'quality_manager', 'admin')
        AND u.is_active = true
      `;
      
      const teamResult = await this.db.query(complianceTeamQuery, [careHomeId]);
      
      if (teamResult.rows.length === 0) {
        this.logger.warn('No compliance team members found for notification', { careHomeId });
        return;
      }
      
      // Create notifications for each team member
      for (const member of teamResult.rows) {
        const notificationQuery = `
          INSERT INTO supervision_notifications (
            supervision_id, notification_type, recipient_id, recipient_type,
            title, message, priority, care_home_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `;
        
        const title = `Compliance Report - Risk Level: ${report.riskLevel.toUpperCase()}`;
        const message = `A supervision compliance report has been generated requiring attention. 
          ReportID: ${report.reportId}
          SupervisionID: ${report.supervisionId}
          RiskLevel: ${report.riskLevel}
          ActionRequired: ${report.actionRequired ? 'Yes' : 'No'}`;
        
        await this.db.query(notificationQuery, [
          report.supervisionId,
          'compliance_alert',
          member.id,
          'compliance',
          title,
          message,
          report.riskLevel === 'critical' ? 'urgent' : 'high',
          careHomeId
        ]);
      }
      
      this.logger.info('Compliance team notified', {
        reportId: report.reportId,
        riskLevel: report.riskLevel,
        recipientCount: teamResult.rows.length
      });
    } catch (error) {
      this.logger.error('Failed to notify compliance team', error);
      // Don't throw error as notification failure shouldn't break supervision completion
    }
  }

  private async getSupervisionById(supervisionId: string, careHomeId: string): Promise<SupervisionSession | null> {
    try {
      const query = `
        SELECT * FROM supervision_sessions 
        WHERE id = $1 AND care_home_id = $2
      `;
      
      const result = await this.db.query(query, [supervisionId, careHomeId]);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      return this.mapToSupervisionSession(result.rows[0]);
    } catch (error) {
      this.logger.error('Failed to get supervision by ID', error);
      return null;
    }
  }
  
  /**
   * Map database row to SupervisionSession object
   */
  private mapToSupervisionSession(row: any): SupervisionSession {
    return {
      id: row.id,
      sessionId: row.session_id,
      supervisionNumber: row.supervision_number,
      supervisionType: row.supervision_type,
      staffMemberId: row.staff_member_id,
      supervisorId: row.supervisor_id,
      scheduledDate: row.scheduled_date,
      actualStartTime: row.actual_start_time,
      actualEndTime: row.actual_end_time,
      duration: row.duration,
      status: row.status,
      supervisionContext: JSON.parse(row.supervision_context || '{}'),
      discussionPoints: JSON.parse(row.discussion_points || '[]'),
      actionItems: JSON.parse(row.action_items || '[]'),
      outcomes: JSON.parse(row.outcomes || '[]'),
      aiSummary: row.ai_summary ? JSON.parse(row.ai_summary) : undefined,
      sentimentAnalysis: row.sentiment_analysis ? JSON.parse(row.sentiment_analysis) : undefined,
      complianceRating: row.compliance_rating ? JSON.parse(row.compliance_rating) : undefined,
      recordingEnabled: row.recording_enabled,
      recordingUrl: row.recording_url,
      transcriptUrl: row.transcript_url,
      documentsAttached: JSON.parse(row.documents_attached || '[]'),
      nextSupervisionDue: row.next_supervision_due,
      escalationRequired: row.escalation_required,
      hrNotificationSent: row.hr_notification_sent,
      complianceReportGenerated: row.compliance_report_generated,
      gdprCompliant: row.gdpr_compliant,
      retentionPeriod: row.retention_period,
      accessLevel: row.access_level,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      careHomeId: row.care_home_id
    };
  }

  private async createSupervisionNotifications(supervision: SupervisionSession, careHomeId: string): Promise<void> {
    try {
      const notifications = [];
      
      // Notification for staff member
      notifications.push({
        supervisionId: supervision.id,
        notificationType: 'scheduled',
        recipientId: supervision.staffMemberId,
        recipientType: 'staff_member',
        title: 'Supervision Scheduled',
        message: `Your ${supervision.supervisionType.replace('_', ' ')} has been scheduled for ${supervision.scheduledDate.toLocaleDateString()} at ${supervision.scheduledDate.toLocaleTimeString()}`,
        priority: 'normal'
      });
      
      // Notification for supervisor
      notifications.push({
        supervisionId: supervision.id,
        notificationType: 'scheduled',
        recipientId: supervision.supervisorId,
        recipientType: 'supervisor',
        title: 'Supervision to Conduct',
        message: `You are scheduled to conduct a ${supervision.supervisionType.replace('_', ' ')} on ${supervision.scheduledDate.toLocaleDateString()} at ${supervision.scheduledDate.toLocaleTimeString()}`,
        priority: 'normal'
      });
      
      // Insert notifications into database
      for (const notification of notifications) {
        const insertQuery = `
          INSERT INTO supervision_notifications (
            supervision_id, notification_type, recipient_id, recipient_type,
            title, message, priority, care_home_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `;
        
        await this.db.query(insertQuery, [
          notification.supervisionId,
          notification.notificationType,
          notification.recipientId,
          notification.recipientType,
          notification.title,
          notification.message,
          notification.priority,
          careHomeId
        ]);
      }
      
      this.logger.info('Supervision notifications created', {
        supervisionId: supervision.id,
        notificationCount: notifications.length
      });
    } catch (error) {
      this.logger.error('Failed to create supervision notifications', error);
      // Don't throw error as notification failure shouldn't break supervision creation
    }
  }

  private async startAIMonitoring(supervisionId: string, sessionId: string): Promise<void> {
    try {
      // In production, this would start real-time AI monitoring
      // Structure for real implementation:
      /*
      const monitoringConfig = {
        supervisionId,
        sessionId,
        features: {
          sentimentTracking: true,
          keywordDetection: true,
          engagementAnalysis: true,
          complianceMonitoring: true
        },
        alerts: {
          negativesentiment: 0.3,
          lowEngagement: 0.4,
          complianceKeywords: ['grievance', 'discrimination', 'harassment']
        }
      };
      
      await this.aiMonitoringService.startSession(monitoringConfig);
      */
      
      // For now, log that monitoring would be started
      this.logger.info('AI monitoring initiated', {
        supervisionId,
        sessionId,
        features: 'sentiment, engagement, compliance tracking'
      });
      
      // Update supervision record to indicate monitoring is active
      await this.db.query(`
        UPDATE supervision_sessions 
        SET ai_monitoring_active = true, updated_at = NOW()
        WHERE id = $1
      `, [supervisionId]);
    } catch (error) {
      this.logger.error('Failed to start AI monitoring', error);
      // Don't throw error as monitoring failure shouldn't break supervision start
    }
  }

  private async createActionItemReminders(actionItems: ActionItem[], supervisionId: string, careHomeId: string): Promise<void> {
    try {
      for (const item of actionItems) {
        // Insert action item into database
        const actionItemQuery = `
          INSERT INTO supervision_action_items (
            supervision_id, description, category, priority, assigned_to,
            assigned_by, due_date, status, progress, ai_generated,
            care_home_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
          RETURNING id
        `;
        
        const actionResult = await this.db.query(actionItemQuery, [
          supervisionId,
          item.description,
          item.category,
          item.priority,
          item.assignedTo,
          'system', // assigned_by - would be supervisor ID in real implementation
          item.dueDate,
          item.status,
          item.progress,
          item.aiGenerated,
          careHomeId
        ]);
        
        const actionItemId = actionResult.rows[0].id;
        
        // Create reminder notification
        const reminderQuery = `
          INSERT INTO supervision_notifications (
            supervision_id, notification_type, recipient_id, recipient_type,
            title, message, priority, care_home_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `;
        
        await this.db.query(reminderQuery, [
          supervisionId,
          'action_item_due',
          item.assignedTo,
          'staff_member',
          'Action Item Assigned',
          `You have been assigned an action item from your supervision: ${item.description}. Due date: ${item.dueDate.toLocaleDateString()}`,
          item.priority === 'urgent' ? 'urgent' : 'normal',
          careHomeId
        ]);
        
        this.logger.info('Action item reminder created', {
          actionItemId,
          supervisionId,
          assignedTo: item.assignedTo,
          dueDate: item.dueDate
        });
      }
    } catch (error) {
      this.logger.error('Failed to create action item reminders', error);
      throw error;
    }
  }

  private async handleEscalation(supervision: SupervisionSession, aiSummary: AISummary | undefined, careHomeId: string): Promise<void> {
    try {
      // Create escalation record
      const escalationId = uuidv4();
      const escalationQuery = `
        INSERT INTO supervision_escalations (
          id, supervision_id, escalation_reason, urgency_level,
          escalated_to, escalated_by, ai_recommended, care_home_id
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      `;
      
      const reason = aiSummary?.escalationSuggested 
        ? `AI recommended escalation: ${aiSummary.concernsIdentified.join(', ')}`
        : 'Manual escalation requested during supervision';
      
      // Get management team for escalation
      const managementQuery = `
        SELECT u.id FROM users u
        JOIN user_roles ur ON u.id = ur.user_id
        JOIN roles r ON ur.role_id = r.id
        WHERE u.care_home_id = $1 
        AND r.name IN ('manager', 'admin', 'senior_manager')
        AND u.is_active = true
        LIMIT 1
      `;
      
      const mgmtResult = await this.db.query(managementQuery, [careHomeId]);
      const escalatedTo = mgmtResult.rows[0]?.id || null;
      
      await this.db.query(escalationQuery, [
        escalationId,
        supervision.id,
        reason,
        'high',
        escalatedTo,
        supervision.supervisorId,
        !!aiSummary?.escalationSuggested,
        careHomeId
      ]);
      
      // Notify management
      if (escalatedTo) {
        const notificationQuery = `
          INSERT INTO supervision_notifications (
            supervision_id, notification_type, recipient_id, recipient_type,
            title, message, priority, care_home_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `;
        
        await this.db.query(notificationQuery, [
          supervision.id,
          'escalation',
          escalatedTo,
          'manager',
          'Supervision Escalation Required',
          `A supervision session has been escalated and requires management attention. Supervision: ${supervision.supervisionNumber}. Reason: ${reason}`,
          'urgent',
          careHomeId
        ]);
      }
      
      this.logger.info('Escalation handled', {
        escalationId,
        supervisionId: supervision.id,
        reason,
        escalatedTo
      });
    } catch (error) {
      this.logger.error('Failed to handle escalation', error);
      throw error;
    }
  }

  private async scheduleNextSupervision(supervision: SupervisionSession, careHomeId: string): Promise<void> {
    try {
      if (!supervision.nextSupervisionDue) {
        this.logger.info('No next supervision date calculated', { supervisionId: supervision.id });
        return;
      }
      
      // Check if next supervision already exists
      const existingQuery = `
        SELECT id FROM supervision_sessions 
        WHERE staff_member_id = $1 
        AND supervision_type = $2 
        AND scheduled_date >= $3
        AND status = 'scheduled'
        AND care_home_id = $4
      `;
      
      const existingResult = await this.db.query(existingQuery, [
        supervision.staffMemberId,
        supervision.supervisionType,
        supervision.nextSupervisionDue,
        careHomeId
      ]);
      
      if (existingResult.rows.length > 0) {
        this.logger.info('Next supervision already scheduled', {
          staffMemberId: supervision.staffMemberId,
          existingSupervisionId: existingResult.rows[0].id
        });
        return;
      }
      
      // Create next supervision session
      const nextSupervisionId = uuidv4();
      const nextSupervisionNumber = await this.generateSupervisionNumber(careHomeId);
      
      const insertQuery = `
        INSERT INTO supervision_sessions (
          id, supervision_number, supervision_type, staff_member_id,
          supervisor_id, scheduled_date, status, supervision_context,
          recording_enabled, gdpr_compliant, retention_period, access_level,
          care_home_id, previous_supervision_id
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      `;
      
      await this.db.query(insertQuery, [
        nextSupervisionId,
        nextSupervisionNumber,
        supervision.supervisionType,
        supervision.staffMemberId,
        supervision.supervisorId,
        supervision.nextSupervisionDue,
        'scheduled',
        JSON.stringify({
          previousSupervisionId: supervision.id,
          supervisionSequence: 'follow_up'
        }),
        false, // recording not enabled by default
        true,
        this.calculateRetentionPeriod(supervision.supervisionType),
        this.determineAccessLevel(supervision.supervisionType),
        careHomeId,
        supervision.id
      ]);
      
      // Create notification for next supervision
      const notificationQuery = `
        INSERT INTO supervision_notifications (
          supervision_id, notification_type, recipient_id, recipient_type,
          title, message, priority, care_home_id
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      `;
      
      await this.db.query(notificationQuery, [
        nextSupervisionId,
        'scheduled',
        supervision.staffMemberId,
        'staff_member',
        'Next Supervision Scheduled',
        `Your next ${supervision.supervisionType.replace('_', ' ')} has been scheduled for ${supervision.nextSupervisionDue.toLocaleDateString()}`,
        'normal',
        careHomeId
      ]);
      
      this.logger.info('Next supervision scheduled', {
        nextSupervisionId,
        staffMemberId: supervision.staffMemberId,
        scheduledDate: supervision.nextSupervisionDue,
        previousSupervisionId: supervision.id
      });
    } catch (error) {
      this.logger.error('Failed to schedule next supervision', error);
      // Don't throw error as this shouldn't break supervision completion
    }
  }

  private async generateSupervisionNumber(careHomeId: string): Promise<string> {
    const year = new Date().getFullYear();
    const month = String(new Date().getMonth() + 1).padStart(2, '0');
    const count = Math.floor(Math.random() * 1000) + 1;
    return `SUP-${year}-${month}-${String(count).padStart(3, '0')}`;
  }

  private calculateNextSupervisionDate(supervisionType: string, currentDate: Date): Date {
    const nextDate = new Date(currentDate);
    switch (supervisionType) {
      case 'monthly_supervision': nextDate.setMonth(nextDate.getMonth() + 1); break;
      case 'annual_appraisal': nextDate.setFullYear(nextDate.getFullYear() + 1); break;
      default: nextDate.setMonth(nextDate.getMonth() + 3);
    }
    return nextDate;
  }

  private calculateRetentionPeriod(supervisionType: string): number {
    constperiods: Record<string, number> = {
      annual_appraisal: 2555, disciplinary: 2555, capability: 2555, 
      grievance: 2555, monthly_supervision: 1825, return_to_work: 1825, probation_review: 1825
    };
    return periods[supervisionType] || 1825;
  }

  private determineAccessLevel(supervisionType: string): 'confidential' | 'restricted' | 'internal' {
    const confidential = ['disciplinary', 'capability', 'grievance'];
    const restricted = ['annual_appraisal', 'return_to_work'];
    if (confidential.includes(supervisionType)) return 'confidential';
    if (restricted.includes(supervisionType)) return 'restricted';
    return 'internal';
  }

  // =====================================================
  // ROUTE DEFINITIONS
  // =====================================================

  getRoutes(): express.Router {
    const router = express.Router();

    const createSupervisionValidation = [
      body('supervisionType').isIn(['annual_appraisal', 'monthly_supervision', 'disciplinary', 'return_to_work', 'probation_review', 'capability', 'grievance']),
      body('staffMemberId').isUUID(),
      body('supervisorId').isUUID(),
      body('scheduledDate').isISO8601(),
      body('recordingRequired').isBoolean(),
      body('aiSummarizationEnabled').isBoolean()
    ];

    const supervisionIdValidation = [param('supervisionId').isUUID()];

    router.post('/supervisions', createSupervisionValidation, this.createSupervision.bind(this));
    router.post('/supervisions/:supervisionId/start', supervisionIdValidation, this.startSupervision.bind(this));
    router.post('/supervisions/:supervisionId/complete', supervisionIdValidation, this.completeSupervision.bind(this));
    router.get('/supervisions/analytics', this.getSupervisionAnalytics.bind(this));

    return router;
  }
}
