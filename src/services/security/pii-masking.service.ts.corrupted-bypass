import { logger } from '../../utils/logger';
import { PilotFeedbackEvent } from '../../types/pilot-feedback-agent.types';

export class PIIMaskingService {
  private readonly PHI_PATTERNS = {
    // UK NHS Number (10 digits, may have spaces)
    nhsNumber: /\b\d{3}\s?\d{3}\s?\d{4}\b/g,
    
    // UK Postcode
    postcode: /\b[A-Z]{1,2}\d[A-Z\d]?\s?\d[A-Z]{2}\b/g,
    
    // Email addresses
    email: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
    
    // Phone numbers (UK format)
    phone: /\b(?:\+44|0)[1-9]\d{8,9}\b/g,
    
    // Names (capitalized words, 2+ words)
    names: /\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/g,
    
    // Dates (various formats)
    dates: /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/g,
    
    // Addresses (numbers followed by street names)
    addresses: /\b\d+\s+[A-Za-z\s]+(?:Street|Road|Avenue|Lane|Drive|Close|Way|Place)\b/g,
    
    // Medical record numbers
    medicalRecord: /\bMRN\d{6,10}\b/g,
    
    // Care home room numbers
    roomNumber: /\bRoom\s?\d{1,3}[A-Z]?\b/gi,
    
    // Staff ID patterns
    staffId: /\b(?:STAFF|EMP|USER)\d{4,8}\b/gi
  };

  private readonly REPLACEMENTS = {
    nhsNumber: '[NHS_NUMBER]',
    postcode: '[POSTCODE]',
    email: '[EMAIL]',
    phone: '[PHONE]',
    names: '[NAME]',
    dates: '[DATE]',
    addresses: '[ADDRESS]',
    medicalRecord: '[MEDICAL_RECORD]',
    roomNumber: '[ROOM]',
    staffId: '[STAFF_ID]'
  };

  /**
   * Mask PII in a single feedback event
   */
  async maskEvent(event: PilotFeedbackEvent): Promise<PilotFeedbackEvent> {
    const maskedText = await this.maskText(event.text);
    
    return {
      ...event,
      text: maskedText
    };
  }

  /**
   * Mask PII in multiple feedback events
   */
  async maskEvents(events: PilotFeedbackEvent[]): Promise<PilotFeedbackEvent[]> {
    return Promise.all(events.map(event => this.maskEvent(event)));
  }

  /**
   * Mask PII in text content
   */
  async maskText(text: string): Promise<string> {
    let maskedText = text;
    let maskingCount = 0;

    // Apply each pattern
    for (const [patternName, pattern] of Object.entries(this.PHI_PATTERNS)) {
      const matches = maskedText.match(pattern);
      if (matches) {
        maskedText = maskedText.replace(pattern, this.REPLACEMENTS[patternName as keyof typeof this.REPLACEMENTS]);
        maskingCount += matches.length;
      }
    }

    // Additional context-aware masking
    maskedText = await this.applyContextualMasking(maskedText);

    // Log masking activity
    if (maskingCount > 0) {
      logger.info('PII masking applied', {
        originalLength: text.length,
        maskedLength: maskedText.length,
        patternsMatched: maskingCount,
        maskingRate: (maskingCount / text.split(/\s+/).length) * 100
      });
    }

    return maskedText;
  }

  /**
   * Apply context-aware masking for healthcare-specific terms
   */
  private async applyContextualMasking(text: string): Promise<string> {
    let maskedText = text;

    // Mask medication names (common patterns)
    const medicationPatterns = [
      /\b(?:paracetamol|ibuprofen|aspirin|morphine|fentanyl|oxycodone|codeine)\b/gi,
      /\b(?:mg|mcg|ml|tablet|capsule|injection|syrup)\b/gi,
      /\b(?:twice daily|three times daily|once daily|as needed|PRN)\b/gi
    ];

    for (const pattern of medicationPatterns) {
      maskedText = maskedText.replace(pattern, '[MEDICATION]');
    }

    // Mask care-related terms that might contain PII
    const carePatterns = [
      /\b(?:resident|patient|client)\s+\d+/gi,
      /\b(?:care home|nursing home|residential home)\s+[A-Za-z\s]+/gi,
      /\b(?:GP|doctor|nurse|carer|staff)\s+[A-Z][a-z]+\b/gi
    ];

    for (const pattern of carePatterns) {
      maskedText = maskedText.replace(pattern, '[CARE_CONTEXT]');
    }

    // Mask time references that might be too specific
    const timePatterns = [
      /\b(?:at\s+)?\d{1,2}:\d{2}(?:\s*[AP]M)?\b/gi,
      /\b(?:yesterday|today|tomorrow|this morning|this afternoon|this evening)\b/gi
    ];

    for (const pattern of timePatterns) {
      maskedText = maskedText.replace(pattern, '[TIME]');
    }

    return maskedText;
  }

  /**
   * Validate that no PII remains in text
   */
  async validateMasking(text: string): Promise<{
    isClean: boolean;
    remainingPatterns: string[];
    confidence: number;
  }> {
    const remainingPatterns: string[] = [];
    let totalMatches = 0;

    // Check for remaining PII patterns
    for (const [patternName, pattern] of Object.entries(this.PHI_PATTERNS)) {
      const matches = text.match(pattern);
      if (matches) {
        remainingPatterns.push(patternName);
        totalMatches += matches.length;
      }
    }

    // Calculate confidence score
    const wordCount = text.split(/\s+/).length;
    const confidence = Math.max(0, 100 - (totalMatches / wordCount) * 100);

    return {
      isClean: remainingPatterns.length === 0,
      remainingPatterns,
      confidence: Math.round(confidence)
    };
  }

  /**
   * Get masking statistics for a batch of events
   */
  async getMaskingStats(events: PilotFeedbackEvent[]): Promise<{
    totalEvents: number;
    eventsWithPII: number;
    totalPatternsMasked: number;
    averageMaskingRate: number;
    patternsByFrequency: Record<string, number>;
  }> {
    let eventsWithPII = 0;
    let totalPatternsMasked = 0;
    const patternsByFrequency: Record<string, number> = {};

    for (const event of events) {
      const originalText = event.text;
      const maskedText = await this.maskText(originalText);
      
      if (originalText !== maskedText) {
        eventsWithPII++;
      }

      // Count patterns in original text
      for (const [patternName, pattern] of Object.entries(this.PHI_PATTERNS)) {
        const matches = originalText.match(pattern);
        if (matches) {
          patternsByFrequency[patternName] = (patternsByFrequency[patternName] || 0) + matches.length;
          totalPatternsMasked += matches.length;
        }
      }
    }

    const totalWords = events.reduce((sum, event) => sum + event.text.split(/\s+/).length, 0);
    const averageMaskingRate = totalWords > 0 ? (totalPatternsMasked / totalWords) * 100 : 0;

    return {
      totalEvents: events.length,
      eventsWithPII,
      totalPatternsMasked,
      averageMaskingRate: Math.round(averageMaskingRate * 100) / 100,
      patternsByFrequency
    };
  }

  /**
   * Check if text contains any PII patterns
   */
  async containsPII(text: string): Promise<boolean> {
    for (const pattern of Object.values(this.PHI_PATTERNS)) {
      if (pattern.test(text)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Get a summary of what was masked in text
   */
  async getMaskingSummary(text: string): Promise<{
    originalText: string;
    maskedText: string;
    patternsFound: string[];
    maskingRate: number;
  }> {
    const maskedText = await this.maskText(text);
    const patternsFound: string[] = [];

    for (const [patternName, pattern] of Object.entries(this.PHI_PATTERNS)) {
      if (pattern.test(text)) {
        patternsFound.push(patternName);
      }
    }

    const wordCount = text.split(/\s+/).length;
    const maskedWordCount = (text.match(/\[[A-Z_]+\]/g) || []).length;
    const maskingRate = wordCount > 0 ? (maskedWordCount / wordCount) * 100 : 0;

    return {
      originalText: text,
      maskedText,
      patternsFound,
      maskingRate: Math.round(maskingRate * 100) / 100
    };
  }

  /**
   * Redact sensitive information for audit logs
   */
  async redactForAudit(data: any): Promise<any> {
    if (typeof data === 'string') {
      return await this.maskText(data);
    }

    if (Array.isArray(data)) {
      return Promise.all(data.map(item => this.redactForAudit(item)));
    }

    if (typeof data === 'object' && data !== null) {
      const redacted: any = {};
      for (const [key, value] of Object.entries(data)) {
        // Skip redaction for certain safe keys
        if (['id', 'timestamp', 'createdAt', 'updatedAt'].includes(key)) {
          redacted[key] = value;
        } else {
          redacted[key] = await this.redactForAudit(value);
        }
      }
      return redacted;
    }

    return data;
  }
}