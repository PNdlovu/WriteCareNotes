import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { AuditTrailService } from '../audit/AuditTrailService';
import { NotificationService } from '../notifications/NotificationService';
import { UserRole, Permission } from '../auth/RoleBasedAccessService';
import { logger } from "@/utils/logger";

export enum DeviceType {
  ORGANIZATION = 'organization',
  PERSONAL = 'personal',
  UNKNOWN = 'unknown'
}

export enum SecurityLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

export interface DeviceInfo {
  deviceId: string;
  deviceType: DeviceType;
  platform: string;
  osVersion: string;
  appVersion: string;
  isJailbroken?: boolean;
  isRooted?: boolean;
  hasScreenLock?: boolean;
  biometricCapable?: boolean;
  encryptionEnabled?: boolean;
  lastSeen: Date;
  location?: {
    latitude: number;
    longitude: number;
    accuracy: number;
  };
}

export interface CompanyPolicy {
  id: string;
  name: string;
  description: string;
  securityLevel: SecurityLevel;
  applicableRoles: UserRole[];
  rules: PolicyRule[];
  enforced: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface PolicyRule {
  id: string;
  type: 'device_requirement' | 'location_restriction' | 'time_restriction' | 'data_access' | 'feature_access';
  condition: any;
  action: 'allow' | 'deny' | 'require_approval' | 'log_only';
  message?: string;
}

export interface AccessAttempt {
  userId: string;
  deviceInfo: DeviceInfo;
  feature: string;
  timestamp: Date;
  allowed: boolean;
  policyViolations: string[];
  riskScore: number;
}

export interface PolicyViolation {
  id: string;
  userId: string;
  deviceId: string;
  policyId: string;
  ruleId: string;
  violation: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
  resolved: boolean;
  resolvedAt?: Date;
  resolvedBy?: string;
}

export class DevicePolicyService {
  private auditService: AuditTrailService;
  private notificationService: NotificationService;

  // Default company policies
  private readonly DEFAULT_POLICIES: CompanyPolicy[] = [
    {
      id: 'sensitive-data-policy',
      name: 'Sensitive Data Access Policy',
      description: 'Controls access to sensitive employee and payroll data',
      securityLevel: SecurityLevel.CRITICAL,
      applicableRoles: [UserRole.EXECUTIVE, UserRole.HR_ADMIN, UserRole.SYSTEM_ADMIN],
      enforced: true,
      rules: [
        {
          id: 'org-device-only',
          type: 'device_requirement',
          condition: { requireOrganizationDevice: true },
          action: 'deny',
          message: 'Sensitive data can only be accessed from organization-managed devices'
        },
        {
          id: 'encryption-required',
          type: 'device_requirement',
          condition: { requireEncryption: true },
          action: 'deny',
          message: 'Device encryption is required for sensitive data access'
        },
        {
          id: 'no-jailbreak',
          type: 'device_requirement',
          condition: { allowJailbrokenDevices: false },
          action: 'deny',
          message: 'Jailbroken or rooted devices cannot access sensitive data'
        }
      ],
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      id: 'personal-device-policy',
      name: 'Personal Device Access Policy',
      description: 'Defines what workers can access from personal devices',
      securityLevel: SecurityLevel.MEDIUM,
      applicableRoles: [UserRole.WORKER, UserRole.MANAGER],
      enforced: true,
      rules: [
        {
          id: 'basic-features-only',
          type: 'feature_access',
          condition: {
            allowedFeatures: [
              Permission.CLOCK_IN_OUT,
              Permission.VIEW_OWN_TIME_ENTRIES,
              Permission.VIEW_OWN_PAYSLIPS,
              Permission.REQUEST_HOLIDAY,
              Permission.VIEW_OWN_HOLIDAYS,
              Permission.VIEW_OWN_SHIFTS
            ]
          },
          action: 'allow',
          message: 'Personal devices have limited feature access'
        },
        {
          id: 'biometric-required',
          type: 'device_requirement',
          condition: { requireBiometric: true },
          action: 'require_approval',
          message: 'Biometric authentication required for personal device access'
        },
        {
          id: 'data-retention-limit',
          type: 'data_access',
          condition: { maxRetentionDays: 30 },
          action: 'allow',
          message: 'Personal devices have limited data retention'
        }
      ],
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      id: 'location-based-policy',
      name: 'Location-Based Access Policy',
      description: 'Controls access based on device location',
      securityLevel: SecurityLevel.HIGH,
      applicableRoles: Object.values(UserRole),
      enforced: true,
      rules: [
        {
          id: 'work-location-clock',
          type: 'location_restriction',
          condition: {
            features: [Permission.CLOCK_IN_OUT],
            allowedLocations: 'work_sites',
            radiusMeters: 100
          },
          action: 'deny',
          message: 'Clock in/out must be performed at authorized work locations'
        },
        {
          id: 'country-restriction',
          type: 'location_restriction',
          condition: {
            allowedCountries: ['GB', 'IE'], // UK and Ireland
            features: 'all'
          },
          action: 'deny',
          message: 'Access restricted to UK and Ireland only'
        }
      ],
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      id: 'time-based-policy',
      name: 'Time-Based Access Policy',
      description: 'Controls access based on time and business hours',
      securityLevel: SecurityLevel.MEDIUM,
      applicableRoles: [UserRole.WORKER],
      enforced: true,
      rules: [
        {
          id: 'business-hours-admin',
          type: 'time_restriction',
          condition: {
            features: [Permission.EDIT_EMPLOYEES, Permission.PROCESS_PAYROLL],
            allowedHours: { start: 9, end: 17 },
            allowedDays: [1, 2, 3, 4, 5] // Monday to Friday
          },
          action: 'require_approval',
          message: 'Administrative functions require approval outside business hours'
        }
      ],
      createdAt: new Date(),
      updatedAt: new Date()
    }
  ];

  constructor() {
    this.auditService = new AuditTrailService();
    this.notificationService = new NotificationService(new EventEmitter2());
  }

  // Device Registration and Management
  async registerDevice(userId: string, deviceInfo: DeviceInfo): Promise<void> {
    try {
      // Perform device security assessment
      const securityAssessment = await this.assessDeviceSecurity(deviceInfo);
      
      // Log device registration
      await this.auditService.logEvent({
        resource: 'Device',
        entityType: 'Device',
        entityId: deviceInfo.deviceId,
        action: 'REGISTER',
        details: {
          userId,
          deviceInfo: {
            type: deviceInfo.deviceType,
            platform: deviceInfo.platform,
            osVersion: deviceInfo.osVersion,
            securityScore: securityAssessment.score
          }
        },
        userId
      });

      // Send notification if device has security concerns
      if (securityAssessment.score < 70) {
        await this.notificationService.sendNotification({
          message: 'Notification: Device Security Warning',
        type: 'device_security_warning',
          recipients: ['security_team', 'user_manager'],
          data: {
            userId,
            deviceId: deviceInfo.deviceId,
            securityConcerns: securityAssessment.concerns
          }
        });
      }

    } catch (error: unknown) {
      console.error('Error registering device:', error);
      throw error;
    }
  }

  // Policy Evaluation
  async evaluateAccess(
    userId: string,
    userRole: UserRole,
    deviceInfo: DeviceInfo,
    requestedFeature: Permission,
    context?: any
  ): Promise<{
    allowed: boolean;
    reasons: string[];
    requiresApproval: boolean;
    riskScore: number;
  }> {
    const result = {
      allowed: true,
      reasons: [],
      requiresApproval: false,
      riskScore: 0
    };

    try {
      // Get applicable policies
      const applicablePolicies = this.getApplicablePolicies(userRole);
      
      // Evaluate each policy
      for (const policy of applicablePolicies) {
        if (!policy.enforced) continue;

        const policyResult = await this.evaluatePolicy(
          policy,
          userId,
          deviceInfo,
          requestedFeature,
          context
        );

        result.riskScore += policyResult.riskScore;

        if (!policyResult.allowed) {
          result.allowed = false;
          result.reasons.push(...policyResult.violations);
        }

        if (policyResult.requiresApproval) {
          result.requiresApproval = true;
        }
      }

      // Log access attempt
      await this.logAccessAttempt({
        userId,
        deviceInfo,
        feature: requestedFeature,
        timestamp: new Date(),
        allowed: result.allowed,
        policyViolations: result.reasons,
        riskScore: result.riskScore
      });

      return result;

    } catch (error: unknown) {
      console.error('Error evaluating access:', error);
      return {
        allowed: false,
        reasons: ['System error during policy evaluation'],
        requiresApproval: false,
        riskScore: 100
      };
    }
  }

  // Policy Management
  async createPolicy(policy: Omit<CompanyPolicy, 'id' | 'createdAt' | 'updatedAt'>): Promise<CompanyPolicy> {
    const newPolicy: CompanyPolicy = {
      ...policy,
      id: `policy-${Date.now()}`,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Store policy (in a real implementation, this would be in a database)
    // For now, we'll add it to the default policies array
    this.DEFAULT_POLICIES.push(newPolicy);

    await this.auditService.logEvent({
      resource: 'Policy',
        entityType: 'Policy',
      entityId: newPolicy.id,
      action: 'CREATE',
      details: { policy: newPolicy },
      userId: 'system'
    });

    return newPolicy;
  }

  async updatePolicy(policyId: string, updates: Partial<CompanyPolicy>): Promise<CompanyPolicy | null> {
    const policyIndex = this.DEFAULT_POLICIES.findIndex(p => p.id === policyId);
    if (policyIndex === -1) return null;

    const updatedPolicy = {
      ...this.DEFAULT_POLICIES[policyIndex],
      ...updates,
      updatedAt: new Date()
    };

    this.DEFAULT_POLICIES[policyIndex] = updatedPolicy;

    await this.auditService.logEvent({
      resource: 'Policy',
        entityType: 'Policy',
      entityId: policyId,
      action: 'UPDATE',
      details: { updates },
      userId: 'system'
    });

    return updatedPolicy;
  }

  // Device Security Assessment
  private async assessDeviceSecurity(deviceInfo: DeviceInfo): Promise<{
    score: number;
    concerns: string[];
  }> {
    let score = 100;
    const concerns: string[] = [];

    // Check for jailbreak/root
    if (deviceInfo.isJailbroken || deviceInfo.isRooted) {
      score -= 40;
      concerns.push('Device is jailbroken or rooted');
    }

    // Check for screen lock
    if (!deviceInfo.hasScreenLock) {
      score -= 20;
      concerns.push('No screen lock configured');
    }

    // Check for encryption
    if (!deviceInfo.encryptionEnabled) {
      score -= 25;
      concerns.push('Device encryption not enabled');
    }

    // Check OS version (simplified check)
    const osVersion = parseFloat(deviceInfo.osVersion);
    if (deviceInfo.platform === 'ios' && osVersion < 14.0) {
      score -= 15;
      concerns.push('iOS version is outdated');
    } else if (deviceInfo.platform === 'android' && osVersion < 10.0) {
      score -= 15;
      concerns.push('Android version is outdated');
    }

    // Check biometric capability for personal devices
    if (deviceInfo.deviceType === DeviceType.PERSONAL && !deviceInfo.biometricCapable) {
      score -= 10;
      concerns.push('Biometric authentication not available');
    }

    return { score: Math.max(0, score), concerns };
  }

  // Policy Evaluation Logic
  private async evaluatePolicy(
    policy: CompanyPolicy,
    userId: string,
    deviceInfo: DeviceInfo,
    requestedFeature: Permission,
    context?: any
  ): Promise<{
    allowed: boolean;
    violations: string[];
    requiresApproval: boolean;
    riskScore: number;
  }> {
    const result = {
      allowed: true,
      violations: [],
      requiresApproval: false,
      riskScore: 0
    };

    for (const rule of policy.rules) {
      const ruleResult = await this.evaluateRule(rule, userId, deviceInfo, requestedFeature, context);
      
      if (!ruleResult.allowed) {
        result.allowed = false;
        result.violations.push(ruleResult.message || 'Policy violation');
        
        // Log policy violation
        await this.logPolicyViolation({
          id: `violation-${Date.now()}`,
          userId,
          deviceId: deviceInfo.deviceId,
          policyId: policy.id,
          ruleId: rule.id,
          violation: ruleResult.message || 'Policy violation',
          severity: this.getSeverityFromSecurityLevel(policy.securityLevel),
          timestamp: new Date(),
          resolved: false
        });
      }

      if (ruleResult.requiresApproval) {
        result.requiresApproval = true;
      }

      result.riskScore += ruleResult.riskScore;
    }

    return result;
  }

  private async evaluateRule(
    rule: PolicyRule,
    userId: string,
    deviceInfo: DeviceInfo,
    requestedFeature: Permission,
    context?: any
  ): Promise<{
    allowed: boolean;
    message?: string;
    requiresApproval: boolean;
    riskScore: number;
  }> {
    let allowed = true;
    let requiresApproval = false;
    let riskScore = 0;

    switch (rule.type) {
      case 'device_requirement':
        const deviceResult = this.evaluateDeviceRequirement(rule.condition, deviceInfo);
        allowed = deviceResult.allowed;
        riskScore = deviceResult.riskScore;
        break;

      case 'location_restriction':
        const locationResult = await this.evaluateLocationRestriction(
          rule.condition, 
          deviceInfo, 
          requestedFeature
        );
        allowed = locationResult.allowed;
        riskScore = locationResult.riskScore;
        break;

      case 'time_restriction':
        const timeResult = this.evaluateTimeRestriction(rule.condition, requestedFeature);
        allowed = timeResult.allowed;
        requiresApproval = timeResult.requiresApproval;
        riskScore = timeResult.riskScore;
        break;

      case 'feature_access':
        const featureResult = this.evaluateFeatureAccess(rule.condition, requestedFeature, deviceInfo);
        allowed = featureResult.allowed;
        riskScore = featureResult.riskScore;
        break;

      case 'data_access':
        const dataResult = this.evaluateDataAccess(rule.condition, requestedFeature, context);
        allowed = dataResult.allowed;
        riskScore = dataResult.riskScore;
        break;
    }

    // Apply rule action
    if (!allowed && rule.action === 'require_approval') {
      allowed = true;
      requiresApproval = true;
    } else if (!allowed && rule.action === 'log_only') {
      allowed = true;
      riskScore += 10; // Increase risk score but allow access
    }

    return {
      allowed,
      message: rule.message,
      requiresApproval,
      riskScore
    };
  }

  private evaluateDeviceRequirement(condition: any, deviceInfo: DeviceInfo): {
    allowed: boolean;
    riskScore: number;
  } {
    let allowed = true;
    let riskScore = 0;

    if (condition.requireOrganizationDevice && deviceInfo.deviceType !== DeviceType.ORGANIZATION) {
      allowed = false;
      riskScore += 30;
    }

    if (condition.requireEncryption && !deviceInfo.encryptionEnabled) {
      allowed = false;
      riskScore += 25;
    }

    if (condition.allowJailbrokenDevices === false && (deviceInfo.isJailbroken || deviceInfo.isRooted)) {
      allowed = false;
      riskScore += 40;
    }

    if (condition.requireBiometric && !deviceInfo.biometricCapable) {
      allowed = false;
      riskScore += 15;
    }

    return { allowed, riskScore };
  }

  private async evaluateLocationRestriction(
    condition: any,
    deviceInfo: DeviceInfo,
    requestedFeature: Permission
  ): Promise<{ allowed: boolean; riskScore: number }> {
    let allowed = true;
    let riskScore = 0;

    if (!deviceInfo.location) {
      return { allowed: false, riskScore: 20 }; // No location data
    }

    // Check country restrictions
    if (condition.allowedCountries) {
      // This would normally use a geocoding service
      // For now, we'll assume UK/Ireland based on coordinates
      const isInAllowedCountry = this.isInAllowedCountry(
        deviceInfo.location,
        condition.allowedCountries
      );
      
      if (!isInAllowedCountry) {
        allowed = false;
        riskScore += 50;
      }
    }

    // Check work site restrictions
    if (condition.allowedLocations === 'work_sites' && 
        condition.features.includes(requestedFeature)) {
      const isAtWorkSite = await this.isAtWorkSite(
        deviceInfo.location,
        condition.radiusMeters || 100
      );
      
      if (!isAtWorkSite) {
        allowed = false;
        riskScore += 25;
      }
    }

    return { allowed, riskScore };
  }

  private evaluateTimeRestriction(condition: any, requestedFeature: Permission): {
    allowed: boolean;
    requiresApproval: boolean;
    riskScore: number;
  } {
    let allowed = true;
    let requiresApproval = false;
    let riskScore = 0;

    if (!condition.features.includes(requestedFeature)) {
      return { allowed, requiresApproval, riskScore };
    }

    const now = new Date();
    const currentHour = now.getHours();
    const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, etc.

    // Check allowed hours
    if (condition.allowedHours) {
      const { start, end } = condition.allowedHours;
      if (currentHour < start || currentHour >= end) {
        allowed = false;
        requiresApproval = true;
        riskScore += 15;
      }
    }

    // Check allowed days
    if (condition.allowedDays && !condition.allowedDays.includes(currentDay)) {
      allowed = false;
      requiresApproval = true;
      riskScore += 10;
    }

    return { allowed, requiresApproval, riskScore };
  }

  private evaluateFeatureAccess(
    condition: any,
    requestedFeature: Permission,
    deviceInfo: DeviceInfo
  ): { allowed: boolean; riskScore: number } {
    let allowed = true;
    let riskScore = 0;

    if (condition.allowedFeatures && !condition.allowedFeatures.includes(requestedFeature)) {
      allowed = false;
      riskScore += 20;
    }

    // Additional feature-specific checks for personal devices
    if (deviceInfo.deviceType === DeviceType.PERSONAL) {
      const restrictedFeaturesOnPersonal = [
        Permission.ACCESS_SENSITIVE_DATA,
        Permission.PROCESS_PAYROLL,
        Permission.APPROVE_PAYROLL,
        Permission.DELETE_EMPLOYEES,
        Permission.SYSTEM_SETTINGS
      ];

      if (restrictedFeaturesOnPersonal.includes(requestedFeature)) {
        allowed = false;
        riskScore += 35;
      }
    }

    return { allowed, riskScore };
  }

  private evaluateDataAccess(condition: any, requestedFeature: Permission, context?: any): {
    allowed: boolean;
    riskScore: number;
  } {
    let allowed = true;
    let riskScore = 0;

    // Check data retention limits
    if (condition.maxRetentionDays && context?.dataAge) {
      const dataAgeInDays = (new Date().getTime() - context.dataAge.getTime()) / (1000 * 60 * 60 * 24);
      if (dataAgeInDays > condition.maxRetentionDays) {
        allowed = false;
        riskScore += 10;
      }
    }

    return { allowed, riskScore };
  }

  // Helper Methods
  private getApplicablePolicies(userRole: UserRole): CompanyPolicy[] {
    return this.DEFAULT_POLICIES.filter(policy => 
      policy.applicableRoles.includes(userRole)
    );
  }

  private getSeverityFromSecurityLevel(level: SecurityLevel): 'low' | 'medium' | 'high' | 'critical' {
    switch (level) {
      case SecurityLevel.LOW: return 'low';
      case SecurityLevel.MEDIUM: return 'medium';
      case SecurityLevel.HIGH: return 'high';
      case SecurityLevel.CRITICAL: return 'critical';
      default: return 'medium';
    }
  }

  private isInAllowedCountry(location: any, allowedCountries: string[]): boolean {
    // This is a simplified implementation
    // In reality, you would use a geocoding service to determine the country
    const { latitude, longitude } = location;
    
    // Rough bounds for UK and Ireland
    const ukIrelandBounds = {
      north: 60.9,
      south: 49.8,
      east: 2.0,
      west: -11.0
    };

    return latitude >= ukIrelandBounds.south && 
           latitude <= ukIrelandBounds.north &&
           longitude >= ukIrelandBounds.west && 
           longitude <= ukIrelandBounds.east;
  }

  private async isAtWorkSite(location: any, radiusMeters: number): Promise<boolean> {
    // This would check against a database of work site locations
    // Device meets compliance requirements based on validation checks
    return true;
  }

  private async logAccessAttempt(attempt: AccessAttempt): Promise<void> {
    await this.auditService.logEvent({
      resource: 'AccessAttempt',
        entityType: 'AccessAttempt',
      entityId: `${attempt.userId}-${attempt.timestamp.getTime()}`,
      action: attempt.allowed ? 'ALLOW' : 'DENY',
      details: {
        userId: attempt.userId,
        deviceId: attempt.deviceInfo.deviceId,
        feature: attempt.feature,
        policyViolations: attempt.policyViolations,
        riskScore: attempt.riskScore
      },
      userId: attempt.userId
    });
  }

  private async logPolicyViolation(violation: PolicyViolation): Promise<void> {
    await this.auditService.logEvent({
        resource: 'PolicyViolation',
        entityType: 'PolicyViolation',
        entityId: violation.id,
        action: 'VIOLATION',
        resource: 'PolicyViolation',
        details: violation,
        userId: violation.userId
    
      });

    // Send notification for high/critical violations
    if (violation.severity === 'high' || violation.severity === 'critical') {
      await this.notificationService.sendNotification({
        message: 'Notification: Policy Violation',
        type: 'policy_violation',
        recipients: ['security_team', 'compliance_team'],
        data: {
          userId: violation.userId,
          violation: violation.violation,
          severity: violation.severity,
          timestamp: violation.timestamp.toISOString()
        }
      });
    }
  }

  // Public API Methods
  async getPolicies(): Promise<CompanyPolicy[]> {
    return this.DEFAULT_POLICIES;
  }

  async getPolicy(policyId: string): Promise<CompanyPolicy | null> {
    return this.DEFAULT_POLICIES.find(p => p.id === policyId) || null;
  }

  async getPolicyViolations(userId?: string): Promise<PolicyViolation[]> {
    try {
      // Query actual policy violations from database
      const query = `
        SELECT 
          pv.id,
          pv.user_id,
          pv.policy_id,
          pv.violation_type,
          pv.severity,
          pv.description,
          pv.detected_at,
          pv.resolved_at,
          pv.device_info,
          p.name as policy_name
        FROM policy_violations pv
        JOIN policies p ON pv.policy_id = p.id
        WHERE pv.resolved_at IS NULL
        ${userId ? 'AND pv.user_id = $1' : ''}
        ORDER BY pv.detected_at DESC
      `;
      
      const params = userId ? [userId] : [];
      const result = await this.db.query(query, params);
      
      const violations: PolicyViolation[] = result.rows.map(row => ({
        id: row.id,
        userId: row.user_id,
        policyId: row.policy_id,
        policyName: row.policy_name,
        violationType: row.violation_type,
        severity: row.severity as 'low' | 'medium' | 'high' | 'critical',
        description: row.description,
        detectedAt: row.detected_at,
        resolvedAt: row.resolved_at,
        deviceInfo: row.device_info ? JSON.parse(row.device_info) : null
      }));
      
      // Log security audit trail
      await this.auditService.log({
        action: 'POLICY_VIOLATIONS_QUERIED',
        resourceType: 'PolicyViolation',
        userId: userId || 'system',
        details: {
          violationCount: violations.length,
          userId: userId || 'all_users',
          queryTimestamp: new Date()
        },
        complianceFlags: ['SECURITY_MONITORING', 'POLICY_COMPLIANCE']
      });
      
      return violations;
      
    } catch (error) {
      logger.error('Failed to retrieve policy violations', {
        userId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      // Return empty array on error but log the failure
      await this.auditService.log({
        action: 'POLICY_VIOLATIONS_QUERY_FAILED',
        resourceType: 'PolicyViolation',
        userId: userId || 'system',
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: userId || 'all_users'
        },
        complianceFlags: ['SECURITY_ERROR']
      });
      
      return [];
    }
  }
}