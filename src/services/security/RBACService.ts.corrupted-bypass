import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { AccessControlUser, AccessLevel, Permission, AuthenticationMethod } from '../../entities/security/AccessControlUser';
import { SecurityComplianceService } from './SecurityComplianceService';
import { NotificationService } from '../notifications/NotificationService';
import { logger } from '../../utils/logger';

export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  inheritsFrom?: string[];
  organizationId?: string;
  tenantId: string;
  isSystemRole: boolean;
  isActive: boolean;
  createdBy: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface UserRoleAssignment {
  id: string;
  userId: string;
  roleId: string;
  organizationId?: string;
  tenantId: string;
  assignedBy: string;
  assignedAt: Date;
  expiresAt?: Date;
  isActive: boolean;
  conditions?: RoleCondition[];
}

export interface RoleCondition {
  field: string;
  operator: 'equals' | 'not_equals' | 'in' | 'not_in' | 'contains' | 'greater_than' | 'less_than';
  value: any;
  context?: 'user' | 'organization' | 'tenant' | 'resource' | 'time' | 'location';
}

export interface PermissionCheck {
  userId: string;
  permission: string;
  resourceType?: string;
  resourceId?: string;
  context?: any;
  result: boolean;
  reason?: string;
  riskScore?: number;
  timestamp: Date;
}

export class RBACService {
  private accessControlRepository: Repository<AccessControlUser>;
  private securityComplianceService: SecurityComplianceService;
  private notificationService: NotificationService;

  // Healthcare-specific roles and permissions
  private readonly HEALTHCARE_ROLES = {
    SYSTEM_ADMIN: 'system_admin',
    TENANT_ADMIN: 'tenant_admin',
    ORGANIZATION_ADMIN: 'organization_admin',
    CARE_HOME_MANAGER: 'care_home_manager',
    CLINICAL_LEAD: 'clinical_lead',
    NURSE_MANAGER: 'nurse_manager',
    CARE_COORDINATOR: 'care_coordinator',
    FINANCE_MANAGER: 'finance_manager',
    HR_MANAGER: 'hr_manager',
    COMPLIANCE_OFFICER: 'compliance_officer',
    AUDITOR: 'auditor',
    CARE_WORKER: 'care_worker',
    NURSE: 'nurse',
    THERAPIST: 'therapist',
    MAINTENANCE_STAFF: 'maintenance_staff',
    KITCHEN_STAFF: 'kitchen_staff',
    HOUSEKEEPING_STAFF: 'housekeeping_staff',
    RECEPTIONIST: 'receptionist',
    VISITOR: 'visitor',
    FAMILY_MEMBER: 'family_member'
  };

  private readonly HEALTHCARE_PERMISSIONS = {
    // Organization Management
    ORGANIZATION_READ: 'organization:read',
    ORGANIZATION_WRITE: 'organization:write',
    ORGANIZATION_CREATE: 'organization:create',
    ORGANIZATION_DELETE: 'organization:delete',
    HIERARCHY_READ: 'hierarchy:read',
    HIERARCHY_MANAGE: 'hierarchy:manage',
    
    // Financial Management
    FINANCIAL_READ: 'financial:read',
    FINANCIAL_WRITE: 'financial:write',
    TRANSACTION_CREATE: 'transaction:create',
    TRANSACTION_READ: 'transaction:read',
    TRANSACTION_UPDATE: 'transaction:update',
    TRANSACTION_DELETE: 'transaction:delete',
    BUDGET_CREATE: 'budget:create',
    BUDGET_READ: 'budget:read',
    BUDGET_UPDATE: 'budget:update',
    FORECAST_CREATE: 'forecast:create',
    FORECAST_READ: 'forecast:read',
    
    // Analytics and Reporting
    ANALYTICS_READ: 'analytics:read',
    ANALYTICS_GENERATE: 'analytics:generate',
    DASHBOARD_READ: 'dashboard:read',
    DASHBOARD_CREATE: 'dashboard:create',
    REPORT_READ: 'report:read',
    REPORT_CREATE: 'report:create',
    REPORT_GENERATE: 'report:generate',
    
    // Configuration Management
    CONFIGURATION_READ: 'configuration:read',
    CONFIGURATION_MANAGE: 'configuration:manage',
    PERMISSION_READ: 'permission:read',
    PERMISSION_MANAGE: 'permission:manage',
    
    // Resident Management
    RESIDENT_READ: 'resident:read',
    RESIDENT_WRITE: 'resident:write',
    RESIDENT_CREATE: 'resident:create',
    RESIDENT_DELETE: 'resident:delete',
    
    // Clinical Data
    CLINICAL_READ: 'clinical:read',
    CLINICAL_WRITE: 'clinical:write',
    MEDICATION_READ: 'medication:read',
    MEDICATION_WRITE: 'medication:write',
    MEDICATION_ADMINISTER: 'medication:administer',
    CARE_PLAN_READ: 'care_plan:read',
    CARE_PLAN_WRITE: 'care_plan:write',
    
    // Staff Management
    STAFF_READ: 'staff:read',
    STAFF_WRITE: 'staff:write',
    STAFF_CREATE: 'staff:create',
    STAFF_DELETE: 'staff:delete',
    
    // Compliance and Audit
    AUDIT_READ: 'audit:read',
    AUDIT_WRITE: 'audit:write',
    COMPLIANCE_READ: 'compliance:read',
    COMPLIANCE_MANAGE: 'compliance:manage',
    
    // System Administration
    SYSTEM_ADMIN: 'system:admin',
    USER_MANAGEMENT: 'user:manage',
    TENANT_MANAGEMENT: 'tenant:manage'
  };

  constructor() {
    this.accessControlRepository = AppDataSource.getRepository(AccessControlUser);
    this.securityComplianceService = new SecurityComplianceService();
    this.notificationService = new NotificationService(new EventEmitter2());
  }

  // User Access Control Management
  async createAccessControlUser(
    userId: string,
    accessLevel: AccessLevel,
    organizationId?: string,
    tenantId: string = 'default'
  ): Promise<AccessControlUser> {
    try {
      const accessControlUser = this.accessControlRepository.create({
        userId,
        accessLevel,
        permissions: [],
        accessCards: [],
        biometricData: [],
        accessSchedule: [],
        securityClearance: {
          clearanceLevel: 'basic',
          clearanceDate: new Date(),
          expiryDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year
          clearingAuthority: 'internal',
          backgroundCheckCompleted: false,
          dbsCheckLevel: 'basic',
          dbsCheckNumber: '',
          restrictionsApplied: [],
          monitoringRequired: false
        },
        accessHistory: [],
        threatIntelligence: {
          threatLevel: 'low',
          threatTypes: [],
          lastThreatAssessment: new Date(),
          securityIncidents: 0,
          vulnerabilitiesIdentified: 0,
          mitigationMeasuresImplemented: [],
          securityScore: 100,
          complianceStatus: {
            gdprCompliant: true,
            iso27001Compliant: true,
            nhsSecurityCompliant: true,
            cqcSecurityCompliant: true
          }
        },
        authorizedZones: ['general'],
        restrictedZones: [],
        isActive: true,
        securitySettings: {
          mfaEnabled: accessLevel === AccessLevel.ADMINISTRATIVE || accessLevel === AccessLevel.SYSTEM_ADMIN,
          biometricRequired: accessLevel === AccessLevel.SYSTEM_ADMIN,
          passwordComplexityLevel: accessLevel === AccessLevel.SYSTEM_ADMIN ? 'maximum' : 'standard',
          sessionTimeout: 480, // 8 hours
          concurrentSessionsAllowed: accessLevel === AccessLevel.SYSTEM_ADMIN ? 1 : 3,
          ipRestrictions: [],
          deviceRestrictions: []
        }
      });

      const savedUser = await this.accessControlRepository.save(accessControlUser);

      // Log the creation
      await this.securityComplianceService.logSecurityEvent(
        'user_management' as any,
        'access_control_user',
        savedUser.id,
        'access_control_user_created',
        'system',
        { userId, accessLevel, organizationId, tenantId },
        'low' as any
      );

      return savedUser;

    } catch (error: unknown) {
      console.error('Failed to create access control user', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        accessLevel
      });
      throw error;
    }
  }

  // Permission Management
  async assignPermission(
    userId: string,
    permission: Permission,
    assignedBy: string
  ): Promise<void> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        throw new Error('Access control user not found');
      }

      accessControlUser.addPermission(permission);
      await this.accessControlRepository.save(accessControlUser);

      // Log the permission assignment
      await this.securityComplianceService.logSecurityEvent(
        'user_management' as any,
        'permission',
        permission.id,
        'permission_assigned',
        assignedBy,
        { 
          userId, 
          permissionName: permission.permissionName,
          resourceType: permission.resourceType,
          actions: permission.actions 
        },
        'low' as any
      );

      // Send notification if high-risk permission
      if (permission.riskLevel === 'high' || permission.riskLevel === 'critical') {
        await this.notificationService.sendNotification({
          message: 'Notification: High Risk Permission Assigned',
        type: 'high_risk_permission_assigned',
          recipients: ['security_team', 'compliance_officer'],
          data: {
            userId,
            permissionName: permission.permissionName,
            riskLevel: permission.riskLevel,
            assignedBy
          }
        });
      }

    } catch (error: unknown) {
      console.error('Failed to assign permission', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        permissionId: permission.id
      });
      throw error;
    }
  }

  async revokePermission(
    userId: string,
    permissionName: string,
    resourceType?: string,
    resourceId?: string,
    revokedBy: string = 'system'
  ): Promise<void> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        throw new Error('Access control user not found');
      }

      accessControlUser.removePermission(permissionName, resourceType, resourceId);
      await this.accessControlRepository.save(accessControlUser);

      // Log the permission revocation
      await this.securityComplianceService.logSecurityEvent(
        'user_management' as any,
        'permission',
        'permission_revocation',
        'permission_revoked',
        revokedBy,
        { 
          userId, 
          permissionName,
          resourceType,
          resourceId 
        },
        'low' as any
      );

    } catch (error: unknown) {
      console.error('Failed to revoke permission', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        permissionName
      });
      throw error;
    }
  }

  // Role-based Permission Assignment
  async assignRolePermissions(
    userId: string,
    roleName: string,
    assignedBy: string,
    organizationId?: string,
    tenantId: string = 'default'
  ): Promise<void> {
    try {
      const rolePermissions = this.getRolePermissions(roleName, tenantId);
      
      for (const permission of rolePermissions) {
        await this.assignPermission(userId, permission, assignedBy);
      }

      // Log role assignment
      await this.securityComplianceService.logSecurityEvent(
        'user_management' as any,
        'role_assignment',
        'role_assigned',
        'role_assigned',
        assignedBy,
        { 
          userId, 
          roleName,
          organizationId,
          tenantId,
          permissionsCount: rolePermissions.length 
        },
        'low' as any
      );

    } catch (error: unknown) {
      console.error('Failed to assign role permissions', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        roleName
      });
      throw error;
    }
  }

  // Permission Checking
  async checkPermission(
    userId: string,
    permission: string,
    resourceType?: string,
    resourceId?: string,
    context?: any
  ): Promise<PermissionCheck> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        return {
          userId,
          permission,
          resourceType,
          resourceId,
          context,
          result: false,
          reason: 'User not found in access control system',
          timestamp: new Date()
        };
      }

      // Check if account is locked
      if (accessControlUser.isAccountLocked()) {
        return {
          userId,
          permission,
          resourceType,
          resourceId,
          context,
          result: false,
          reason: 'Account is locked',
          timestamp: new Date()
        };
      }

      // Check if user is active
      if (!accessControlUser.isActive) {
        return {
          userId,
          permission,
          resourceType,
          resourceId,
          context,
          result: false,
          reason: 'User account is inactive',
          timestamp: new Date()
        };
      }

      // Check permission
      const hasPermission = accessControlUser.hasPermission(permission, resourceType, resourceId);
      
      if (!hasPermission) {
        return {
          userId,
          permission,
          resourceType,
          resourceId,
          context,
          result: false,
          reason: 'Insufficient permissions',
          timestamp: new Date()
        };
      }

      // Check time-based access
      if (context && context.checkTimeAccess) {
        const canAccessAtTime = accessControlUser.canAccessAtTime(new Date());
        if (!canAccessAtTime) {
          return {
            userId,
            permission,
            resourceType,
            resourceId,
            context,
            result: false,
            reason: 'Access not allowed at this time',
            timestamp: new Date()
          };
        }
      }

      // Check zone access
      if (context && context.location) {
        const canAccessZone = accessControlUser.canAccessZone(context.location);
        if (!canAccessZone) {
          return {
            userId,
            permission,
            resourceType,
            resourceId,
            context,
            result: false,
            reason: 'Access not allowed in this zone',
            timestamp: new Date()
          };
        }
      }

      // Calculate risk score
      const riskScore = this.calculatePermissionRiskScore(accessControlUser, permission, context);

      // Log permission check
      await this.securityComplianceService.logSecurityEvent(
        'data_access' as any,
        resourceType || 'permission_check',
        resourceId || 'permission_check',
        'permission_checked',
        userId,
        { 
          permission, 
          resourceType, 
          resourceId, 
          result: true,
          riskScore 
        },
        riskScore > 70 ? 'high' as any : riskScore > 40 ? 'medium' as any : 'low' as any
      );

      return {
        userId,
        permission,
        resourceType,
        resourceId,
        context,
        result: true,
        riskScore,
        timestamp: new Date()
      };

    } catch (error: unknown) {
      console.error('Failed to check permission', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        permission
      });
      
      return {
        userId,
        permission,
        resourceType,
        resourceId,
        context,
        result: false,
        reason: 'Permission check failed',
        timestamp: new Date()
      };
    }
  }

  // Access Attempt Recording
  async recordAccessAttempt(
    userId: string,
    accessPoint: string,
    authenticationMethod: AuthenticationMethod,
    success: boolean,
    failureReason?: string,
    deviceInfo?: any,
    contextualFactors?: any
  ): Promise<void> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        throw new Error('Access control user not found');
      }

      const accessAttempt = {
        attemptId: `ATT_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        attemptTime: new Date(),
        accessPoint,
        authenticationMethod,
        success,
        failureReason,
        riskScore: this.calculateAccessRiskScore(accessControlUser, success, failureReason),
        deviceInfo: deviceInfo || {},
        contextualFactors: contextualFactors || {}
      };

      accessControlUser.addAccessAttempt(accessAttempt);
      await this.accessControlRepository.save(accessControlUser);

      // Log access attempt
      await this.securityComplianceService.logSecurityEvent(
        success ? 'user_login' as any : 'security_event' as any,
        'access_attempt',
        accessAttempt.attemptId,
        success ? 'access_granted' : 'access_denied',
        userId,
        { 
          accessPoint, 
          authenticationMethod, 
          success, 
          failureReason,
          riskScore: accessAttempt.riskScore 
        },
        success ? 'low' as any : 'medium' as any
      );

      // Send alert for suspicious activity
      if (!success && accessAttempt.riskScore > 70) {
        await this.notificationService.sendNotification({
          message: 'Notification: Suspicious Access Attempt',
        type: 'suspicious_access_attempt',
          recipients: ['security_team'],
          data: {
            userId,
            accessPoint,
            failureReason,
            riskScore: accessAttempt.riskScore,
            timestamp: accessAttempt.attemptTime
          }
        });
      }

    } catch (error: unknown) {
      console.error('Failed to record access attempt', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        accessPoint
      });
      throw error;
    }
  }

  // Security Management
  async lockUserAccount(userId: string, durationMinutes: number, lockedBy: string): Promise<void> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        throw new Error('Access control user not found');
      }

      accessControlUser.lockAccount(durationMinutes);
      await this.accessControlRepository.save(accessControlUser);

      // Log account lock
      await this.securityComplianceService.logSecurityEvent(
        'security_event' as any,
        'user_account',
        userId,
        'account_locked',
        lockedBy,
        { 
          durationMinutes,
          reason: 'Security measure',
          failedAttempts: accessControlUser.failedAccessAttempts 
        },
        'high' as any
      );

      // Send notification
      await this.notificationService.sendNotification({
        message: 'Notification: Account Locked',
        type: 'account_locked',
        recipients: [userId, 'security_team'],
        data: {
          userId,
          durationMinutes,
          lockedBy,
          timestamp: new Date()
        }
      });

    } catch (error: unknown) {
      console.error('Failed to lock user account', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        durationMinutes
      });
      throw error;
    }
  }

  async unlockUserAccount(userId: string, unlockedBy: string): Promise<void> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        throw new Error('Access control user not found');
      }

      accessControlUser.unlockAccount();
      await this.accessControlRepository.save(accessControlUser);

      // Log account unlock
      await this.securityComplianceService.logSecurityEvent(
        'security_event' as any,
        'user_account',
        userId,
        'account_unlocked',
        unlockedBy,
        { reason: 'Manual unlock' },
        'low' as any
      );

      // Send notification
      await this.notificationService.sendNotification({
        message: 'Notification: Account Unlocked',
        type: 'account_unlocked',
        recipients: [userId, 'security_team'],
        data: {
          userId,
          unlockedBy,
          timestamp: new Date()
        }
      });

    } catch (error: unknown) {
      console.error('Failed to unlock user account', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId
      });
      throw error;
    }
  }

  // Helper Methods
  private getRolePermissions(roleName: string, tenantId: string): Permission[] {
    const rolePermissionMap = {
      [this.HEALTHCARE_ROLES.SYSTEM_ADMIN]: [
        this.createPermission(this.HEALTHCARE_PERMISSIONS.SYSTEM_ADMIN, 'system', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.USER_MANAGEMENT, 'user', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.TENANT_MANAGEMENT, 'tenant', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.ORGANIZATION_READ, 'organization', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.ORGANIZATION_WRITE, 'organization', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.ORGANIZATION_CREATE, 'organization', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.ORGANIZATION_DELETE, 'organization', ['*'])
      ],
      [this.HEALTHCARE_ROLES.CARE_HOME_MANAGER]: [
        this.createPermission(this.HEALTHCARE_PERMISSIONS.ORGANIZATION_READ, 'organization', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.ORGANIZATION_WRITE, 'organization', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_READ, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_WRITE, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_CREATE, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.STAFF_READ, 'staff', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.STAFF_WRITE, 'staff', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.FINANCIAL_READ, 'financial', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.REPORT_READ, 'report', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.REPORT_GENERATE, 'report', ['*'])
      ],
      [this.HEALTHCARE_ROLES.NURSE]: [
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_READ, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_WRITE, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.CLINICAL_READ, 'clinical', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.CLINICAL_WRITE, 'clinical', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.MEDICATION_READ, 'medication', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.MEDICATION_WRITE, 'medication', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.MEDICATION_ADMINISTER, 'medication', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.CARE_PLAN_READ, 'care_plan', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.CARE_PLAN_WRITE, 'care_plan', ['*'])
      ],
      [this.HEALTHCARE_ROLES.CARE_WORKER]: [
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_READ, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.RESIDENT_WRITE, 'resident', ['*']),
        this.createPermission(this.HEALTHCARE_PERMISSIONS.CLINICAL_READ, 'clinical', ['*'])
      ]
    };

    return rolePermissionMap[roleName] || [];
  }

  private createPermission(
    permissionName: string,
    resourceType: string,
    actions: string[],
    riskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low'
  ): Permission {
    return {
      id: `perm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      permissionName,
      permissionCategory: this.getPermissionCategory(permissionName),
      resourceType,
      actions,
      conditions: {
        timeRestrictions: undefined,
        locationRestrictions: [],
        contextualRequirements: []
      },
      grantedDate: new Date(),
      grantedBy: 'system',
      riskLevel
    };
  }

  private getPermissionCategory(permissionName: string): 'system' | 'clinical' | 'administrative' | 'facility' | 'emergency' {
    if (permissionName.includes('system') || permissionName.includes('admin')) return 'system';
    if (permissionName.includes('clinical') || permissionName.includes('medication') || permissionName.includes('care_plan')) return 'clinical';
    if (permissionName.includes('financial') || permissionName.includes('staff') || permissionName.includes('organization')) return 'administrative';
    if (permissionName.includes('emergency')) return 'emergency';
    return 'facility';
  }

  private calculatePermissionRiskScore(
    user: AccessControlUser,
    permission: string,
    context?: any
  ): number {
    let riskScore = 0;

    // Base risk from user profile
    if (user.isHighRiskUser()) riskScore += 30;
    if (user.failedAccessAttempts > 0) riskScore += user.failedAccessAttempts * 5;
    if (!user.isSecurityClearanceValid()) riskScore += 20;

    // Permission-based risk
    if (permission.includes('delete') || permission.includes('admin')) riskScore += 15;
    if (permission.includes('financial') || permission.includes('system')) riskScore += 10;

    // Context-based risk
    if (context?.unusualTime) riskScore += 15;
    if (context?.unusualLocation) riskScore += 20;
    if (context?.externalNetwork) riskScore += 25;

    return Math.min(100, riskScore);
  }

  private calculateAccessRiskScore(
    user: AccessControlUser,
    success: boolean,
    failureReason?: string
  ): number {
    let riskScore = 0;

    if (!success) {
      riskScore += 20; // Base risk for failed attempts
      
      if (failureReason?.includes('password')) riskScore += 10;
      if (failureReason?.includes('biometric')) riskScore += 15;
      if (failureReason?.includes('permission')) riskScore += 5;
    }

    // User profile risk
    if (user.isHighRiskUser()) riskScore += 25;
    if (user.failedAccessAttempts > 2) riskScore += 15;

    return Math.min(100, riskScore);
  }
}

export default RBACService;