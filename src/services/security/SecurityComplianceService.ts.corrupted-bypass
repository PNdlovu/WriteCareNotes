import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { AuditEvent, AuditEventType, RiskLevel, ComplianceFramework } from '../../entities/audit/AuditEvent';
import { AccessControlUser, AccessLevel, AuthenticationMethod } from '../../entities/security/AccessControlUser';
import { SecurityIncident } from '../../entities/security/SecurityIncident';
import { NotificationService } from '../notifications/NotificationService';
import { logger } from '../../utils/logger';

export interface SecurityPolicy {
  id: string;
  name: string;
  description: string;
  policyType: 'access_control' | 'data_protection' | 'incident_response' | 'compliance';
  rules: SecurityRule[];
  enforcementLevel: 'advisory' | 'mandatory' | 'critical';
  effectiveDate: Date;
  expiryDate?: Date;
  applicableRoles: string[];
  applicableResources: string[];
}

export interface SecurityRule {
  id: string;
  ruleName: string;
  condition: string;
  action: 'allow' | 'deny' | 'require_approval' | 'log_only' | 'escalate';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  remediation: string;
}

export interface ComplianceCheck {
  framework: ComplianceFramework;
  checkId: string;
  checkName: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  automated: boolean;
  frequency: 'real_time' | 'daily' | 'weekly' | 'monthly' | 'quarterly';
  lastCheck: Date;
  status: 'pass' | 'fail' | 'warning' | 'not_applicable';
  violations: ComplianceViolation[];
  evidence: ComplianceEvidence[];
}

export interface ComplianceViolation {
  violationId: string;
  violationType: string;
  description: string;
  severity: 'minor' | 'major' | 'critical';
  detectedAt: Date;
  remediatedAt?: Date;
  remediation: string;
  responsibleParty: string;
  deadline?: Date;
}

export interface ComplianceEvidence {
  evidenceId: string;
  evidenceType: 'document' | 'log' | 'configuration' | 'test_result' | 'certification';
  description: string;
  location: string;
  collectedAt: Date;
  validUntil?: Date;
  verified: boolean;
}

export interface DataSubjectRequest {
  id: string;
  requestType: 'access' | 'rectification' | 'erasure' | 'portability' | 'restriction' | 'objection';
  dataSubjectId: string;
  dataSubjectName: string;
  requestDate: Date;
  dueDate: Date;
  status: 'pending' | 'in_progress' | 'completed' | 'rejected';
  description: string;
  requestedData: string[];
  responseData?: any;
  completedAt?: Date;
  completedBy?: string;
  verificationMethod: 'email' | 'phone' | 'postal' | 'in_person' | 'digital_id';
  verificationCompleted: boolean;
}

export class SecurityComplianceService {
  private auditEventRepository: Repository<AuditEvent>;
  private accessControlRepository: Repository<AccessControlUser>;
  private securityIncidentRepository: Repository<SecurityIncident>;
  private notificationService: NotificationService;

  constructor() {
    this.auditEventRepository = AppDataSource.getRepository(AuditEvent);
    this.accessControlRepository = AppDataSource.getRepository(AccessControlUser);
    this.securityIncidentRepository = AppDataSource.getRepository(SecurityIncident);
    this.notificationService = new NotificationService(new EventEmitter2());
  }

  // Enhanced Audit Logging
  async logSecurityEvent(
    eventType: AuditEventType,
    entityType: string,
    entityId: string,
    action: string,
    userId: string,
    details: any,
    riskLevel: RiskLevel = RiskLevel.LOW,
    complianceFrameworks: ComplianceFramework[] = []
  ): Promise<AuditEvent> {
    try {
      const auditEvent = this.auditEventRepository.create({
        eventId: this.generateEventId(),
        eventType,
        entityType,
        entityId,
        action,
        userId,
        details,
        riskLevel,
        auditContext: {
          sessionId: details.sessionId || 'unknown',
          userAgent: details.userAgent || 'unknown',
          ipAddress: details.ipAddress || 'unknown',
          deviceInfo: details.deviceInfo || {},
          networkInfo: details.networkInfo || {}
        },
        dataClassification: {
          dataType: this.classifyDataType(entityType, details),
          sensitivityLevel: this.determineSensitivityLevel(riskLevel, details),
          retentionPeriod: this.calculateRetentionPeriod(entityType, details),
          encryptionRequired: this.requiresEncryption(entityType, details),
          accessRestrictions: this.determineAccessRestrictions(entityType, details),
          complianceRequirements: complianceFrameworks
        },
        complianceValidation: [],
        advancedFeatures: {
          realTimeMonitoring: {
            anomalyDetection: true,
            behaviorAnalysis: true,
            riskScoring: true,
            alertGeneration: true,
            automaticResponse: true
          },
          intelligentAnalysis: {
            patternRecognition: true,
            trendAnalysis: true,
            predictiveInsights: true,
            correlationAnalysis: true,
            rootCauseAnalysis: true
          },
          complianceAutomation: {
            automaticClassification: true,
            complianceChecking: true,
            evidenceCollection: true,
            reportGeneration: true,
            remediation: true
          },
          forensicCapabilities: {
            digitalForensics: true,
            chainOfCustody: true,
            evidencePreservation: true,
            timelineReconstruction: true,
            expertAnalysis: true
          }
        },
        beforeState: details.beforeState || null,
        afterState: details.afterState || null,
        processingTime: details.processingTime || 0,
        isSuccessful: details.success !== false,
        relatedEvents: [],
        retentionDate: this.calculateRetentionDate(entityType, details)
      });

      const savedEvent = await this.auditEventRepository.save(auditEvent);

      // Perform real-time compliance checks
      await this.performRealTimeComplianceCheck(savedEvent);

      // Check for security anomalies
      await this.checkForSecurityAnomalies(savedEvent);

      // Send alerts if necessary
      if (savedEvent.isHighRisk()) {
        await this.sendSecurityAlert(savedEvent);
      }

      console.info('Security event logged', {
        eventId: savedEvent.eventId,
        eventType: savedEvent.eventType,
        userId: savedEvent.userId,
        riskLevel: savedEvent.riskLevel
      });

      return savedEvent;

    } catch (error: unknown) {
      console.error('Failed to log security event', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        eventType,
        userId,
        entityType,
        entityId
      });
      throw error;
    }
  }

  // Access Control Management
  async validateAccess(
    userId: string,
    resourceType: string,
    resourceId: string,
    action: string,
    context: any
  ): Promise<{ allowed: boolean; reason?: string; riskScore?: number }> {
    try {
      const accessControlUser = await this.accessControlRepository.findOne({
        where: { userId }
      });

      if (!accessControlUser) {
        return { allowed: false, reason: 'User not found in access control system' };
      }

      // Check if account is locked
      if (accessControlUser.isAccountLocked()) {
        await this.logSecurityEvent(
          AuditEventType.SECURITY_EVENT,
          'access_control',
          userId,
          'access_denied_locked_account',
          userId,
          { resourceType, resourceId, action, reason: 'Account locked' },
          RiskLevel.HIGH
        );
        return { allowed: false, reason: 'Account is locked' };
      }

      // Check permissions
      const hasPermission = accessControlUser.hasPermission(action, resourceType, resourceId);
      if (!hasPermission) {
        await this.logSecurityEvent(
          AuditEventType.SECURITY_EVENT,
          'access_control',
          userId,
          'access_denied_insufficient_permissions',
          userId,
          { resourceType, resourceId, action, userPermissions: accessControlUser.getActivePermissions() },
          RiskLevel.MEDIUM
        );
        return { allowed: false, reason: 'Insufficient permissions' };
      }

      // Check time-based access
      const canAccessAtTime = accessControlUser.canAccessAtTime(new Date());
      if (!canAccessAtTime) {
        await this.logSecurityEvent(
          AuditEventType.SECURITY_EVENT,
          'access_control',
          userId,
          'access_denied_time_restriction',
          userId,
          { resourceType, resourceId, action, currentTime: new Date() },
          RiskLevel.MEDIUM
        );
        return { allowed: false, reason: 'Access not allowed at this time' };
      }

      // Check zone access
      if (context.location && !accessControlUser.canAccessZone(context.location)) {
        await this.logSecurityEvent(
          AuditEventType.SECURITY_EVENT,
          'access_control',
          userId,
          'access_denied_zone_restriction',
          userId,
          { resourceType, resourceId, action, location: context.location },
          RiskLevel.HIGH
        );
        return { allowed: false, reason: 'Access not allowed in this zone' };
      }

      // Calculate risk score
      const riskScore = this.calculateAccessRiskScore(accessControlUser, context);

      // Log successful access
      await this.logSecurityEvent(
        AuditEventType.DATA_ACCESS,
        resourceType,
        resourceId,
        action,
        userId,
        { 
          accessGranted: true, 
          riskScore,
          accessLevel: accessControlUser.accessLevel,
          context 
        },
        riskScore > 70 ? RiskLevel.HIGH : riskScore > 40 ? RiskLevel.MEDIUM : RiskLevel.LOW
      );

      return { allowed: true, riskScore };

    } catch (error: unknown) {
      console.error('Failed to validate access', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId,
        resourceType,
        resourceId,
        action
      });
      return { allowed: false, reason: 'Access validation failed' };
    }
  }

  // GDPR Compliance Management
  async processDataSubjectRequest(request: DataSubjectRequest): Promise<DataSubjectRequest> {
    try {
      // Log the request
      await this.logSecurityEvent(
        AuditEventType.COMPLIANCE_CHECK,
        'data_subject_request',
        request.id,
        'data_subject_request_received',
        request.dataSubjectId,
        { requestType: request.requestType, description: request.description },
        RiskLevel.MEDIUM,
        [ComplianceFramework.GDPR]
      );

      // Process based on request type
      switch (request.requestType) {
        case 'access':
          await this.processAccessRequest(request);
          break;
        case 'rectification':
          await this.processRectificationRequest(request);
          break;
        case 'erasure':
          await this.processErasureRequest(request);
          break;
        case 'portability':
          await this.processPortabilityRequest(request);
          break;
        case 'restriction':
          await this.processRestrictionRequest(request);
          break;
        case 'objection':
          await this.processObjectionRequest(request);
          break;
      }

      // Update request status
      request.status = 'completed';
      request.completedAt = new Date();

      // Log completion
      await this.logSecurityEvent(
        AuditEventType.COMPLIANCE_CHECK,
        'data_subject_request',
        request.id,
        'data_subject_request_completed',
        request.completedBy || 'system',
        { requestType: request.requestType, completionTime: request.completedAt },
        RiskLevel.LOW,
        [ComplianceFramework.GDPR]
      );

      return request;

    } catch (error: unknown) {
      console.error('Failed to process data subject request', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        requestId: request.id,
        requestType: request.requestType
      });
      throw error;
    }
  }

  // Security Incident Management
  async reportSecurityIncident(
    incidentType: string,
    severity: 'low' | 'medium' | 'high' | 'critical',
    description: string,
    reportedBy: string,
    affectedSystems: string[],
    evidence: any[]
  ): Promise<SecurityIncident> {
    try {
      const incident = this.securityIncidentRepository.create({
        incidentId: this.generateIncidentId(),
        incidentType,
        severity,
        description,
        reportedBy,
        reportedAt: new Date(),
        affectedSystems,
        evidence,
        status: 'reported',
        assignedTo: null,
        resolution: null,
        lessonsLearned: null
      });

      const savedIncident = await this.securityIncidentRepository.save(incident);

      // Log the incident
      await this.logSecurityEvent(
        AuditEventType.SECURITY_EVENT,
        'security_incident',
        savedIncident.id,
        'security_incident_reported',
        reportedBy,
        { 
          incidentType, 
          severity, 
          description, 
          affectedSystems,
          evidenceCount: evidence.length 
        },
        severity === 'critical' ? RiskLevel.CRITICAL : 
        severity === 'high' ? RiskLevel.HIGH : 
        severity === 'medium' ? RiskLevel.MEDIUM : RiskLevel.LOW
      );

      // Send incident notifications
      await this.sendIncidentNotifications(savedIncident);

      // Auto-assign based on severity
      if (severity === 'critical' || severity === 'high') {
        await this.autoAssignIncident(savedIncident);
      }

      return savedIncident;

    } catch (error: unknown) {
      console.error('Failed to report security incident', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        incidentType,
        severity,
        reportedBy
      });
      throw error;
    }
  }

  // Compliance Monitoring
  async performComplianceCheck(framework: ComplianceFramework): Promise<ComplianceCheck> {
    try {
      const check: ComplianceCheck = {
        framework,
        checkId: this.generateCheckId(),
        checkName: `${framework.toUpperCase()} Compliance Check`,
        description: `Automated compliance check for ${framework}`,
        severity: 'high',
        automated: true,
        frequency: 'daily',
        lastCheck: new Date(),
        status: 'pass',
        violations: [],
        evidence: []
      };

      // Perform framework-specific checks
      switch (framework) {
        case ComplianceFramework.GDPR:
          await this.performGDPRComplianceCheck(check);
          break;
        case ComplianceFramework.CQC:
          await this.performCQCComplianceCheck(check);
          break;
        case ComplianceFramework.ISO_27001:
          await this.performISO27001ComplianceCheck(check);
          break;
        case ComplianceFramework.NHS_DIGITAL:
          await this.performNHSDigitalComplianceCheck(check);
          break;
      }

      // Log compliance check
      await this.logSecurityEvent(
        AuditEventType.COMPLIANCE_CHECK,
        'compliance_check',
        check.checkId,
        'compliance_check_performed',
        'system',
        { 
          framework, 
          status: check.status, 
          violationsCount: check.violations.length,
          evidenceCount: check.evidence.length 
        },
        check.violations.some(v => v.severity === 'critical') ? RiskLevel.CRITICAL :
        check.violations.some(v => v.severity === 'major') ? RiskLevel.HIGH :
        check.violations.length > 0 ? RiskLevel.MEDIUM : RiskLevel.LOW,
        [framework]
      );

      return check;

    } catch (error: unknown) {
      console.error('Failed to perform compliance check', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        framework
      });
      throw error;
    }
  }

  // Data Encryption and Protection
  async encryptSensitiveData(data: any, dataType: string): Promise<string> {
    try {
      // In a real implementation, this would use proper encryption
      const encryptionKey = this.getEncryptionKey(dataType);
      const encryptedData = Buffer.from(JSON.stringify(data)).toString('base64');
      
      await this.logSecurityEvent(
        AuditEventType.SECURITY_EVENT,
        'data_encryption',
        'encryption_operation',
        'data_encrypted',
        'system',
        { dataType, encryptionKey: encryptionKey.substring(0, 8) + '...' },
        RiskLevel.LOW
      );

      return encryptedData;

    } catch (error: unknown) {
      console.error('Failed to encrypt sensitive data', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        dataType
      });
      throw error;
    }
  }

  async decryptSensitiveData(encryptedData: string, dataType: string): Promise<any> {
    try {
      // In a real implementation, this would use proper decryption
      const decryptedData = JSON.parse(Buffer.from(encryptedData, 'base64').toString());
      
      await this.logSecurityEvent(
        AuditEventType.SECURITY_EVENT,
        'data_encryption',
        'decryption_operation',
        'data_decrypted',
        'system',
        { dataType },
        RiskLevel.LOW
      );

      return decryptedData;

    } catch (error: unknown) {
      console.error('Failed to decrypt sensitive data', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        dataType
      });
      throw error;
    }
  }

  // Helper Methods
  private generateEventId(): string {
    return `EVT_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateIncidentId(): string {
    return `INC_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateCheckId(): string {
    return `CHK_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private classifyDataType(entityType: string, details: any): 'personal' | 'sensitive_personal' | 'medical' | 'financial' | 'operational' {
    if (entityType.includes('resident') || entityType.includes('patient')) return 'medical';
    if (entityType.includes('financial') || entityType.includes('payment')) return 'financial';
    if (entityType.includes('personal') || entityType.includes('contact')) return 'sensitive_personal';
    if (entityType.includes('medical') || entityType.includes('health')) return 'medical';
    return 'operational';
  }

  private determineSensitivityLevel(riskLevel: RiskLevel, details: any): 'public' | 'internal' | 'confidential' | 'restricted' | 'top_secret' {
    if (riskLevel === RiskLevel.CRITICAL) return 'top_secret';
    if (riskLevel === RiskLevel.HIGH) return 'restricted';
    if (riskLevel === RiskLevel.MEDIUM) return 'confidential';
    if (riskLevel === RiskLevel.LOW) return 'internal';
    return 'public';
  }

  private calculateRetentionPeriod(entityType: string, details: any): number {
    // GDPR default retention periods
    if (entityType.includes('medical')) return 7 * 365; // 7 years
    if (entityType.includes('financial')) return 6 * 365; // 6 years
    if (entityType.includes('audit')) return 7 * 365; // 7 years
    return 3 * 365; // 3 years default
  }

  private requiresEncryption(entityType: string, details: any): boolean {
    return entityType.includes('medical') || 
           entityType.includes('financial') || 
           entityType.includes('personal') ||
           details.sensitive === true;
  }

  private determineAccessRestrictions(entityType: string, details: any): string[] {
    const restrictions = [];
    if (entityType.includes('medical')) restrictions.push('healthcare_staff_only');
    if (entityType.includes('financial')) restrictions.push('finance_staff_only');
    if (entityType.includes('audit')) restrictions.push('audit_staff_only');
    return restrictions;
  }

  private calculateRetentionDate(entityType: string, details: any): Date {
    const retentionPeriod = this.calculateRetentionPeriod(entityType, details);
    const retentionDate = new Date();
    retentionDate.setDate(retentionDate.getDate() + retentionPeriod);
    return retentionDate;
  }

  private calculateAccessRiskScore(user: AccessControlUser, context: any): number {
    let riskScore = 0;

    // Base risk from user profile
    if (user.isHighRiskUser()) riskScore += 30;
    if (user.failedAccessAttempts > 0) riskScore += user.failedAccessAttempts * 5;
    if (!user.isSecurityClearanceValid()) riskScore += 20;

    // Context-based risk
    if (context.unusualTime) riskScore += 15;
    if (context.unusualLocation) riskScore += 20;
    if (context.externalNetwork) riskScore += 25;
    if (context.highValueResource) riskScore += 10;

    return Math.min(100, riskScore);
  }

  private async performRealTimeComplianceCheck(auditEvent: AuditEvent): Promise<void> {
    // Perform real-time compliance validation
    const complianceValidation = {
      validationId: this.generateCheckId(),
      framework: ComplianceFramework.GDPR,
      validationTime: new Date(),
      validationResults: {
        compliant: true,
        complianceScore: 100,
        violations: [],
        evidence: []
      },
      automaticRemediation: {
        remediationApplied: false,
        remediationActions: [],
        remediationSuccess: false,
        manualActionRequired: false
      }
    };

    auditEvent.addComplianceValidation(complianceValidation);
    await this.auditEventRepository.save(auditEvent);
  }

  private async checkForSecurityAnomalies(auditEvent: AuditEvent): Promise<void> {
    // Check for unusual patterns or behaviors
    if (auditEvent.riskLevel === RiskLevel.HIGH || auditEvent.riskLevel === RiskLevel.CRITICAL) {
      await this.sendSecurityAlert(auditEvent);
    }
  }

  private async sendSecurityAlert(auditEvent: AuditEvent): Promise<void> {
    await this.notificationService.sendNotification({
      message: 'Notification: Security Alert',
        type: 'security_alert',
      recipients: ['security_team', 'compliance_officer'],
      data: {
        eventId: auditEvent.eventId,
        eventType: auditEvent.eventType,
        riskLevel: auditEvent.riskLevel,
        userId: auditEvent.userId,
        timestamp: auditEvent.createdAt
      }
    });
  }

  private async sendIncidentNotifications(incident: SecurityIncident): Promise<void> {
    const recipients = incident.severity === 'critical' ? 
      ['security_team', 'incident_response_team', 'management'] :
      ['security_team', 'incident_response_team'];

    await this.notificationService.sendNotification({
      message: 'Notification: Security Incident',
        type: 'security_incident',
      recipients,
      data: {
        incidentId: incident.incidentId,
        incidentType: incident.incidentType,
        severity: incident.severity,
        description: incident.description,
        reportedAt: incident.reportedAt
      }
    });
  }

  private async autoAssignIncident(incident: SecurityIncident): Promise<void> {
    // Auto-assign to appropriate team member based on incident type and severity
    incident.assignedTo = 'security_lead';
    incident.status = 'assigned';
    await this.securityIncidentRepository.save(incident);
  }

  private getEncryptionKey(dataType: string): string {
    // In a real implementation, this would retrieve from a secure key management system
    return `enc_key_${dataType}_${Date.now()}`;
  }

  // GDPR-specific processing methods
  private async processAccessRequest(request: DataSubjectRequest): Promise<void> {
    // Implement data access request processing
    request.responseData = { message: 'Data access request processed' };
  }

  private async processRectificationRequest(request: DataSubjectRequest): Promise<void> {
    // Implement data rectification request processing
    request.responseData = { message: 'Data rectification request processed' };
  }

  private async processErasureRequest(request: DataSubjectRequest): Promise<void> {
    // Implement data erasure request processing
    request.responseData = { message: 'Data erasure request processed' };
  }

  private async processPortabilityRequest(request: DataSubjectRequest): Promise<void> {
    // Implement data portability request processing
    request.responseData = { message: 'Data portability request processed' };
  }

  private async processRestrictionRequest(request: DataSubjectRequest): Promise<void> {
    // Implement data restriction request processing
    request.responseData = { message: 'Data restriction request processed' };
  }

  private async processObjectionRequest(request: DataSubjectRequest): Promise<void> {
    // Implement data objection request processing
    request.responseData = { message: 'Data objection request processed' };
  }

  // Framework-specific compliance checks
  private async performGDPRComplianceCheck(check: ComplianceCheck): Promise<void> {
    // Implement GDPR-specific compliance checks
    check.status = 'pass';
  }

  private async performCQCComplianceCheck(check: ComplianceCheck): Promise<void> {
    // Implement CQC-specific compliance checks
    check.status = 'pass';
  }

  private async performISO27001ComplianceCheck(check: ComplianceCheck): Promise<void> {
    // Implement ISO 27001-specific compliance checks
    check.status = 'pass';
  }

  private async performNHSDigitalComplianceCheck(check: ComplianceCheck): Promise<void> {
    // Implement NHS Digital-specific compliance checks
    check.status = 'pass';
  }
}

export default SecurityComplianceService;