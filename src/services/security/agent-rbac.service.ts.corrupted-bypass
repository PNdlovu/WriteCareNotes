import { logger } from '../../utils/logger';
import { 
  AgentRole, 
  AgentPermission, 
  AgentAccessControl 
} from '../../types/pilot-feedback-agent.types';

export class AgentRBACService {
  private roles: Map<string, AgentRole> = new Map();
  private permissions: Map<string, AgentPermission> = new Map();
  private userAccess: Map<string, AgentAccessControl> = new Map();

  constructor() {
    this.initializeDefaultRoles();
    this.initializeDefaultPermissions();
  }

  /**
   * Check if user has permission to perform action on resource
   */
  async checkPermission(
    userId: string, 
    tenantId: string, 
    resource: string, 
    action: string
  ): Promise<boolean> {
    try {
      const accessControl = await this.getUserAccessControl(userId, tenantId);
      if (!accessControl) {
        logger.warn('No access control found for user', { userId, tenantId });
        return false;
      }

      // Check direct permissions
      const hasDirectPermission = accessControl.permissions.some(permission => 
        permission.resource === resource && 
        permission.actions.includes(action)
      );

      if (hasDirectPermission) {
        return true;
      }

      // Check role-based permissions
      for (const roleId of accessControl.roles) {
        const role = this.roles.get(roleId);
        if (role) {
          const hasRolePermission = role.permissions.some(permission => 
            permission.resource === resource && 
            permission.actions.includes(action)
          );
          if (hasRolePermission) {
            return true;
          }
        }
      }

      return false;

    } catch (error) {
      logger.error('Failed to check permission', { 
        userId, 
        tenantId, 
        resource, 
        action, 
        error: error.message 
      });
      return false;
    }
  }

  /**
   * Get user access control for tenant
   */
  async getUserAccessControl(userId: string, tenantId: string): Promise<AgentAccessControl | null> {
    const key = `${userId}:${tenantId}`;
    return this.userAccess.get(key) || null;
  }

  /**
   * Assign role to user for tenant
   */
  async assignRole(userId: string, tenantId: string, roleId: string): Promise<void> {
    const key = `${userId}:${tenantId}`;
    let accessControl = this.userAccess.get(key);
    
    if (!accessControl) {
      accessControl = {
        userId,
        tenantId,
        roles: [],
        permissions: []
      };
    }

    if (!accessControl.roles.includes(roleId)) {
      accessControl.roles.push(roleId);
      this.userAccess.set(key, accessControl);
      
      logger.info('Role assigned to user', { userId, tenantId, roleId });
    }
  }

  /**
   * Remove role from user for tenant
   */
  async removeRole(userId: string, tenantId: string, roleId: string): Promise<void> {
    const key = `${userId}:${tenantId}`;
    const accessControl = this.userAccess.get(key);
    
    if (accessControl) {
      accessControl.roles = accessControl.roles.filter(id => id !== roleId);
      this.userAccess.set(key, accessControl);
      
      logger.info('Role removed from user', { userId, tenantId, roleId });
    }
  }

  /**
   * Grant direct permission to user for tenant
   */
  async grantPermission(
    userId: string, 
    tenantId: string, 
    resource: string, 
    actions: string[]
  ): Promise<void> {
    const key = `${userId}:${tenantId}`;
    let accessControl = this.userAccess.get(key);
    
    if (!accessControl) {
      accessControl = {
        userId,
        tenantId,
        roles: [],
        permissions: []
      };
    }

    const existingPermission = accessControl.permissions.find(p => p.resource === resource);
    if (existingPermission) {
      // Merge actions
      existingPermission.actions = [...new Set([...existingPermission.actions, ...actions])];
    } else {
      accessControl.permissions.push({
        permissionId: this.generateId(),
        resource,
        actions
      });
    }

    this.userAccess.set(key, accessControl);
    
    logger.info('Permission granted to user', { userId, tenantId, resource, actions });
  }

  /**
   * Revoke permission from user for tenant
   */
  async revokePermission(
    userId: string, 
    tenantId: string, 
    resource: string, 
    actions?: string[]
  ): Promise<void> {
    const key = `${userId}:${tenantId}`;
    const accessControl = this.userAccess.get(key);
    
    if (accessControl) {
      if (actions) {
        // Remove specific actions
        const permission = accessControl.permissions.find(p => p.resource === resource);
        if (permission) {
          permission.actions = permission.actions.filter(action => !actions.includes(action));
          if (permission.actions.length === 0) {
            accessControl.permissions = accessControl.permissions.filter(p => p.resource !== resource);
          }
        }
      } else {
        // Remove entire permission
        accessControl.permissions = accessControl.permissions.filter(p => p.resource !== resource);
      }

      this.userAccess.set(key, accessControl);
      
      logger.info('Permission revoked from user', { userId, tenantId, resource, actions });
    }
  }

  /**
   * Get all permissions for user in tenant
   */
  async getUserPermissions(userId: string, tenantId: string): Promise<AgentPermission[]> {
    const accessControl = await this.getUserAccessControl(userId, tenantId);
    if (!accessControl) return [];

    const allPermissions: AgentPermission[] = [...accessControl.permissions];

    // Add role-based permissions
    for (const roleId of accessControl.roles) {
      const role = this.roles.get(roleId);
      if (role) {
        allPermissions.push(...role.permissions);
      }
    }

    return allPermissions;
  }

  /**
   * Check if user can access agent features
   */
  async canAccessAgentFeatures(userId: string, tenantId: string): Promise<boolean> {
    return await this.checkPermission(userId, tenantId, 'agent', 'read');
  }

  /**
   * Check if user can approve recommendations
   */
  async canApproveRecommendations(userId: string, tenantId: string): Promise<boolean> {
    return await this.checkPermission(userId, tenantId, 'recommendations', 'approve');
  }

  /**
   * Check if user can configure agent
   */
  async canConfigureAgent(userId: string, tenantId: string): Promise<boolean> {
    return await this.checkPermission(userId, tenantId, 'agent', 'configure');
  }

  /**
   * Check if user can view audit logs
   */
  async canViewAuditLogs(userId: string, tenantId: string): Promise<boolean> {
    return await this.checkPermission(userId, tenantId, 'audit', 'read');
  }

  /**
   * Get role by ID
   */
  getRole(roleId: string): AgentRole | null {
    return this.roles.get(roleId) || null;
  }

  /**
   * Get all roles
   */
  getAllRoles(): AgentRole[] {
    return Array.from(this.roles.values());
  }

  /**
   * Create new role
   */
  async createRole(role: Omit<AgentRole, 'roleId' | 'createdAt'>): Promise<AgentRole> {
    const newRole: AgentRole = {
      ...role,
      roleId: this.generateId(),
      createdAt: new Date()
    };

    this.roles.set(newRole.roleId, newRole);
    
    logger.info('Role created', { roleId: newRole.roleId, name: newRole.name });
    
    return newRole;
  }

  /**
   * Update role
   */
  async updateRole(roleId: string, updates: Partial<AgentRole>): Promise<void> {
    const role = this.roles.get(roleId);
    if (!role) {
      throw new Error('Role not found');
    }

    const updatedRole = { ...role, ...updates };
    this.roles.set(roleId, updatedRole);
    
    logger.info('Role updated', { roleId, updates });
  }

  /**
   * Delete role
   */
  async deleteRole(roleId: string): Promise<void> {
    const role = this.roles.get(roleId);
    if (!role) {
      throw new Error('Role not found');
    }

    this.roles.delete(roleId);
    
    // Remove role from all user access controls
    for (const [key, accessControl] of this.userAccess.entries()) {
      if (accessControl.roles.includes(roleId)) {
        accessControl.roles = accessControl.roles.filter(id => id !== roleId);
        this.userAccess.set(key, accessControl);
      }
    }
    
    logger.info('Role deleted', { roleId, name: role.name });
  }

  /**
   * Initialize default roles
   */
  private initializeDefaultRoles(): void {
    const roles: Omit<AgentRole, 'roleId' | 'createdAt'>[] = [
      {
        name: 'Pilot Admin',
        description: 'Full access to pilot feedback agent features',
        permissions: [
          { permissionId: 'perm-1', resource: 'agent', actions: ['read', 'write', 'configure'] },
          { permissionId: 'perm-2', resource: 'recommendations', actions: ['read', 'approve', 'dismiss'] },
          { permissionId: 'perm-3', resource: 'audit', actions: ['read'] },
          { permissionId: 'perm-4', resource: 'feedback', actions: ['read', 'write'] }
        ]
      },
      {
        name: 'Developer',
        description: 'Read access to agent outputs with masked data',
        permissions: [
          { permissionId: 'perm-5', resource: 'agent', actions: ['read'] },
          { permissionId: 'perm-6', resource: 'recommendations', actions: ['read'] },
          { permissionId: 'perm-7', resource: 'feedback', actions: ['read'] }
        ]
      },
      {
        name: 'Compliance Officer',
        description: 'Access to compliance and audit features',
        permissions: [
          { permissionId: 'perm-8', resource: 'agent', actions: ['read', 'configure'] },
          { permissionId: 'perm-9', resource: 'audit', actions: ['read', 'write'] },
          { permissionId: 'perm-10', resource: 'compliance', actions: ['read', 'write'] }
        ]
      },
      {
        name: 'Support',
        description: 'Limited access to agent outputs for support purposes',
        permissions: [
          { permissionId: 'perm-11', resource: 'agent', actions: ['read'] },
          { permissionId: 'perm-12', resource: 'recommendations', actions: ['read'] }
        ]
      }
    ];

    roles.forEach(role => {
      const newRole: AgentRole = {
        ...role,
        roleId: this.generateId(),
        createdAt: new Date()
      };
      this.roles.set(newRole.roleId, newRole);
    });
  }

  /**
   * Initialize default permissions
   */
  private initializeDefaultPermissions(): void {
    const permissions: Omit<AgentPermission, 'permissionId'>[] = [
      { resource: 'agent', actions: ['read', 'write', 'configure'] },
      { resource: 'recommendations', actions: ['read', 'approve', 'dismiss'] },
      { resource: 'audit', actions: ['read', 'write'] },
      { resource: 'feedback', actions: ['read', 'write'] },
      { resource: 'compliance', actions: ['read', 'write'] }
    ];

    permissions.forEach(permission => {
      const newPermission: AgentPermission = {
        ...permission,
        permissionId: this.generateId()
      };
      this.permissions.set(newPermission.permissionId, newPermission);
    });
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}