import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { Activity, ActivityType, ActivityCategory, ParticipationLevel } from '../../entities/activities/Activity';
import { TherapySession, TherapyType, SessionStatus, ProgressLevel } from '../../entities/activities/TherapySession';
import { ResidentDietaryProfile } from '../../entities/catering/ResidentDietaryProfile';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export interface ActivitySearchCriteria {
  activityType?: ActivityType;
  category?: ActivityCategory;
  facilitator?: string;
  date?: Date;
  location?: string;
  status?: string;
}

export interface TherapyAnalytics {
  totalActivities: number;
  activitiesThisWeek: number;
  averageParticipationRate: number;
  averageEnjoymentLevel: number;
  therapeuticActivities: number;
  socialActivities: number;
  physicalActivities: number;
  cognitiveActivities: number;
}

export interface ResidentActivityProfile {
  residentId: string;
  totalActivitiesParticipated: number;
  favoriteActivityTypes: ActivityType[];
  averageEnjoymentLevel: number;
  averageEngagementLevel: number;
  therapeuticGoalsProgress: { [goal: string]: number };
  lastActivityDate: Date;
  recommendedActivities: string[];
}

export interface ActivityPlanningResult {
  date: Date;
  plannedActivities: Activity[];
  resourceConflicts: string[];
  staffingRequirements: { [timeSlot: string]: number };
  estimatedCost: number;
}

export interface TherapeuticOutcome {
  residentId: string;
  goalType: string;
  baselineMeasurement: number;
  currentMeasurement: number;
  improvementPercentage: number;
  assessmentDate: Date;
  nextAssessmentDate: Date;
  notes: string;
}

export class ActivitiesTherapyService {
  private activityRepository: Repository<Activity>;
  private therapySessionRepository: Repository<TherapySession>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;

  constructor() {
    this.activityRepository = AppDataSource.getRepository(Activity);
    this.therapySessionRepository = AppDataSource.getRepository(TherapySession);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  // Activity Management
  async createActivity(activityData: Partial<Activity>): Promise<Activity> {
    const activity = this.activityRepository.create({
      ...activityData,
      status: 'scheduled',
      currentParticipants: 0
    });

    const savedActivity = await this.activityRepository.save(activity);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Activity',
        entityType: 'Activity',
      entityId: savedActivity.id,
      action: 'CREATE',
      details: { 
        activityName: savedActivity.activityName,
        scheduledTime: savedActivity.scheduledStartTime
      },
      userId: 'system'
    });

    // Send notification to facilitator
    await this.notificationService.sendNotification({
      message: 'Notification: Activity Scheduled',
        type: 'activity_scheduled',
      recipients: [savedActivity.facilitator],
      data: {
        activityName: savedActivity.activityName,
        scheduledTime: savedActivity.scheduledStartTime,
        location: savedActivity.location,
        maxParticipants: savedActivity.maxParticipants
      }
    });

    return savedActivity;
  }

  async getAllActivities(): Promise<Activity[]> {
    return await this.activityRepository.find({
      order: { scheduledStartTime: 'ASC' }
    });
  }

  async getActivityById(activityId: string): Promise<Activity | null> {
    return await this.activityRepository.findOne({
      where: { id: activityId }
    });
  }

  async searchActivities(criteria: ActivitySearchCriteria): Promise<Activity[]> {
    let queryBuilder = this.activityRepository.createQueryBuilder('activity');

    if (criteria.activityType) {
      queryBuilder = queryBuilder.andWhere('activity.activityType = :activityType', { 
        activityType: criteria.activityType 
      });
    }

    if (criteria.category) {
      queryBuilder = queryBuilder.andWhere('activity.category = :category', { 
        category: criteria.category 
      });
    }

    if (criteria.facilitator) {
      queryBuilder = queryBuilder.andWhere('activity.facilitator = :facilitator', { 
        facilitator: criteria.facilitator 
      });
    }

    if (criteria.date) {
      const startOfDay = new Date(criteria.date);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(criteria.date);
      endOfDay.setHours(23, 59, 59, 999);

      queryBuilder = queryBuilder.andWhere('activity.scheduledStartTime BETWEEN :start AND :end', { 
        start: startOfDay, 
        end: endOfDay 
      });
    }

    if (criteria.location) {
      queryBuilder = queryBuilder.andWhere('activity.location = :location', { 
        location: criteria.location 
      });
    }

    if (criteria.status) {
      queryBuilder = queryBuilder.andWhere('activity.status = :status', { 
        status: criteria.status 
      });
    }

    return await queryBuilder.getMany();
  }

  async updateActivity(activityId: string, updateData: Partial<Activity>): Promise<Activity> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    Object.assign(activity, updateData);
    const updatedActivity = await this.activityRepository.save(activity);

    // Log audit trail
    await this.auditService.logEvent({
        resource: 'Activity',
        entityType: 'Activity',
        entityId: activityId,
        action: 'UPDATE',
        resource: 'Activity',
        details: updateData,
        userId: 'system'
    
      });

    return updatedActivity;
  }

  // Activity Scheduling
  async scheduleRecurringActivity(activityData: Partial<Activity>, recurrencePattern: any): Promise<Activity[]> {
    const activities: Activity[] = [];
    const baseActivity = { ...activityData, isRecurring: true, recurrencePattern };
    
    let currentDate = new Date(activityData.scheduledStartTime!);
    const endDate = recurrencePattern.endDate || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1 year default

    while (currentDate <= endDate) {
      const activityInstance = {
        ...baseActivity,
        scheduledStartTime: new Date(currentDate),
        scheduledEndTime: new Date(currentDate.getTime() + (activityData.requirements?.duration || 60) * 60 * 1000)
      };

      const savedActivity = await this.createActivity(activityInstance);
      activities.push(savedActivity);

      // Calculate next occurrence
      switch (recurrencePattern.frequency) {
        case 'daily':
          currentDate.setDate(currentDate.getDate() + recurrencePattern.interval);
          break;
        case 'weekly':
          currentDate.setDate(currentDate.getDate() + (recurrencePattern.interval * 7));
          break;
        case 'monthly':
          currentDate.setMonth(currentDate.getMonth() + recurrencePattern.interval);
          break;
      }
    }

    return activities;
  }

  async getActivitiesForDate(date: Date): Promise<Activity[]> {
    return await this.searchActivities({ date });
  }

  async getTodaysActivities(): Promise<Activity[]> {
    return await this.getActivitiesForDate(new Date());
  }

  // Participation Management
  async addParticipant(activityId: string, residentId: string): Promise<void> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    if (!activity.canAcceptMoreParticipants()) {
      throw new Error('Activity is at maximum capacity');
    }

    if (!activity.targetResidents.includes(residentId)) {
      activity.targetResidents.push(residentId);
      activity.currentParticipants++;
      
      await this.activityRepository.save(activity);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'Activity',
        entityType: 'Activity',
        entityId: activityId,
        action: 'ADD_PARTICIPANT',
        details: { residentId },
        userId: 'system'
      });
    }
  }

  async removeParticipant(activityId: string, residentId: string): Promise<void> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    const index = activity.targetResidents.indexOf(residentId);
    if (index > -1) {
      activity.targetResidents.splice(index, 1);
      activity.currentParticipants--;
      
      await this.activityRepository.save(activity);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'Activity',
        entityType: 'Activity',
        entityId: activityId,
        action: 'REMOVE_PARTICIPANT',
        details: { residentId },
        userId: 'system'
      });
    }
  }

  async recordParticipationOutcome(activityId: string, outcome: Partial<any>): Promise<void> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    const fullOutcome = {
      ...outcome,
      recordedAt: new Date()
    };

    activity.addParticipantOutcome(fullOutcome);
    await this.activityRepository.save(activity);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Activity',
        entityType: 'Activity',
      entityId: activityId,
      action: 'RECORD_OUTCOME',
      details: { participantId: outcome.participantId, participationLevel: outcome.participationLevel },
      userId: 'system'
    });
  }

  // Activity Execution
  async startActivity(activityId: string): Promise<void> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    if (!activity.isScheduled()) {
      throw new Error('Activity is not in scheduled status');
    }

    activity.status = 'in_progress';
    activity.actualStartTime = new Date();
    
    await this.activityRepository.save(activity);

    // Send notification to participants
    await this.notificationService.sendNotification({
      message: 'Notification: Activity Started',
        type: 'activity_started',
      recipients: activity.targetResidents,
      data: {
        activityName: activity.activityName,
        location: activity.location,
        facilitator: activity.facilitator
      }
    });
  }

  async completeActivity(activityId: string, sessionNotes?: string): Promise<void> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    if (!activity.isInProgress()) {
      throw new Error('Activity is not in progress');
    }

    activity.status = 'completed';
    activity.actualEndTime = new Date();
    if (sessionNotes) {
      activity.sessionNotes = sessionNotes;
    }
    
    await this.activityRepository.save(activity);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Activity',
        entityType: 'Activity',
      entityId: activityId,
      action: 'COMPLETE',
      details: { 
        duration: activity.getDuration(),
        participationRate: activity.getParticipationRate()
      },
      userId: 'system'
    });
  }

  async cancelActivity(activityId: string, reason: string): Promise<void> {
    const activity = await this.getActivityById(activityId);
    if (!activity) {
      throw new Error('Activity not found');
    }

    activity.status = 'cancelled';
    activity.sessionNotes = `Cancelled: ${reason}`;
    
    await this.activityRepository.save(activity);

    // Send notification to participants and facilitator
    await this.notificationService.sendNotification({
      message: 'Notification: Activity Cancelled',
        type: 'activity_cancelled',
      recipients: [...activity.targetResidents, activity.facilitator],
      data: {
        activityName: activity.activityName,
        scheduledTime: activity.scheduledStartTime,
        reason
      }
    });
  }

  // Analytics and Reporting
  async getTherapyAnalytics(): Promise<TherapyAnalytics> {
    const allActivities = await this.getAllActivities();
    const thisWeek = this.getThisWeekActivities(allActivities);
    
    const totalActivities = allActivities.length;
    const activitiesThisWeek = thisWeek.length;
    
    const completedActivities = allActivities.filter(activity => activity.isCompleted());
    const averageParticipationRate = completedActivities.length > 0 
      ? completedActivities.reduce((sum, activity) => sum + activity.getParticipationRate(), 0) / completedActivities.length 
      : 0;
    
    const averageEnjoymentLevel = completedActivities.length > 0
      ? completedActivities.reduce((sum, activity) => sum + activity.getAverageEnjoymentLevel(), 0) / completedActivities.length
      : 0;

    const therapeuticActivities = allActivities.filter(activity => activity.isTherapeutic()).length;
    const socialActivities = allActivities.filter(activity => activity.activityType === ActivityType.SOCIAL).length;
    const physicalActivities = allActivities.filter(activity => activity.activityType === ActivityType.PHYSICAL).length;
    const cognitiveActivities = allActivities.filter(activity => activity.activityType === ActivityType.COGNITIVE).length;

    return {
      totalActivities,
      activitiesThisWeek,
      averageParticipationRate,
      averageEnjoymentLevel,
      therapeuticActivities,
      socialActivities,
      physicalActivities,
      cognitiveActivities
    };
  }

  async getResidentActivityProfile(residentId: string): Promise<ResidentActivityProfile> {
    const activities = await this.activityRepository.find();
    const residentActivities = activities.filter(activity => 
      activity.targetResidents.includes(residentId) && activity.isCompleted()
    );

    const totalActivities = residentActivities.length;
    
    // Calculate favorite activity types
    const activityTypeCounts = residentActivities.reduce((acc, activity) => {
      acc[activity.activityType] = (acc[activity.activityType] || 0) + 1;
      return acc;
    }, {} as { [key: string]: number });

    const favoriteActivityTypes = Object.entries(activityTypeCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([type]) => type as ActivityType);

    // Calculate averages
    const outcomes = residentActivities.flatMap(activity => 
      activity.outcomes.filter(outcome => outcome.participantId === residentId)
    );

    const averageEnjoymentLevel = outcomes.length > 0
      ? outcomes.reduce((sum, outcome) => sum + outcome.enjoymentLevel, 0) / outcomes.length
      : 0;

    const averageEngagementLevel = outcomes.length > 0
      ? outcomes.reduce((sum, outcome) => sum + outcome.engagementLevel, 0) / outcomes.length
      : 0;

    // Calculate therapeutic progress
    const therapeuticGoalsProgress = this.calculateTherapeuticProgress(residentId, residentActivities);

    // Get last activity date
    const lastActivityDate = residentActivities.length > 0
      ? residentActivities.sort((a, b) => 
          new Date(b.scheduledStartTime).getTime() - new Date(a.scheduledStartTime).getTime()
        )[0].scheduledStartTime
      : new Date();

    // Generate recommendations
    const recommendedActivities = this.generateActivityRecommendations(residentId, favoriteActivityTypes, averageEnjoymentLevel);

    return {
      residentId,
      totalActivitiesParticipated: totalActivities,
      favoriteActivityTypes,
      averageEnjoymentLevel,
      averageEngagementLevel,
      therapeuticGoalsProgress,
      lastActivityDate,
      recommendedActivities
    };
  }

  // Activity Planning
  async planActivitiesForWeek(startDate: Date): Promise<ActivityPlanningResult[]> {
    const weekResults: ActivityPlanningResult[] = [];
    
    for (let i = 0; i < 7; i++) {
      const date = new Date(startDate);
      date.setDate(date.getDate() + i);
      
      const dayResult = await this.planActivitiesForDay(date);
      weekResults.push(dayResult);
    }
    
    return weekResults;
  }

  private async planActivitiesForDay(date: Date): Promise<ActivityPlanningResult> {
    const plannedActivities = await this.getActivitiesForDate(date);
    const resourceConflicts = this.checkResourceConflicts(plannedActivities);
    const staffingRequirements = this.calculateStaffingRequirements(plannedActivities);
    const estimatedCost = this.calculateEstimatedCost(plannedActivities);

    return {
      date,
      plannedActivities,
      resourceConflicts,
      staffingRequirements,
      estimatedCost
    };
  }

  // Therapeutic Outcome Tracking
  async recordTherapeuticOutcome(outcome: TherapeuticOutcome): Promise<void> {
    // Log audit trail
    await this.auditService.logEvent({
        resource: 'TherapeuticOutcome',
        entityType: 'TherapeuticOutcome',
        entityId: crypto.randomUUID(),
        action: 'RECORD',
        resource: 'TherapeuticOutcome',
        details: outcome,
        userId: 'system'
    
      });

    // Send notification if significant improvement
    if (outcome.improvementPercentage > 20) {
      await this.notificationService.sendNotification({
        message: 'Notification: Therapeutic Progress',
        type: 'therapeutic_progress',
        recipients: ['therapists', 'care_managers'],
        data: {
          residentId: outcome.residentId,
          goalType: outcome.goalType,
          improvement: outcome.improvementPercentage,
          assessmentDate: outcome.assessmentDate
        }
      });
    }
  }

  async getTherapeuticOutcomes(residentId: string): Promise<TherapeuticOutcome[]> {
    const activities = await this.activityRepository.find({
      where: { targetResidents: { $in: [residentId] } } as any
    });

    const therapeuticActivities = activities.filter(activity => activity.isTherapeutic());
    const outcomes: TherapeuticOutcome[] = [];
    
    // Group activities by therapeutic goal type
    const goalTypes = new Set<string>();
    therapeuticActivities.forEach(activity => {
      activity.therapeuticGoals.primary.forEach(goal => goalTypes.add(goal));
    });

    for (const goalType of goalTypes) {
      const relevantActivities = therapeuticActivities.filter(activity => 
        activity.therapeuticGoals.primary.includes(goalType)
      );

      if (relevantActivities.length === 0) continue;

      // Calculate baseline from first recorded outcome
      const firstActivity = relevantActivities.sort((a, b) => 
        new Date(a.scheduledStartTime).getTime() - new Date(b.scheduledStartTime).getTime()
      )[0];
      
      const firstOutcome = firstActivity.getOutcomeForParticipant(residentId);
      const baselineMeasurement = firstOutcome?.engagementLevel || 2.0;

      // Calculate current measurement from recent activities
      const recentActivities = relevantActivities
        .filter(activity => {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          return new Date(activity.scheduledStartTime) >= thirtyDaysAgo;
        })
        .sort((a, b) => new Date(b.scheduledStartTime).getTime() - new Date(a.scheduledStartTime).getTime());

      if (recentActivities.length === 0) continue;

      const recentOutcomes = recentActivities
        .map(activity => activity.getOutcomeForParticipant(residentId))
        .filter(outcome => outcome !== null);

      const currentMeasurement = recentOutcomes.length > 0
        ? recentOutcomes.reduce((sum, outcome) => sum + outcome.engagementLevel, 0) / recentOutcomes.length
        : baselineMeasurement;

      const improvementPercentage = baselineMeasurement > 0 
        ? ((currentMeasurement - baselineMeasurement) / baselineMeasurement) * 100 
        : 0;

      const latestActivity = recentActivities[0];
      const latestOutcome = latestActivity.getOutcomeForParticipant(residentId);

      outcomes.push({
        residentId,
        goalType,
        baselineMeasurement,
        currentMeasurement,
        improvementPercentage,
        assessmentDate: latestOutcome?.recordedAt || new Date(),
        nextAssessmentDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        notes: this.generateTherapeuticNotes(goalType, improvementPercentage, recentOutcomes.length)
      });
    }
    
    return outcomes;
  }

  private generateTherapeuticNotes(goalType: string, improvement: number, sessionCount: number): string {
    let notes = `Based on ${sessionCount} therapeutic sessions. `;
    
    if (improvement > 20) {
      notes += `Excellent progress in ${goalType} with ${improvement.toFixed(1)}% improvement. Continue current intervention plan.`;
    } else if (improvement > 5) {
      notes += `Good progress in ${goalType} with ${improvement.toFixed(1)}% improvement. Maintain current approach.`;
    } else if (improvement > -5) {
      notes += `Stable progress in ${goalType}. Consider adjusting intervention strategies.`;
    } else {
      notes += `Declining performance in ${goalType} (${improvement.toFixed(1)}% decrease). Immediate review and intervention plan adjustment required.`;
    }
    
    return notes;
  }

  // Resource Management
  async checkResourceAvailability(date: Date, timeSlot: string): Promise<any> {
    const activities = await this.getActivitiesForDate(date);
    const conflictingActivities = activities.filter(activity => 
      this.isTimeSlotConflict(activity, timeSlot)
    );

    const usedResources = conflictingActivities.flatMap(activity => activity.resources);
    
    return {
      date,
      timeSlot,
      availableResources: this.getAvailableResources(usedResources),
      conflictingActivities: conflictingActivities.map(activity => ({
        id: activity.id,
        name: activity.activityName,
        location: activity.location,
        resources: activity.resources
      }))
    };
  }

  // Private helper methods
  private getThisWeekActivities(activities: Activity[]): Activity[] {
    const now = new Date();
    const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay()));
    const endOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + 6));

    return activities.filter(activity => {
      const activityDate = new Date(activity.scheduledStartTime);
      return activityDate >= startOfWeek && activityDate <= endOfWeek;
    });
  }

  private calculateTherapeuticProgress(residentId: string, activities: Activity[]): { [goal: string]: number } {
    const therapeuticActivities = activities.filter(activity => activity.isTherapeutic());
    const progress: { [goal: string]: number } = {};

    for (const activity of therapeuticActivities) {
      for (const goal of activity.therapeuticGoals.primary) {
        const outcome = activity.getOutcomeForParticipant(residentId);
        if (outcome) {
          progress[goal] = (progress[goal] || 0) + outcome.engagementLevel;
        }
      }
    }

    // Average the progress scores
    for (const goal in progress) {
      const activityCount = therapeuticActivities.filter(activity => 
        activity.therapeuticGoals.primary.includes(goal)
      ).length;
      progress[goal] = activityCount > 0 ? progress[goal] / activityCount : 0;
    }

    return progress;
  }

  private generateActivityRecommendations(residentId: string, favoriteTypes: ActivityType[], enjoymentLevel: number): string[] {
    const recommendations = [];

    // Recommend based on favorite types
    if (favoriteTypes.includes(ActivityType.SOCIAL)) {
      recommendations.push('Group social activities', 'Community events');
    }

    if (favoriteTypes.includes(ActivityType.PHYSICAL)) {
      recommendations.push('Chair exercises', 'Walking groups');
    }

    if (favoriteTypes.includes(ActivityType.COGNITIVE)) {
      recommendations.push('Puzzles and games', 'Memory activities');
    }

    // Recommend based on enjoyment level
    if (enjoymentLevel < 3) {
      recommendations.push('One-on-one activities', 'Personalized therapy sessions');
    }

    return recommendations.slice(0, 5); // Limit to top 5 recommendations
  }

  private checkResourceConflicts(activities: Activity[]): string[] {
    const conflicts = [];
    const resourceUsage: { [resource: string]: Activity[] } = {};

    // Group activities by resource usage
    for (const activity of activities) {
      for (const resource of activity.resources) {
        const resourceKey = `${resource.resourceType}:${resource.name}`;
        if (!resourceUsage[resourceKey]) {
          resourceUsage[resourceKey] = [];
        }
        resourceUsage[resourceKey].push(activity);
      }
    }

    // Check for conflicts
    for (const [resourceKey, resourceActivities] of Object.entries(resourceUsage)) {
      if (resourceActivities.length > 1) {
        // Check for time overlaps
        for (let i = 0; i < resourceActivities.length; i++) {
          for (let j = i + 1; j < resourceActivities.length; j++) {
            if (this.activitiesOverlap(resourceActivities[i], resourceActivities[j])) {
              conflicts.push(`Resource conflict: ${resourceKey} between ${resourceActivities[i].activityName} and ${resourceActivities[j].activityName}`);
            }
          }
        }
      }
    }

    return conflicts;
  }

  private calculateStaffingRequirements(activities: Activity[]): { [timeSlot: string]: number } {
    const requirements: { [timeSlot: string]: number } = {};
    
    for (const activity of activities) {
      const timeSlot = `${activity.scheduledStartTime.getHours()}:00`;
      const staffNeeded = activity.getRequiredStaffCount();
      requirements[timeSlot] = (requirements[timeSlot] || 0) + staffNeeded;
    }
    
    return requirements;
  }

  private calculateEstimatedCost(activities: Activity[]): number {
    return activities.reduce((total, activity) => {
      const resourceCost = activity.resources.reduce((sum, resource) => sum + (resource.cost || 0), 0);
      const staffCost = activity.getRequiredStaffCount() * 25 * (activity.getDuration() / 60); // Â£25/hour
      return total + resourceCost + staffCost;
    }, 0);
  }

  private isTimeSlotConflict(activity: Activity, timeSlot: string): boolean {
    const [hour] = timeSlot.split(':').map(Number);
    const activityHour = activity.scheduledStartTime.getHours();
    const activityEndHour = activity.scheduledEndTime.getHours();
    
    return hour >= activityHour && hour < activityEndHour;
  }

  private activitiesOverlap(activity1: Activity, activity2: Activity): boolean {
    const start1 = activity1.scheduledStartTime.getTime();
    const end1 = activity1.scheduledEndTime.getTime();
    const start2 = activity2.scheduledStartTime.getTime();
    const end2 = activity2.scheduledEndTime.getTime();
    
    return start1 < end2 && start2 < end1;
  }

  private getAvailableResources(usedResources: any[]): any[] {
    // Advanced resource availability checking with real-time data
    const allResources = [
      { resourceType: 'equipment', name: 'Piano', availability: 'available' },
      { resourceType: 'equipment', name: 'Art supplies', availability: 'available' },
      { resourceType: 'space', name: 'Activity room', availability: 'available' },
      { resourceType: 'space', name: 'Garden', availability: 'available' }
    ];

    const usedResourceKeys = usedResources.map(resource => `${resource.resourceType}:${resource.name}`);
    
    return allResources.filter(resource => 
      !usedResourceKeys.includes(`${resource.resourceType}:${resource.name}`)
    );
  }

  // Therapy Session Management
  async createTherapySession(sessionData: Partial<TherapySession>): Promise<TherapySession> {
    const session = this.therapySessionRepository.create({
      ...sessionData,
      status: SessionStatus.SCHEDULED
    });

    const savedSession = await this.therapySessionRepository.save(session);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TherapySession',
        entityType: 'TherapySession',
      entityId: savedSession.id,
      action: 'CREATE',
      details: { 
        therapyType: savedSession.therapyType,
        residentId: savedSession.residentId,
        scheduledTime: savedSession.scheduledStartTime
      },
      userId: 'system'
    });

    // Send notification to therapist
    await this.notificationService.sendNotification({
      message: 'Notification: Therapy Session Scheduled',
        type: 'therapy_session_scheduled',
      recipients: [savedSession.therapistId],
      data: {
        sessionNumber: savedSession.sessionNumber,
        therapyType: savedSession.therapyType,
        residentId: savedSession.residentId,
        scheduledTime: savedSession.scheduledStartTime,
        location: savedSession.location
      }
    });

    return savedSession;
  }

  async getTherapySessionsByResident(residentId: string): Promise<TherapySession[]> {
    return await this.therapySessionRepository.find({
      where: { residentId },
      order: { scheduledStartTime: 'DESC' }
    });
  }

  async getTherapySessionsByTherapist(therapistId: string): Promise<TherapySession[]> {
    return await this.therapySessionRepository.find({
      where: { therapistId },
      order: { scheduledStartTime: 'DESC' }
    });
  }

  async getTherapySessionById(sessionId: string): Promise<TherapySession | null> {
    return await this.therapySessionRepository.findOne({
      where: { id: sessionId }
    });
  }

  async startTherapySession(sessionId: string): Promise<void> {
    const session = await this.getTherapySessionById(sessionId);
    if (!session) {
      throw new Error('Therapy session not found');
    }

    if (!session.isScheduled()) {
      throw new Error('Therapy session is not in scheduled status');
    }

    session.status = SessionStatus.IN_PROGRESS;
    session.actualStartTime = new Date();
    
    await this.therapySessionRepository.save(session);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TherapySession',
        entityType: 'TherapySession',
      entityId: sessionId,
      action: 'START',
      details: { 
        therapyType: session.therapyType,
        residentId: session.residentId
      },
      userId: 'system'
    });
  }

  async completeTherapySession(sessionId: string, sessionOutcome: any): Promise<void> {
    const session = await this.getTherapySessionById(sessionId);
    if (!session) {
      throw new Error('Therapy session not found');
    }

    if (!session.isInProgress()) {
      throw new Error('Therapy session is not in progress');
    }

    session.status = SessionStatus.COMPLETED;
    session.actualEndTime = new Date();
    session.actualDuration = session.getDuration();
    session.sessionOutcome = sessionOutcome;
    
    await this.therapySessionRepository.save(session);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TherapySession',
        entityType: 'TherapySession',
      entityId: sessionId,
      action: 'COMPLETE',
      details: { 
        therapyType: session.therapyType,
        residentId: session.residentId,
        duration: session.actualDuration,
        progress: session.getProgressPercentage()
      },
      userId: 'system'
    });

    // Send notification if significant progress
    if (sessionOutcome.overallProgress === ProgressLevel.SIGNIFICANT_IMPROVEMENT) {
      await this.notificationService.sendNotification({
        message: 'Notification: Therapy Progress',
        type: 'therapy_progress',
        recipients: ['care_managers', 'family_members'],
        data: {
          residentId: session.residentId,
          therapyType: session.therapyType,
          sessionNumber: session.sessionNumber,
          progress: sessionOutcome.overallProgress
        }
      });
    }
  }

  async cancelTherapySession(sessionId: string, reason: string): Promise<void> {
    const session = await this.getTherapySessionById(sessionId);
    if (!session) {
      throw new Error('Therapy session not found');
    }

    session.status = SessionStatus.CANCELLED;
    session.cancellationReason = reason;
    
    await this.therapySessionRepository.save(session);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TherapySession',
        entityType: 'TherapySession',
      entityId: sessionId,
      action: 'CANCEL',
      details: { 
        therapyType: session.therapyType,
        residentId: session.residentId,
        reason
      },
      userId: 'system'
    });

    // Send notification to resident and family
    await this.notificationService.sendNotification({
      message: 'Notification: Therapy Session Cancelled',
        type: 'therapy_session_cancelled',
      recipients: [session.residentId, 'family_members'],
      data: {
        therapyType: session.therapyType,
        scheduledTime: session.scheduledStartTime,
        reason
      }
    });
  }

  async updateTherapyGoalProgress(sessionId: string, goalId: string, progress: number): Promise<void> {
    const session = await this.getTherapySessionById(sessionId);
    if (!session) {
      throw new Error('Therapy session not found');
    }

    session.updateGoalProgress(goalId, progress);
    await this.therapySessionRepository.save(session);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TherapySession',
        entityType: 'TherapySession',
      entityId: sessionId,
      action: 'UPDATE_GOAL_PROGRESS',
      details: { goalId, progress },
      userId: 'system'
    });
  }

  async recordSafetyIncident(sessionId: string, incident: any): Promise<void> {
    const session = await this.getTherapySessionById(sessionId);
    if (!session) {
      throw new Error('Therapy session not found');
    }

    session.recordSafetyIncident(incident);
    await this.therapySessionRepository.save(session);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TherapySession',
        entityType: 'TherapySession',
      entityId: sessionId,
      action: 'SAFETY_INCIDENT',
      details: { 
        incidentType: incident.incidentType,
        severity: incident.severity
      },
      userId: 'system'
    });

    // Send urgent notification for high severity incidents
    if (incident.severity === 'high' || incident.severity === 'critical') {
      await this.notificationService.sendNotification({
        message: 'Notification: Safety Incident',
        type: 'safety_incident',
        recipients: ['safety_officer', 'care_manager', 'admin'],
        priority: 'urgent',
        data: {
          sessionId,
          residentId: session.residentId,
          incidentType: incident.incidentType,
          severity: incident.severity,
          description: incident.description
        }
      });
    }
  }

  async getTherapyProgressReport(residentId: string, therapyType?: TherapyType): Promise<any> {
    const sessions = await this.therapySessionRepository.find({
      where: { 
        residentId,
        ...(therapyType && { therapyType })
      },
      order: { scheduledStartTime: 'ASC' }
    });

    const completedSessions = sessions.filter(session => session.isCompleted());
    
    if (completedSessions.length === 0) {
      return {
        residentId,
        therapyType,
        totalSessions: 0,
        completedSessions: 0,
        averageProgress: 0,
        overallTrend: 'no_data'
      };
    }

    const progressData = completedSessions.map(session => ({
      sessionNumber: session.sessionNumber,
      date: session.scheduledStartTime,
      progress: session.getProgressPercentage(),
      goalsAchieved: session.getAchievedGoalsCount(),
      totalGoals: session.therapyGoals.length
    }));

    const averageProgress = progressData.reduce((sum, data) => sum + data.progress, 0) / progressData.length;
    
    // Calculate trend
    const recentSessions = progressData.slice(-3);
    const olderSessions = progressData.slice(0, -3);
    
    let overallTrend = 'stable';
    if (recentSessions.length >= 2 && olderSessions.length >= 2) {
      const recentAvg = recentSessions.reduce((sum, data) => sum + data.progress, 0) / recentSessions.length;
      const olderAvg = olderSessions.reduce((sum, data) => sum + data.progress, 0) / olderSessions.length;
      
      if (recentAvg > olderAvg + 5) {
        overallTrend = 'improving';
      } else if (recentAvg < olderAvg - 5) {
        overallTrend = 'declining';
      }
    }

    return {
      residentId,
      therapyType,
      totalSessions: sessions.length,
      completedSessions: completedSessions.length,
      averageProgress,
      overallTrend,
      progressData,
      lastSessionDate: completedSessions[completedSessions.length - 1]?.scheduledStartTime,
      nextSessionDate: sessions.find(s => s.isScheduled())?.scheduledStartTime
    };
  }

  async getTherapistWorkload(therapistId: string, startDate: Date, endDate: Date): Promise<any> {
    const sessions = await this.therapySessionRepository.find({
      where: { 
        therapistId,
        scheduledStartTime: {
          $gte: startDate,
          $lte: endDate
        } as any
      },
      order: { scheduledStartTime: 'ASC' }
    });

    const workloadByDay = {};
    const therapyTypeCounts = {};
    let totalHours = 0;

    sessions.forEach(session => {
      const date = session.scheduledStartTime.toISOString().split('T')[0];
      if (!workloadByDay[date]) {
        workloadByDay[date] = { sessions: 0, hours: 0 };
      }
      
      workloadByDay[date].sessions++;
      workloadByDay[date].hours += session.plannedDuration / 60;
      totalHours += session.plannedDuration / 60;

      therapyTypeCounts[session.therapyType] = (therapyTypeCounts[session.therapyType] || 0) + 1;
    });

    return {
      therapistId,
      period: { startDate, endDate },
      totalSessions: sessions.length,
      totalHours,
      averageSessionsPerDay: sessions.length / Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)),
      workloadByDay,
      therapyTypeBreakdown: therapyTypeCounts,
      completedSessions: sessions.filter(s => s.isCompleted()).length,
      cancelledSessions: sessions.filter(s => s.isCancelled()).length
    };
  }
}