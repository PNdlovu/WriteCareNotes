import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { ShiftSwap, ShiftSwapStatus } from '../../entities/hr/ShiftSwap';
import { Employee } from '../../entities/hr/Employee';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export interface ShiftSwapSearchCriteria {
  status?: ShiftSwapStatus;
  requesterId?: string;
  accepterId?: string;
  department?: string;
  dateRange?: {
    start: Date;
    end: Date;
  };
}

export interface ShiftSwapSummary {
  totalSwaps: number;
  pendingSwaps: number;
  approvedSwaps: number;
  rejectedSwaps: number;
  cancelledSwaps: number;
  byDepartment: {
    department: string;
    count: number;
    approved: number;
    rejected: number;
  }[];
  byMonth: {
    month: string;
    count: number;
    approved: number;
    rejected: number;
  }[];
  averageProcessingTime: number; // in hours
  approvalRate: number;
}

export interface ShiftSwapRequestData {
  requesterId: string;
  offeredShiftId: string;
  desiredShiftId: string;
  reason: string;
  notes?: string;
}

export interface ShiftSwapApprovalData {
  approverId: string;
  approved: boolean;
  rejectionReason?: string;
  notes?: string;
}

export interface ShiftSwapAcceptanceData {
  accepterId: string;
  accepted: boolean;
  notes?: string;
}

export interface ShiftAvailability {
  employeeId: string;
  availableShifts: {
    shiftId: string;
    date: Date;
    startTime: string;
    endTime: string;
    department: string;
    role: string;
  }[];
}

export class ShiftSwapService {
  private shiftSwapRepository: Repository<ShiftSwap>;
  private employeeRepository: Repository<Employee>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;

  constructor() {
    this.shiftSwapRepository = AppDataSource.getRepository(ShiftSwap);
    this.employeeRepository = AppDataSource.getRepository(Employee);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  // Shift Swap Request Management
  async createShiftSwapRequest(requestData: ShiftSwapRequestData): Promise<ShiftSwap> {
    // Validate requester exists
    const requester = await this.employeeRepository.findOne({
      where: { id: requestData.requesterId }
    });
    if (!requester) {
      throw new Error('Requester not found');
    }

    // Validate shifts exist and belong to requester
    // This would typically involve checking against a shifts table
    // For now, we'll assume the validation is done elsewhere

    // Check for existing pending swap for the same shifts
    const existingSwap = await this.shiftSwapRepository.findOne({
      where: {
        offeredShiftId: requestData.offeredShiftId,
        desiredShiftId: requestData.desiredShiftId,
        status: ShiftSwapStatus.PENDING
      }
    });
    if (existingSwap) {
      throw new Error('Shift swap request already exists for these shifts');
    }

    const shiftSwap = this.shiftSwapRepository.create({
      ...requestData,
      status: ShiftSwapStatus.PENDING,
      requestDate: new Date()
    });

    const savedSwap = await this.shiftSwapRepository.save(shiftSwap);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'ShiftSwap',
      entityType: 'ShiftSwap',
      entityId: savedSwap.id,
      action: 'CREATE',
      details: {
        requesterId: savedSwap.requesterId,
        offeredShiftId: savedSwap.offeredShiftId,
        desiredShiftId: savedSwap.desiredShiftId,
        reason: savedSwap.reason
      },
      userId: 'system'
    });

    // Send notification to potential accepters
    await this.notificationService.sendNotification({
      message: 'New Shift Swap Request',
      type: 'shift_swap_request',
      recipients: ['hr_team', 'line_managers'],
      data: {
        requesterName: requester.getFullName(),
        offeredShiftId: savedSwap.offeredShiftId,
        desiredShiftId: savedSwap.desiredShiftId,
        reason: savedSwap.reason
      }
    });

    return savedSwap;
  }

  async getShiftSwapById(swapId: string): Promise<ShiftSwap | null> {
    return await this.shiftSwapRepository.findOne({
      where: { id: swapId },
      relations: ['requester', 'accepter']
    });
  }

  async getAllShiftSwaps(): Promise<ShiftSwap[]> {
    return await this.shiftSwapRepository.find({
      relations: ['requester', 'accepter'],
      order: { requestDate: 'DESC' }
    });
  }

  async getShiftSwapsByRequester(requesterId: string): Promise<ShiftSwap[]> {
    return await this.shiftSwapRepository.find({
      where: { requesterId },
      relations: ['requester', 'accepter'],
      order: { requestDate: 'DESC' }
    });
  }

  async getShiftSwapsByAccepter(accepterId: string): Promise<ShiftSwap[]> {
    return await this.shiftSwapRepository.find({
      where: { accepterId },
      relations: ['requester', 'accepter'],
      order: { requestDate: 'DESC' }
    });
  }

  async searchShiftSwaps(criteria: ShiftSwapSearchCriteria): Promise<ShiftSwap[]> {
    let queryBuilder = this.shiftSwapRepository.createQueryBuilder('swap')
      .leftJoinAndSelect('swap.requester', 'requester')
      .leftJoinAndSelect('swap.accepter', 'accepter');

    if (criteria.status) {
      queryBuilder = queryBuilder.andWhere('swap.status = :status', { status: criteria.status });
    }

    if (criteria.requesterId) {
      queryBuilder = queryBuilder.andWhere('swap.requesterId = :requesterId', { requesterId: criteria.requesterId });
    }

    if (criteria.accepterId) {
      queryBuilder = queryBuilder.andWhere('swap.accepterId = :accepterId', { accepterId: criteria.accepterId });
    }

    if (criteria.department) {
      queryBuilder = queryBuilder.andWhere('requester.department = :department', { department: criteria.department });
    }

    if (criteria.dateRange) {
      queryBuilder = queryBuilder.andWhere('swap.requestDate >= :startDate', { startDate: criteria.dateRange.start });
      queryBuilder = queryBuilder.andWhere('swap.requestDate <= :endDate', { endDate: criteria.dateRange.end });
    }

    return await queryBuilder.getMany();
  }

  async updateShiftSwap(swapId: string, updateData: Partial<ShiftSwap>): Promise<ShiftSwap> {
    const swap = await this.getShiftSwapById(swapId);
    if (!swap) {
      throw new Error('Shift swap not found');
    }

    // Don't allow updates to approved or rejected swaps
    if (swap.status === ShiftSwapStatus.APPROVED || swap.status === ShiftSwapStatus.REJECTED) {
      throw new Error('Cannot update approved or rejected shift swap');
    }

    Object.assign(swap, updateData);
    const updatedSwap = await this.shiftSwapRepository.save(swap);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'ShiftSwap',
      entityType: 'ShiftSwap',
      entityId: swapId,
      action: 'UPDATE',
      details: updateData,
      userId: 'system'
    });

    return updatedSwap;
  }

  async deleteShiftSwap(swapId: string): Promise<void> {
    const swap = await this.getShiftSwapById(swapId);
    if (!swap) {
      throw new Error('Shift swap not found');
    }

    // Don't allow deletion of approved swaps
    if (swap.status === ShiftSwapStatus.APPROVED) {
      throw new Error('Cannot delete approved shift swap');
    }

    await this.shiftSwapRepository.remove(swap);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'ShiftSwap',
      entityType: 'ShiftSwap',
      entityId: swapId,
      action: 'DELETE',
      details: {
        requesterId: swap.requesterId,
        offeredShiftId: swap.offeredShiftId,
        desiredShiftId: swap.desiredShiftId
      },
      userId: 'system'
    });
  }

  // Shift Swap Acceptance
  async acceptShiftSwap(swapId: string, acceptanceData: ShiftSwapAcceptanceData): Promise<ShiftSwap> {
    const swap = await this.getShiftSwapById(swapId);
    if (!swap) {
      throw new Error('Shift swap not found');
    }

    if (swap.status !== ShiftSwapStatus.PENDING) {
      throw new Error('Shift swap is not pending acceptance');
    }

    swap.accepterId = acceptanceData.accepterId;
    swap.status = acceptanceData.accepted ? ShiftSwapStatus.ACCEPTED : ShiftSwapStatus.REJECTED;
    
    if (acceptanceData.notes) {
      swap.notes = acceptanceData.notes;
    }

    const updatedSwap = await this.shiftSwapRepository.save(swap);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'ShiftSwap',
      entityType: 'ShiftSwap',
      entityId: swapId,
      action: acceptanceData.accepted ? 'ACCEPT' : 'REJECT',
      details: {
        accepterId: acceptanceData.accepterId,
        accepted: acceptanceData.accepted,
        notes: acceptanceData.notes
      },
      userId: 'system'
    });

    // Send notification to requester
    await this.notificationService.sendNotification({
      message: `Shift Swap ${acceptanceData.accepted ? 'Accepted' : 'Rejected'}`,
      type: acceptanceData.accepted ? 'shift_swap_accepted' : 'shift_swap_rejected',
      recipients: [swap.requesterId],
      data: {
        offeredShiftId: swap.offeredShiftId,
        desiredShiftId: swap.desiredShiftId,
        accepterName: swap.accepter?.getFullName(),
        notes: acceptanceData.notes
      }
    });

    return updatedSwap;
  }

  // Shift Swap Approval
  async approveShiftSwap(swapId: string, approvalData: ShiftSwapApprovalData): Promise<ShiftSwap> {
    const swap = await this.getShiftSwapById(swapId);
    if (!swap) {
      throw new Error('Shift swap not found');
    }

    if (swap.status !== ShiftSwapStatus.ACCEPTED) {
      throw new Error('Shift swap must be accepted before approval');
    }

    swap.approverId = approvalData.approverId;
    swap.approvalDate = new Date();
    swap.status = approvalData.approved ? ShiftSwapStatus.APPROVED : ShiftSwapStatus.REJECTED;
    
    if (!approvalData.approved && approvalData.rejectionReason) {
      swap.rejectionReason = approvalData.rejectionReason;
    }

    if (approvalData.notes) {
      swap.notes = approvalData.notes;
    }

    const updatedSwap = await this.shiftSwapRepository.save(swap);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'ShiftSwap',
      entityType: 'ShiftSwap',
      entityId: swapId,
      action: approvalData.approved ? 'APPROVE' : 'REJECT',
      details: {
        approverId: approvalData.approverId,
        approved: approvalData.approved,
        rejectionReason: approvalData.rejectionReason,
        notes: approvalData.notes
      },
      userId: 'system'
    });

    // Send notification to both parties
    await this.notificationService.sendNotification({
      message: `Shift Swap ${approvalData.approved ? 'Approved' : 'Rejected'}`,
      type: approvalData.approved ? 'shift_swap_approved' : 'shift_swap_rejected',
      recipients: [swap.requesterId, swap.accepterId],
      data: {
        offeredShiftId: swap.offeredShiftId,
        desiredShiftId: swap.desiredShiftId,
        rejectionReason: swap.rejectionReason
      }
    });

    return updatedSwap;
  }

  async cancelShiftSwap(swapId: string, reason?: string): Promise<ShiftSwap> {
    const swap = await this.getShiftSwapById(swapId);
    if (!swap) {
      throw new Error('Shift swap not found');
    }

    if (swap.status === ShiftSwapStatus.APPROVED) {
      throw new Error('Cannot cancel approved shift swap');
    }

    swap.status = ShiftSwapStatus.CANCELLED;
    if (reason) {
      swap.notes = reason;
    }

    const updatedSwap = await this.shiftSwapRepository.save(swap);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'ShiftSwap',
      entityType: 'ShiftSwap',
      entityId: swapId,
      action: 'CANCEL',
      details: { reason },
      userId: 'system'
    });

    return updatedSwap;
  }

  // Shift Availability
  async getAvailableShifts(employeeId: string, dateRange?: { start: Date; end: Date }): Promise<ShiftAvailability> {
    // This would typically query a shifts table to find available shifts
    // For now, we'll return a mock structure
    const employee = await this.employeeRepository.findOne({
      where: { id: employeeId }
    });
    if (!employee) {
      throw new Error('Employee not found');
    }

    // Mock available shifts - in a real implementation, this would query the shifts table
    const availableShifts = [
      {
        shiftId: 'shift-1',
        date: new Date(),
        startTime: '08:00',
        endTime: '16:00',
        department: employee.department,
        role: 'Care Assistant'
      },
      {
        shiftId: 'shift-2',
        date: new Date(Date.now() + 24 * 60 * 60 * 1000),
        startTime: '16:00',
        endTime: '00:00',
        department: employee.department,
        role: 'Care Assistant'
      }
    ];

    return {
      employeeId,
      availableShifts
    };
  }

  // Shift Swap Analytics
  async getShiftSwapSummary(): Promise<ShiftSwapSummary> {
    const swaps = await this.getAllShiftSwaps();
    const pendingSwaps = swaps.filter(s => s.status === ShiftSwapStatus.PENDING);
    const approvedSwaps = swaps.filter(s => s.status === ShiftSwapStatus.APPROVED);
    const rejectedSwaps = swaps.filter(s => s.status === ShiftSwapStatus.REJECTED);
    const cancelledSwaps = swaps.filter(s => s.status === ShiftSwapStatus.CANCELLED);

    // Group by department
    const byDepartment = this.groupByDepartment(swaps);

    // Group by month
    const byMonth = this.groupByMonth(swaps);

    // Calculate average processing time
    const processedSwaps = swaps.filter(s => s.approvalDate);
    const averageProcessingTime = processedSwaps.length > 0
      ? processedSwaps.reduce((sum, s) => {
          const processingTime = s.approvalDate!.getTime() - s.requestDate.getTime();
          return sum + (processingTime / (1000 * 60 * 60)); // Convert to hours
        }, 0) / processedSwaps.length
      : 0;

    // Calculate approval rate
    const totalProcessed = approvedSwaps.length + rejectedSwaps.length;
    const approvalRate = totalProcessed > 0 ? (approvedSwaps.length / totalProcessed) * 100 : 0;

    return {
      totalSwaps: swaps.length,
      pendingSwaps: pendingSwaps.length,
      approvedSwaps: approvedSwaps.length,
      rejectedSwaps: rejectedSwaps.length,
      cancelledSwaps: cancelledSwaps.length,
      byDepartment,
      byMonth,
      averageProcessingTime,
      approvalRate
    };
  }

  private groupByDepartment(swaps: ShiftSwap[]): any[] {
    const grouped = new Map<string, { count: number; approved: number; rejected: number }>();

    swaps.forEach(swap => {
      const department = swap.requester.department;
      if (!grouped.has(department)) {
        grouped.set(department, { count: 0, approved: 0, rejected: 0 });
      }
      
      const stats = grouped.get(department)!;
      stats.count++;
      if (swap.status === ShiftSwapStatus.APPROVED) {
        stats.approved++;
      } else if (swap.status === ShiftSwapStatus.REJECTED) {
        stats.rejected++;
      }
    });

    return Array.from(grouped.entries()).map(([department, stats]) => ({
      department,
      ...stats
    }));
  }

  private groupByMonth(swaps: ShiftSwap[]): any[] {
    const grouped = new Map<string, { count: number; approved: number; rejected: number }>();

    swaps.forEach(swap => {
      const month = swap.requestDate.toISOString().substring(0, 7); // YYYY-MM format
      if (!grouped.has(month)) {
        grouped.set(month, { count: 0, approved: 0, rejected: 0 });
      }
      
      const stats = grouped.get(month)!;
      stats.count++;
      if (swap.status === ShiftSwapStatus.APPROVED) {
        stats.approved++;
      } else if (swap.status === ShiftSwapStatus.REJECTED) {
        stats.rejected++;
      }
    });

    return Array.from(grouped.entries()).map(([month, stats]) => ({
      month,
      ...stats
    }));
  }

  // Reporting
  async getShiftSwapsByDepartment(department: string): Promise<ShiftSwap[]> {
    return await this.searchShiftSwaps({ department });
  }

  async getPendingShiftSwaps(): Promise<ShiftSwap[]> {
    return await this.searchShiftSwaps({ status: ShiftSwapStatus.PENDING });
  }

  async getApprovedShiftSwaps(): Promise<ShiftSwap[]> {
    return await this.searchShiftSwaps({ status: ShiftSwapStatus.APPROVED });
  }

  async getShiftSwapsByDateRange(startDate: Date, endDate: Date): Promise<ShiftSwap[]> {
    return await this.searchShiftSwaps({ dateRange: { start: startDate, end: endDate } });
  }

  async exportShiftSwaps(criteria: ShiftSwapSearchCriteria): Promise<ShiftSwap[]> {
    return await this.searchShiftSwaps(criteria);
  }

  // Bulk Operations
  async bulkApproveShiftSwaps(swapIds: string[], approvalData: ShiftSwapApprovalData): Promise<number> {
    let approvedCount = 0;

    for (const swapId of swapIds) {
      try {
        await this.approveShiftSwap(swapId, approvalData);
        approvedCount++;
      } catch (error) {
        console.error(`Failed to approve shift swap ${swapId}:`, error);
      }
    }

    return approvedCount;
  }

  async bulkCancelShiftSwaps(swapIds: string[], reason?: string): Promise<number> {
    let cancelledCount = 0;

    for (const swapId of swapIds) {
      try {
        await this.cancelShiftSwap(swapId, reason);
        cancelledCount++;
      } catch (error) {
        console.error(`Failed to cancel shift swap ${swapId}:`, error);
      }
    }

    return cancelledCount;
  }

  // Conflict Detection
  async detectConflicts(offeredShiftId: string, desiredShiftId: string): Promise<{
    hasConflicts: boolean;
    conflicts: string[];
    recommendations: string[];
  }> {
    // This would typically check for scheduling conflicts, skill requirements, etc.
    // For now, we'll return a mock structure
    const conflicts = [];
    const recommendations = [];

    // Mock conflict detection logic
    if (offeredShiftId === desiredShiftId) {
      conflicts.push('Cannot swap shift with itself');
      recommendations.push('Select different shifts for the swap');
    }

    return {
      hasConflicts: conflicts.length > 0,
      conflicts,
      recommendations
    };
  }

  // Shift Swap Matching
  async findMatchingSwaps(employeeId: string): Promise<ShiftSwap[]> {
    // This would typically find shift swaps that match the employee's skills, availability, etc.
    // For now, we'll return swaps where the employee could potentially accept
    return await this.shiftSwapRepository
      .createQueryBuilder('swap')
      .leftJoinAndSelect('swap.requester', 'requester')
      .where('swap.status = :status', { status: ShiftSwapStatus.PENDING })
      .andWhere('swap.requesterId != :employeeId', { employeeId })
      .orderBy('swap.requestDate', 'DESC')
      .getMany();
  }

  // Shift Swap History
  async getShiftSwapHistory(employeeId: string): Promise<ShiftSwap[]> {
    return await this.shiftSwapRepository
      .createQueryBuilder('swap')
      .leftJoinAndSelect('swap.requester', 'requester')
      .leftJoinAndSelect('swap.accepter', 'accepter')
      .where('(swap.requesterId = :employeeId OR swap.accepterId = :employeeId)', { employeeId })
      .orderBy('swap.requestDate', 'DESC')
      .getMany();
  }
}