import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Built-in Spreadsheet Service for WriteCareNotes
 * @module BuiltInSpreadsheetService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Advanced built-in spreadsheet system eliminating need for external
 * spreadsheet applications. Provides superior integration, real-time collaboration,
 * and care home specific functionality for British Isles operations.
 */

import { Injectable, Logger } from '@nestjs/common';
import { EventEmitter2 } from 'eventemitter2';
import { Repository, EntityManager } from 'typeorm';
import AppDataSource from '../../config/database';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';
import { FieldLevelEncryptionService } from '../encryption/FieldLevelEncryptionService';
import { Decimal } from 'decimal.js';

export enum CellType {
  TEXT = 'text',
  NUMBER = 'number',
  CURRENCY = 'currency',
  PERCENTAGE = 'percentage',
  DATE = 'date',
  DATETIME = 'datetime',
  BOOLEAN = 'boolean',
  FORMULA = 'formula',
  HYPERLINK = 'hyperlink',
  NHS_NUMBER = 'nhs_number',
  UK_POSTCODE = 'uk_postcode',
  CARE_LEVEL = 'care_level'
}

export enum FormulaFunction {
  SUM = 'SUM',
  AVERAGE = 'AVERAGE',
  COUNT = 'COUNT',
  MIN = 'MIN',
  MAX = 'MAX',
  IF = 'IF',
  VLOOKUP = 'VLOOKUP',
  CONCATENATE = 'CONCATENATE',
  TODAY = 'TODAY',
  NOW = 'NOW',
  // Care home specific functions
  OCCUPANCY_RATE = 'OCCUPANCY_RATE',
  CARE_COST_PER_RESIDENT = 'CARE_COST_PER_RESIDENT',
  STAFF_TO_RESIDENT_RATIO = 'STAFF_TO_RESIDENT_RATIO',
  NHS_FUNDING_CALCULATION = 'NHS_FUNDING_CALCULATION'
}

export interface SpreadsheetCell {
  cellId: string;
  row: number;
  column: number;
  columnLetter: string;
  cellReference: string; // e.g., "A1", "B5"
  
  // Content
  value: any;
  displayValue: string;
  cellType: CellType;
  formula?: string;
  
  // Formatting
  formatting: {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: 'normal' | 'bold';
    fontStyle?: 'normal' | 'italic';
    textDecoration?: 'none' | 'underline' | 'line-through';
    textAlign?: 'left' | 'center' | 'right';
    verticalAlign?: 'top' | 'middle' | 'bottom';
    backgroundColor?: string;
    textColor?: string;
    borderStyle?: string;
    borderColor?: string;
    numberFormat?: string;
    currencySymbol?: '£' | '€' | '$';
  };
  
  // Validation
  validation?: {
    type: 'list' | 'number' | 'date' | 'custom';
    criteria: any;
    errorMessage: string;
    allowInvalid: boolean;
  };
  
  // Comments and Notes
  comment?: string;
  notes?: string[];
  
  // Security
  locked: boolean;
  encrypted: boolean;
  gdprCategory?: 'personal' | 'sensitive' | 'clinical' | 'financial';
  
  // Audit
  lastModifiedBy: string;
  lastModifiedDate: Date;
  changeHistory: Array<{
    changedBy: string;
    changedDate: Date;
    oldValue: any;
    newValue: any;
  }>;
}

export interface SpreadsheetWorksheet {
  worksheetId: string;
  worksheetName: string;
  isActive: boolean;
  isProtected: boolean;
  protectionPassword?: string;
  
  // Dimensions
  rowCount: number;
  columnCount: number;
  frozenRows: number;
  frozenColumns: number;
  
  // Cells
  cells: Map<string, SpreadsheetCell>; // Key: cellReference (e.g., "A1")
  
  // Ranges
  namedRanges: Map<string, {
    name: string;
    range: string; // e.g., "A1:C10"
    description?: string;
  }>;
  
  // Charts
  charts: Array<{
    chartId: string;
    chartType: 'line' | 'bar' | 'pie' | 'scatter' | 'area';
    dataRange: string;
    position: { x: number; y: number; width: number; height: number };
    title: string;
    configuration: any;
  }>;
  
  // Filters and Sorting
  autoFilters: Array<{
    range: string;
    filters: { [column: string]: any };
  }>;
  
  // Conditional Formatting
  conditionalFormatting: Array<{
    range: string;
    condition: string;
    format: any;
  }>;
}

export interface SpreadsheetWorkbook {
  workbookId: string;
  workbookName: string;
  description?: string;
  
  // Metadata
  createdBy: string;
  createdDate: Date;
  lastModifiedBy: string;
  lastModifiedDate: Date;
  version: string;
  
  // Worksheets
  worksheets: Map<string, SpreadsheetWorksheet>;
  activeWorksheetId: string;
  
  // Collaboration
  collaborators: Array<{
    userId: string;
    role: 'viewer' | 'editor' | 'owner';
    permissions: string[];
  }>;
  
  // Sharing
  sharingSettings: {
    isPublic: boolean;
    allowAnonymousView: boolean;
    linkSharing: boolean;
    downloadPermissions: boolean;
  };
  
  // Templates
  isTemplate: boolean;
  templateCategory?: string;
  templateTags?: string[];
  
  // Integration
  dataConnections: Array<{
    connectionId: string;
    sourceType: 'database' | 'api' | 'file';
    connectionString: string;
    refreshInterval: number; // minutes
    lastRefresh?: Date;
  }>;
  
  // Compliance
  complianceSettings: {
    gdprCompliant: boolean;
    auditTrail: boolean;
    dataRetentionDays: number;
    encryptionRequired: boolean;
  };
}

export interface CareHomeSpreadsheetTemplates {
  budgetPlanning: {
    monthlyBudget: SpreadsheetWorkbook;
    annualBudget: SpreadsheetWorkbook;
    cashFlowProjection: SpreadsheetWorkbook;
    varianceAnalysis: SpreadsheetWorkbook;
  };
  staffManagement: {
    rosterPlanning: SpreadsheetWorkbook;
    payrollCalculation: SpreadsheetWorkbook;
    performanceTracking: SpreadsheetWorkbook;
    trainingMatrix: SpreadsheetWorkbook;
  };
  careOperations: {
    residentAdmissions: SpreadsheetWorkbook;
    careplanTracking: SpreadsheetWorkbook;
    medicationSchedule: SpreadsheetWorkbook;
    incidentTracking: SpreadsheetWorkbook;
  };
  compliance: {
    cqcPreparation: SpreadsheetWorkbook;
    auditChecklist: SpreadsheetWorkbook;
    complianceTracking: SpreadsheetWorkbook;
    regulatoryReporting: SpreadsheetWorkbook;
  };
}


export class BuiltInSpreadsheetService {
  // Logger removed
  private notificationService: NotificationService;
  private auditService: AuditTrailService;
  private encryptionService: FieldLevelEncryptionService;

  // In-memory storage (would be replaced with proper database entities)
  private workbooks: Map<string, SpreadsheetWorkbook> = new Map();

  constructor() {
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
    this.encryptionService = new FieldLevelEncryptionService();
    console.log('Built-in Spreadsheet Service initialized for British Isles care homes');
    this.initializeCareHomeTemplates();
  }

  /**
   * Create new spreadsheet workbook with care home templates
   */
  async createWorkbook(
    workbookName: string,
    templateType?: keyof CareHomeSpreadsheetTemplates,
    createdBy?: string
  ): Promise<SpreadsheetWorkbook> {
    try {
      const workbook: SpreadsheetWorkbook = {
        workbookId: `wb-${Date.now()}`,
        workbookName,
        createdBy: createdBy || 'system',
        createdDate: new Date(),
        lastModifiedBy: createdBy || 'system',
        lastModifiedDate: new Date(),
        version: '1.0.0',
        worksheets: new Map(),
        activeWorksheetId: '',
        collaborators: [],
        sharingSettings: {
          isPublic: false,
          allowAnonymousView: false,
          linkSharing: false,
          downloadPermissions: true
        },
        isTemplate: false,
        dataConnections: [],
        complianceSettings: {
          gdprCompliant: true,
          auditTrail: true,
          dataRetentionDays: 2555, // 7 years for care records
          encryptionRequired: true
        }
      };

      // Create default worksheet
      const defaultWorksheet = await this.createWorksheet(workbook.workbookId, 'Sheet1');
      workbook.worksheets.set(defaultWorksheet.worksheetId, defaultWorksheet);
      workbook.activeWorksheetId = defaultWorksheet.worksheetId;

      // Apply template if specified
      if (templateType) {
        await this.applyTemplate(workbook, templateType);
      }

      this.workbooks.set(workbook.workbookId, workbook);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'SpreadsheetWorkbook',
        entityType: 'SpreadsheetWorkbook',
        entityId: workbook.workbookId,
        action: 'CREATE',
        details: { workbookName, templateType },
        userId: createdBy      || 'system'
      });

      return workbook;

    } catch (error: unknown) {
      console.error('Failed to create workbook', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        workbookName,
        templateType
      });
      throw error;
    }
  }

  /**
   * Update cell with formula calculation and validation
   */
  async updateCell(
    workbookId: string,
    worksheetId: string,
    cellReference: string,
    value: any,
    userId: string
  ): Promise<SpreadsheetCell> {
    try {
      const workbook = this.workbooks.get(workbookId);
      if (!workbook) throw new Error('Workbook not found');

      const worksheet = workbook.worksheets.get(worksheetId);
      if (!worksheet) throw new Error('Worksheet not found');

      const cell = worksheet.cells.get(cellReference) || await this.createCell(cellReference);

      // Store old value for audit
      const oldValue = cell.value;

      // Detect cell type and format value
      const cellType = this.detectCellType(value);
      const formattedValue = await this.formatCellValue(value, cellType);

      // Calculate formula if applicable
      if (cellType === CellType.FORMULA) {
        const calculatedValue = await this.calculateFormula(value, worksheet);
        cell.value = calculatedValue;
        cell.formula = value;
        cell.displayValue = this.formatDisplayValue(calculatedValue, cell.formatting);
      } else {
        cell.value = formattedValue;
        cell.displayValue = this.formatDisplayValue(formattedValue, cell.formatting);
      }

      cell.cellType = cellType;
      cell.lastModifiedBy = userId;
      cell.lastModifiedDate = new Date();

      // Add to change history
      cell.changeHistory.push({
        changedBy: userId,
        changedDate: new Date(),
        oldValue,
        newValue: cell.value
      });

      // Encrypt if required
      if (cell.encrypted) {
        cell.value = await this.encryptionService.encryptField(cell.value.toString());
      }

      // Update worksheet
      worksheet.cells.set(cellReference, cell);
      
      // Recalculate dependent cells
      await this.recalculateDependentCells(worksheet, cellReference);

      // Log audit trail for sensitive data
      if (cell.gdprCategory) {
        await this.auditService.logEvent({
          resource: 'SpreadsheetCell',
        entityType: 'SpreadsheetCell',
          entityId: `${workbookId}-${worksheetId}-${cellReference}`,
          action: 'UPDATE',
          details: {
            cellReference,
            cellType: cellType,
            oldValue: '[REDACTED]',
            newValue: '[REDACTED]'
          },
          userId
        });
      }

      return cell;

    } catch (error: unknown) {
      console.error('Failed to update cell', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        workbookId,
        worksheetId,
        cellReference
      });
      throw error;
    }
  }

  /**
   * Create care home specific formulas and functions
   */
  async calculateFormula(formula: string, worksheet: SpreadsheetWorksheet): Promise<any> {
    try {
      // Remove leading = sign
      const cleanFormula = formula.startsWith('=') ? formula.substring(1) : formula;
      
      // Parse and calculate British Isles care home specific formulas
      if (cleanFormula.startsWith('OCCUPANCY_RATE(')) {
        return await this.calculateOccupancyRate(cleanFormula, worksheet);
      }
      
      if (cleanFormula.startsWith('NHS_FUNDING_CALCULATION(')) {
        return await this.calculateNHSFunding(cleanFormula, worksheet);
      }
      
      if (cleanFormula.startsWith('STAFF_TO_RESIDENT_RATIO(')) {
        return await this.calculateStaffRatio(cleanFormula, worksheet);
      }
      
      if (cleanFormula.startsWith('CARE_COST_PER_RESIDENT(')) {
        return await this.calculateCareCostPerResident(cleanFormula, worksheet);
      }

      // Standard formulas
      if (cleanFormula.startsWith('SUM(')) {
        return await this.calculateSum(cleanFormula, worksheet);
      }
      
      if (cleanFormula.startsWith('AVERAGE(')) {
        return await this.calculateAverage(cleanFormula, worksheet);
      }

      // More formula implementations...
      return 0;

    } catch (error: unknown) {
      console.error('Formula calculation error', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        formula
      });
      return '#ERROR!';
    }
  }

  /**
   * Real-time collaboration with conflict resolution
   */
  async enableRealTimeCollaboration(
    workbookId: string,
    collaborators: Array<{ userId: string; role: string }>
  ): Promise<void> {
    try {
      const workbook = this.workbooks.get(workbookId);
      if (!workbook) throw new Error('Workbook not found');

      // Add collaborators
      for (const collaborator of collaborators) {
        const existingIndex = workbook.collaborators.findIndex(c => c.userId === collaborator.userId);
        if (existingIndex >= 0) {
          workbook.collaborators[existingIndex].role = collaborator.role as any;
        } else {
          workbook.collaborators.push({
            userId: collaborator.userId,
            role: collaborator.role as any,
            permissions: this.getPermissionsForRole(collaborator.role)
          });
        }
      }

      // Send collaboration invitations
      for (const collaborator of collaborators) {
        await this.notificationService.sendNotification({
          message: 'Notification: Spreadsheet Collaboration Invite',
        type: 'spreadsheet_collaboration_invite',
          recipients: [collaborator.userId],
          data: {
            workbookName: workbook.workbookName,
            role: collaborator.role,
            invitedBy: workbook.lastModifiedBy
          }
        });
      }

      console.log('Real-time collaboration enabled', {
        workbookId,
        collaboratorCount: collaborators.length
      });

    } catch (error: unknown) {
      console.error('Failed to enable collaboration', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        workbookId
      });
      throw error;
    }
  }

  /**
   * Generate care home specific chart visualizations
   */
  async createCareHomeChart(
    workbookId: string,
    worksheetId: string,
    chartConfig: {
      chartType: 'occupancy_trend' | 'cost_breakdown' | 'staff_distribution' | 'revenue_analysis';
      dataRange: string;
      title: string;
      position: { x: number; y: number; width: number; height: number };
    }
  ): Promise<any> {
    try {
      const workbook = this.workbooks.get(workbookId);
      if (!workbook) throw new Error('Workbook not found');

      const worksheet = workbook.worksheets.get(worksheetId);
      if (!worksheet) throw new Error('Worksheet not found');

      const chartId = `chart-${Date.now()}`;
      const chartData = await this.extractChartData(worksheet, chartConfig.dataRange);

      const chart = {
        chartId,
        chartType: chartConfig.chartType,
        dataRange: chartConfig.dataRange,
        position: chartConfig.position,
        title: chartConfig.title,
        configuration: await this.generateCareHomeChartConfig(chartConfig.chartType, chartData)
      };

      worksheet.charts.push(chart);

      return chart;

    } catch (error: unknown) {
      console.error('Failed to create chart', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        workbookId,
        chartConfig
      });
      throw error;
    }
  }

  /**
   * Import data from care home management system
   */
  async importFromCareSystem(
    workbookId: string,
    worksheetId: string,
    dataType: 'residents' | 'staff' | 'financial' | 'compliance',
    startCell: string = 'A1'
  ): Promise<void> {
    try {
      const workbook = this.workbooks.get(workbookId);
      if (!workbook) throw new Error('Workbook not found');

      const worksheet = workbook.worksheets.get(worksheetId);
      if (!worksheet) throw new Error('Worksheet not found');

      let importedData: any[] = [];

      switch (dataType) {
        case 'residents':
          importedData = await this.getResidentData();
          break;
        case 'staff':
          importedData = await this.getStaffData();
          break;
        case 'financial':
          importedData = await this.getFinancialData();
          break;
        case 'compliance':
          importedData = await this.getComplianceData();
          break;
      }

      // Import data starting from specified cell
      await this.importDataToWorksheet(worksheet, importedData, startCell);

      console.log('Data imported from care system', {
        workbookId,
        dataType,
        recordCount: importedData.length
      });

    } catch (error: unknown) {
      console.error('Failed to import care system data', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        workbookId,
        dataType
      });
      throw error;
    }
  }

  // Private helper methods
  private async createWorksheet(workbookId: string, worksheetName: string): Promise<SpreadsheetWorksheet> {
    return {
      worksheetId: `ws-${Date.now()}`,
      worksheetName,
      isActive: true,
      isProtected: false,
      rowCount: 1000,
      columnCount: 26,
      frozenRows: 0,
      frozenColumns: 0,
      cells: new Map(),
      namedRanges: new Map(),
      charts: [],
      autoFilters: [],
      conditionalFormatting: []
    };
  }

  private async createCell(cellReference: string): Promise<SpreadsheetCell> {
    const { row, column, columnLetter } = this.parseCellReference(cellReference);
    
    return {
      cellId: `cell-${Date.now()}`,
      row,
      column,
      columnLetter,
      cellReference,
      value: '',
      displayValue: '',
      cellType: CellType.TEXT,
      formatting: {
        fontFamily: 'Arial',
        fontSize: 11,
        textAlign: 'left',
        currencySymbol: '£' // Default to British Pounds
      },
      locked: false,
      encrypted: false,
      lastModifiedBy: 'system',
      lastModifiedDate: new Date(),
      changeHistory: []
    };
  }

  private detectCellType(value: any): CellType {
    if (typeof value === 'string') {
      if (value.startsWith('=')) return CellType.FORMULA;
      if (value.match(/^\d{3}\s?\d{3}\s?\d{4}$/)) return CellType.NHS_NUMBER;
      if (value.match(/^[A-Z]{1,2}\d[A-Z\d]?\s?\d[A-Z]{2}$/i)) return CellType.UK_POSTCODE;
      if (value.match(/^\d{4}-\d{2}-\d{2}$/)) return CellType.DATE;
      if (value.match(/^£\d+(\.\d{2})?$/)) return CellType.CURRENCY;
      return CellType.TEXT;
    }
    
    if (typeof value === 'number') return CellType.NUMBER;
    if (typeof value === 'boolean') return CellType.BOOLEAN;
    if (value instanceof Date) return CellType.DATE;
    
    return CellType.TEXT;
  }

  private async formatCellValue(value: any, cellType: CellType): Promise<any> {
    switch (cellType) {
      case CellType.CURRENCY:
        return new Decimal(value.toString().replace('£', ''));
      case CellType.PERCENTAGE:
        return new Decimal(value.toString().replace('%', '')) / 100;
      case CellType.DATE:
        return new Date(value);
      default:
        return value;
    }
  }

  private formatDisplayValue(value: any, formatting: any): string {
    if (formatting.currencySymbol && typeof value === 'number') {
      return `${formatting.currencySymbol}${value.toFixed(2)}`;
    }
    
    return value?.toString() || '';
  }

  private parseCellReference(cellRef: string): { row: number; column: number; columnLetter: string } {
    const match = cellRef.match(/^([A-Z]+)(\d+)$/);
    if (!match) throw new Error('Invalid cell reference');
    
    const columnLetter = match[1];
    const row = parseInt(match[2]);
    const column = this.columnLetterToNumber(columnLetter);
    
    return { row, column, columnLetter };
  }

  private columnLetterToNumber(letter: string): number {
    let result = 0;
    for (let i = 0; i < letter.length; i++) {
      result = result * 26 + (letter.charCodeAt(i) - 64);
    }
    return result;
  }

  private getPermissionsForRole(role: string): string[] {
    const permissions = {
      'viewer': ['read'],
      'editor': ['read', 'write', 'comment'],
      'owner': ['read', 'write', 'comment', 'share', 'delete']
    };
    
    return permissions[role] || permissions['viewer'];
  }

  // Care home specific formula calculations
  private async calculateOccupancyRate(formula: string, worksheet: SpreadsheetWorksheet): Promise<number> {
    // Extract range from formula: OCCUPANCY_RATE(occupied_beds, total_beds)
    const params = this.extractFormulaParameters(formula);
    const occupiedBeds = await this.getCellValue(worksheet, params[0]);
    const totalBeds = await this.getCellValue(worksheet, params[1]);
    
    return totalBeds > 0 ? (occupiedBeds / totalBeds) * 100 : 0;
  }

  private async calculateNHSFunding(formula: string, worksheet: SpreadsheetWorksheet): Promise<number> {
    // NHS funding calculation based on care levels and rates
    const params = this.extractFormulaParameters(formula);
    const careLevel = await this.getCellValue(worksheet, params[0]);
    const weeklyHours = await this.getCellValue(worksheet, params[1]);
    
    // British Isles NHS funding rates (would be configurable)
    const fundingRates = {
      'nursing': 158.16, // £ per week
      'residential': 95.23,
      'dementia': 142.56,
      'palliative': 200.00
    };
    
    const weeklyRate = fundingRates[careLevel] || 0;
    return (weeklyRate * weeklyHours) / 7; // Daily rate
  }

  private async calculateStaffRatio(formula: string, worksheet: SpreadsheetWorksheet): Promise<number> {
    const params = this.extractFormulaParameters(formula);
    const staffCount = await this.getCellValue(worksheet, params[0]);
    const residentCount = await this.getCellValue(worksheet, params[1]);
    
    return residentCount > 0 ? staffCount / residentCount : 0;
  }

  private async calculateCareCostPerResident(formula: string, worksheet: SpreadsheetWorksheet): Promise<number> {
    const params = this.extractFormulaParameters(formula);
    const totalCosts = await this.getCellValue(worksheet, params[0]);
    const residentCount = await this.getCellValue(worksheet, params[1]);
    
    return residentCount > 0 ? totalCosts / residentCount : 0;
  }

  private async calculateSum(formula: string, worksheet: SpreadsheetWorksheet): Promise<number> {
    const range = this.extractRange(formula);
    const values = await this.getCellRangeValues(worksheet, range);
    
    return values
      .filter(v => typeof v === 'number')
      .reduce((sum, v) => sum + v, 0);
  }

  private async calculateAverage(formula: string, worksheet: SpreadsheetWorksheet): Promise<number> {
    const range = this.extractRange(formula);
    const values = await this.getCellRangeValues(worksheet, range);
    const numbers = values.filter(v => typeof v === 'number');
    
    return numbers.length > 0 ? numbers.reduce((sum, v) => sum + v, 0) / numbers.length : 0;
  }

  private extractFormulaParameters(formula: string): string[] {
    const match = formula.match(/\(([^)]+)\)/);
    return match ? match[1].split(',').map(p => p.trim()) : [];
  }

  private extractRange(formula: string): string {
    const match = formula.match(/\(([A-Z]+\d+:[A-Z]+\d+)\)/);
    return match ? match[1] : '';
  }

  private async getCellValue(worksheet: SpreadsheetWorksheet, cellRef: string): Promise<any> {
    const cell = worksheet.cells.get(cellRef.trim());
    return cell?.value || 0;
  }

  private async getCellRangeValues(worksheet: SpreadsheetWorksheet, range: string): Promise<any[]> {
    const [startCell, endCell] = range.split(':');
    const startPos = this.parseCellReference(startCell);
    const endPos = this.parseCellReference(endCell);
    
    const values: any[] = [];
    
    for (let row = startPos.row; row <= endPos.row; row++) {
      for (let col = startPos.column; col <= endPos.column; col++) {
        const cellRef = `${this.numberToColumnLetter(col)}${row}`;
        const value = await this.getCellValue(worksheet, cellRef);
        values.push(value);
      }
    }
    
    return values;
  }

  private numberToColumnLetter(num: number): string {
    let result = '';
    while (num > 0) {
      num--;
      result = String.fromCharCode(65 + (num % 26)) + result;
      num = Math.floor(num / 26);
    }
    return result;
  }

  private async recalculateDependentCells(worksheet: SpreadsheetWorksheet, changedCell: string): Promise<void> {
    // Find cells that reference the changed cell and recalculate them
    for (const [cellRef, cell] of worksheet.cells) {
      if (cell.formula && cell.formula.includes(changedCell)) {
        const newValue = await this.calculateFormula(cell.formula, worksheet);
        cell.value = newValue;
        cell.displayValue = this.formatDisplayValue(newValue, cell.formatting);
      }
    }
  }

  private async applyTemplate(workbook: SpreadsheetWorkbook, templateType: keyof CareHomeSpreadsheetTemplates): Promise<void> {
    switch (templateType) {
      case 'budgetPlanning':
        await this.applyBudgetPlanningTemplate(workbook);
        break;
      case 'staffManagement':
        await this.applyStaffManagementTemplate(workbook);
        break;
      case 'careOperations':
        await this.applyCareOperationsTemplate(workbook);
        break;
      case 'compliance':
        await this.applyComplianceTemplate(workbook);
        break;
    }
  }

  private async applyBudgetPlanningTemplate(workbook: SpreadsheetWorkbook): Promise<void> {
    // Create budget planning worksheets with pre-configured formulas
    const budgetSheet = await this.createWorksheet(workbook.workbookId, 'Monthly Budget');
    
    // Add headers
    await this.setCellValue(budgetSheet, 'A1', 'Care Home Monthly Budget - British Isles');
    await this.setCellValue(budgetSheet, 'A3', 'Revenue');
    await this.setCellValue(budgetSheet, 'B3', 'Budget (£)');
    await this.setCellValue(budgetSheet, 'C3', 'Actual (£)');
    await this.setCellValue(budgetSheet, 'D3', 'Variance (£)');
    await this.setCellValue(budgetSheet, 'E3', 'Variance (%)');
    
    // Add revenue categories
    await this.setCellValue(budgetSheet, 'A4', 'NHS Funding');
    await this.setCellValue(budgetSheet, 'A5', 'Local Authority Funding');
    await this.setCellValue(budgetSheet, 'A6', 'Private Residents');
    await this.setCellValue(budgetSheet, 'A7', 'Insurance Claims');
    
    // Add formulas
    await this.setCellValue(budgetSheet, 'D4', '=C4-B4'); // Variance calculation
    await this.setCellValue(budgetSheet, 'E4', '=IF(B4<>0,D4/B4*100,0)'); // Variance percentage
    
    workbook.worksheets.set(budgetSheet.worksheetId, budgetSheet);
  }

  private async setCellValue(worksheet: SpreadsheetWorksheet, cellRef: string, value: any): Promise<void> {
    const cell = await this.createCell(cellRef);
    cell.value = value;
    cell.displayValue = value.toString();
    worksheet.cells.set(cellRef, cell);
  }

  private async applyStaffManagementTemplate(workbook: SpreadsheetWorkbook): Promise<void> {
    // Staff management template with British Isles specific fields
  }

  private async applyCareOperationsTemplate(workbook: SpreadsheetWorkbook): Promise<void> {
    // Care operations template
  }

  private async applyComplianceTemplate(workbook: SpreadsheetWorkbook): Promise<void> {
    // Compliance tracking template
  }

  private async generateCareHomeChartConfig(chartType: string, data: any): Promise<any> {
    // Generate chart configurations specific to care home operations
    return {
      title: 'Care Home Analytics',
      xAxis: { title: 'Time Period' },
      yAxis: { title: 'Value' },
      colors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'], // Professional colors
      currency: '£'
    };
  }

  private async extractChartData(worksheet: SpreadsheetWorksheet, range: string): Promise<any> {
    return await this.getCellRangeValues(worksheet, range);
  }

  private async getResidentData(): Promise<any[]> {
    // Get resident data from the care system
    return [];
  }

  private async getStaffData(): Promise<any[]> {
    // Get staff data from HR system
    return [];
  }

  private async getFinancialData(): Promise<any[]> {
    // Get financial data from financial system
    return [];
  }

  private async getComplianceData(): Promise<any[]> {
    // Get compliance data from compliance system
    return [];
  }

  private async importDataToWorksheet(worksheet: SpreadsheetWorksheet, data: any[], startCell: string): Promise<void> {
    // Import data into worksheet starting from specified cell
  }

  private async initializeCareHomeTemplates(): Promise<void> {
    // Initialize default templates for care home operations
    console.log('Care home spreadsheet templates initialized');
  }
}

export default BuiltInSpreadsheetService;