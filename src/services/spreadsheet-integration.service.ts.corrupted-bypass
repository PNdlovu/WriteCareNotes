import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import * as XLSX from 'xlsx';
import { AuditTrailService } from './audit/AuditTrailService';
import { logger } from '../utils/logger';

export interface SpreadsheetTemplate {
  id: string;
  name: string;
  description: string;
  category: 'care_plans' | 'medications' | 'assessments' | 'reports' | 'schedules' | 'inventory' | 'financial' | 'compliance';
  fileType: 'xlsx' | 'xls' | 'csv' | 'ods';
  templateData: any; // Excel/CSV data structure
  fields: SpreadsheetField[];
  validationRules: ValidationRule[];
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface SpreadsheetField {
  id: string;
  name: string;
  displayName: string;
  type: 'text' | 'number' | 'date' | 'boolean' | 'dropdown' | 'formula';
  required: boolean;
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
    options?: string[];
  };
  position: {
    row: number;
    column: number;
  };
  formula?: string;
}

export interface ValidationRule {
  id: string;
  fieldId: string;
  ruleType: 'required' | 'range' | 'pattern' | 'custom';
  ruleValue: any;
  errorMessage: string;
  isActive: boolean;
}

export interface SpreadsheetExport {
  id: string;
  templateId: string;
  fileName: string;
  filePath: string;
  fileSize: number;
  exportType: 'full' | 'filtered' | 'summary';
  filters?: Record<string, any>;
  dataRange?: {
    startRow: number;
    endRow: number;
    startColumn: number;
    endColumn: number;
  };
  status: 'pending' | 'processing' | 'completed' | 'failed';
  errorMessage?: string;
  createdAt: Date;
  completedAt?: Date;
}

export interface SpreadsheetImport {
  id: string;
  templateId: string;
  fileName: string;
  filePath: string;
  fileSize: number;
  importType: 'full' | 'incremental' | 'validation_only';
  status: 'pending' | 'processing' | 'completed' | 'failed';
  recordsProcessed: number;
  recordsSuccessful: number;
  recordsFailed: number;
  errorMessage?: string;
  validationResults: ValidationResult[];
  createdAt: Date;
  completedAt?: Date;
}

export interface ValidationResult {
  row: number;
  field: string;
  value: any;
  isValid: boolean;
  errorMessage?: string;
}

export interface SpreadsheetData {
  id: string;
  templateId: string;
  rowData: Record<string, any>;
  rowNumber: number;
  isValid: boolean;
  validationErrors: ValidationError[];
  createdAt: Date;
  updatedAt: Date;
}

export interface ValidationError {
  field: string;
  value: any;
  errorMessage: string;
  severity: 'error' | 'warning' | 'info';
}

export interface SpreadsheetReport {
  id: string;
  name: string;
  description: string;
  templateId: string;
  reportType: 'summary' | 'detailed' | 'analytics' | 'compliance';
  parameters: Record<string, any>;
  schedule?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly';
    time: string;
    dayOfWeek?: number;
    dayOfMonth?: number;
  };
  isActive: boolean;
  lastGenerated?: Date;
  nextGeneration?: Date;
  createdAt: Date;
  updatedAt: Date;
}

@Injectable()
export class SpreadsheetIntegrationService {
  constructor(
    @InjectRepository('SpreadsheetTemplate')
    private templateRepository: Repository<SpreadsheetTemplate>,
    @InjectRepository('SpreadsheetExport')
    private exportRepository: Repository<SpreadsheetExport>,
    @InjectRepository('SpreadsheetImport')
    private importRepository: Repository<SpreadsheetImport>,
    @InjectRepository('SpreadsheetData')
    private dataRepository: Repository<SpreadsheetData>,
    @InjectRepository('SpreadsheetReport')
    private reportRepository: Repository<SpreadsheetReport>,
    private eventEmitter: EventEmitter2,
    private auditService: AuditTrailService,
  ) {}

  /**
   * Create a new spreadsheet template
   */
  async createTemplate(templateData: Omit<SpreadsheetTemplate, 'id' | 'createdAt' | 'updatedAt'>): Promise<SpreadsheetTemplate> {
    try {
      const template: SpreadsheetTemplate = {
        id: `template_${Date.now()}`,
        ...templateData,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.templateRepository.save(template);

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Template',
        entityId: template.id,
        action: 'CREATE',
        details: {
          templateName: template.name,
          category: template.category,
          fileType: template.fileType,
          fieldCount: template.fields.length,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('spreadsheet.template.created', {
        templateId: template.id,
        templateName: template.name,
        category: template.category,
        fileType: template.fileType,
        timestamp: new Date(),
      });

      return template;
    } catch (error) {
      console.error('Error creating template:', error);
      throw new Error('Failed to create template');
    }
  }

  /**
   * Export data to spreadsheet
   */
  async exportToSpreadsheet(
    templateId: string,
    data: any[],
    exportType: 'full' | 'filtered' | 'summary' = 'full',
    filters?: Record<string, any>,
  ): Promise<SpreadsheetExport> {
    try {
      const template = await this.templateRepository.findOne({ where: { id: templateId } });
      if (!template) {
        throw new Error('Template not found');
      }

      const exportRecord: SpreadsheetExport = {
        id: `export_${Date.now()}`,
        templateId,
        fileName: `${template.name}_${new Date().toISOString().split('T')[0]}.${template.fileType}`,
        filePath: '',
        fileSize: 0,
        exportType,
        filters,
        status: 'pending',
        createdAt: new Date(),
      };

      await this.exportRepository.save(exportRecord);

      // Simulate file generation
      const filePath = `/exports/${exportRecord.fileName}`;
      const fileSize = this.calculateFileSize(data, template.fileType);

      await this.exportRepository.update(exportRecord.id, {
        filePath,
        fileSize,
        status: 'completed',
        completedAt: new Date(),
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Export',
        entityId: exportRecord.id,
        action: 'CREATE',
        details: {
          templateId,
          fileName: exportRecord.fileName,
          exportType,
          recordCount: data.length,
          fileSize,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('spreadsheet.export.completed', {
        exportId: exportRecord.id,
        templateId,
        fileName: exportRecord.fileName,
        recordCount: data.length,
        fileSize,
        timestamp: new Date(),
      });

      return { ...exportRecord, filePath, fileSize, status: 'completed', completedAt: new Date() };
    } catch (error) {
      console.error('Error exporting to spreadsheet:', error);
      throw new Error('Failed to export to spreadsheet');
    }
  }

  /**
   * Import data from spreadsheet
   */
  async importFromSpreadsheet(
    templateId: string,
    filePath: string,
    fileName: string,
    fileSize: number,
    importType: 'full' | 'incremental' | 'validation_only' = 'full',
  ): Promise<SpreadsheetImport> {
    try {
      const template = await this.templateRepository.findOne({ where: { id: templateId } });
      if (!template) {
        throw new Error('Template not found');
      }

      const importRecord: SpreadsheetImport = {
        id: `import_${Date.now()}`,
        templateId,
        fileName,
        filePath,
        fileSize,
        importType,
        status: 'pending',
        recordsProcessed: 0,
        recordsSuccessful: 0,
        recordsFailed: 0,
        validationResults: [],
        createdAt: new Date(),
      };

      await this.importRepository.save(importRecord);

      // Process actual file data
      const fileData = await this.parseSpreadsheetFile(file, template);
      const validationResults = await this.validateData(fileData, template);
      const recordsProcessed = fileData.length;
      const recordsSuccessful = validationResults.filter(r => r.isValid).length;
      const recordsFailed = validationResults.filter(r => !r.isValid).length;

      await this.importRepository.update(importRecord.id, {
        status: 'completed',
        recordsProcessed,
        recordsSuccessful,
        recordsFailed,
        validationResults,
        completedAt: new Date(),
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Import',
        entityId: importRecord.id,
        action: 'CREATE',
        details: {
          templateId,
          fileName,
          importType,
          recordsProcessed,
          recordsSuccessful,
          recordsFailed,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('spreadsheet.import.completed', {
        importId: importRecord.id,
        templateId,
        fileName,
        recordsProcessed,
        recordsSuccessful,
        recordsFailed,
        timestamp: new Date(),
      });

      return {
        ...importRecord,
        status: 'completed',
        recordsProcessed,
        recordsSuccessful,
        recordsFailed,
        validationResults,
        completedAt: new Date(),
      };
    } catch (error) {
      console.error('Error importing from spreadsheet:', error);
      throw new Error('Failed to import from spreadsheet');
    }
  }

  /**
   * Validate spreadsheet data
   */
  async validateSpreadsheetData(templateId: string, data: any[]): Promise<ValidationResult[]> {
    try {
      const template = await this.templateRepository.findOne({ where: { id: templateId } });
      if (!template) {
        throw new Error('Template not found');
      }

      const validationResults = this.validateData(data, template);

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Validation',
        entityId: `validation_${Date.now()}`,
        action: 'CREATE',
        details: {
          templateId,
          recordCount: data.length,
          validRecords: validationResults.filter(r => r.isValid).length,
          invalidRecords: validationResults.filter(r => !r.isValid).length,
        },
        userId: 'system',
      });

      return validationResults;
    } catch (error) {
      console.error('Error validating spreadsheet data:', error);
      throw new Error('Failed to validate spreadsheet data');
    }
  }

  /**
   * Get all templates
   */
  async getAllTemplates(): Promise<SpreadsheetTemplate[]> {
    try {
      const templates = await this.templateRepository.find({
        order: { createdAt: 'DESC' },
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Templates',
        entityId: 'templates_list',
        action: 'READ',
        details: {
          count: templates.length,
        },
        userId: 'system',
      });

      return templates;
    } catch (error) {
      console.error('Error getting all templates:', error);
      throw new Error('Failed to get templates');
    }
  }

  /**
   * Get template by ID
   */
  async getTemplateById(templateId: string): Promise<SpreadsheetTemplate | null> {
    try {
      const template = await this.templateRepository.findOne({ where: { id: templateId } });

      if (template) {
        await this.auditService.logEvent({
          resource: 'SpreadsheetIntegration',
          entityType: 'Template',
          entityId: templateId,
          action: 'READ',
          details: {
            templateName: template.name,
            category: template.category,
            fileType: template.fileType,
          },
          userId: 'system',
        });
      }

      return template;
    } catch (error) {
      console.error('Error getting template by ID:', error);
      throw new Error('Failed to get template');
    }
  }

  /**
   * Get templates by category
   */
  async getTemplatesByCategory(category: SpreadsheetTemplate['category']): Promise<SpreadsheetTemplate[]> {
    try {
      const templates = await this.templateRepository.find({
        where: { category },
        order: { createdAt: 'DESC' },
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Templates',
        entityId: `templates_${category}`,
        action: 'READ',
        details: {
          category,
          count: templates.length,
        },
        userId: 'system',
      });

      return templates;
    } catch (error) {
      console.error('Error getting templates by category:', error);
      throw new Error('Failed to get templates by category');
    }
  }

  /**
   * Get export history
   */
  async getExportHistory(templateId?: string): Promise<SpreadsheetExport[]> {
    try {
      const whereCondition = templateId ? { templateId } : {};
      const exports = await this.exportRepository.find({
        where: whereCondition,
        order: { createdAt: 'DESC' },
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Exports',
        entityId: 'exports_list',
        action: 'READ',
        details: {
          templateId,
          count: exports.length,
        },
        userId: 'system',
      });

      return exports;
    } catch (error) {
      console.error('Error getting export history:', error);
      throw new Error('Failed to get export history');
    }
  }

  /**
   * Get import history
   */
  async getImportHistory(templateId?: string): Promise<SpreadsheetImport[]> {
    try {
      const whereCondition = templateId ? { templateId } : {};
      const imports = await this.importRepository.find({
        where: whereCondition,
        order: { createdAt: 'DESC' },
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Imports',
        entityId: 'imports_list',
        action: 'READ',
        details: {
          templateId,
          count: imports.length,
        },
        userId: 'system',
      });

      return imports;
    } catch (error) {
      console.error('Error getting import history:', error);
      throw new Error('Failed to get import history');
    }
  }

  /**
   * Create a scheduled report
   */
  async createScheduledReport(reportData: Omit<SpreadsheetReport, 'id' | 'createdAt' | 'updatedAt'>): Promise<SpreadsheetReport> {
    try {
      const report: SpreadsheetReport = {
        id: `report_${Date.now()}`,
        ...reportData,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.reportRepository.save(report);

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Report',
        entityId: report.id,
        action: 'CREATE',
        details: {
          reportName: report.name,
          templateId: report.templateId,
          reportType: report.reportType,
          schedule: report.schedule,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('spreadsheet.report.created', {
        reportId: report.id,
        reportName: report.name,
        templateId: report.templateId,
        reportType: report.reportType,
        timestamp: new Date(),
      });

      return report;
    } catch (error) {
      console.error('Error creating scheduled report:', error);
      throw new Error('Failed to create scheduled report');
    }
  }

  /**
   * Get all reports
   */
  async getAllReports(): Promise<SpreadsheetReport[]> {
    try {
      const reports = await this.reportRepository.find({
        order: { createdAt: 'DESC' },
      });

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Reports',
        entityId: 'reports_list',
        action: 'READ',
        details: {
          count: reports.length,
        },
        userId: 'system',
      });

      return reports;
    } catch (error) {
      console.error('Error getting all reports:', error);
      throw new Error('Failed to get reports');
    }
  }

  /**
   * Get spreadsheet integration statistics
   */
  async getSpreadsheetIntegrationStatistics(): Promise<any> {
    try {
      const totalTemplates = await this.templateRepository.count();
      const activeTemplates = await this.templateRepository.count({ where: { isActive: true } });
      const totalExports = await this.exportRepository.count();
      const completedExports = await this.exportRepository.count({ where: { status: 'completed' } });
      const totalImports = await this.importRepository.count();
      const completedImports = await this.importRepository.count({ where: { status: 'completed' } });
      const totalReports = await this.reportRepository.count();
      const activeReports = await this.reportRepository.count({ where: { isActive: true } });

      const statistics = {
        templates: {
          total: totalTemplates,
          active: activeTemplates,
          inactive: totalTemplates - activeTemplates,
        },
        exports: {
          total: totalExports,
          completed: completedExports,
          failed: totalExports - completedExports,
          successRate: totalExports > 0 ? (completedExports / totalExports) * 100 : 0,
        },
        imports: {
          total: totalImports,
          completed: completedImports,
          failed: totalImports - completedImports,
          successRate: totalImports > 0 ? (completedImports / totalImports) * 100 : 0,
        },
        reports: {
          total: totalReports,
          active: activeReports,
          inactive: totalReports - activeReports,
        },
        lastUpdated: new Date(),
      };

      await this.auditService.logEvent({
        resource: 'SpreadsheetIntegration',
        entityType: 'Statistics',
        entityId: 'spreadsheet_stats',
        action: 'READ',
        details: {
          totalTemplates,
          activeTemplates,
          totalExports,
          completedExports,
          totalImports,
          completedImports,
        },
        userId: 'system',
      });

      return statistics;
    } catch (error) {
      console.error('Error getting spreadsheet integration statistics:', error);
      throw new Error('Failed to get spreadsheet integration statistics');
    }
  }

  /**
   * Helper method to calculate file size
   */
  private calculateFileSize(data: any[], fileType: string): number {
    // Simple calculation based on data size and file type
    const baseSize = JSON.stringify(data).length;
    const multiplier = fileType === 'xlsx' ? 1.5 : fileType === 'csv' ? 0.8 : 1.0;
    return Math.round(baseSize * multiplier);
  }

  /**
   * Parse actual spreadsheet file data
   */
  private async parseSpreadsheetFile(file: Express.Multer.File, template: SpreadsheetTemplate): Promise<any[]> {
    try {
      const workbook = XLSX.read(file.buffer, { type: 'buffer' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      // Convert worksheet to JSON
      const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      
      if (rawData.length === 0) {
        throw new Error('Spreadsheet file is empty');
      }
      
      // Get headers from first row
      const headers = rawData[0] as string[];
      const dataRows = rawData.slice(1);
      
      // Map data to template fields
      const parsedData = dataRows.map((row: any[], index: number) => {
        const rowData: any = {};
        
        template.fields.forEach(field => {
          const columnIndex = headers.findIndex(header => 
            header.toLowerCase().trim() === field.name.toLowerCase().trim()
          );
          
          if (columnIndex !== -1 && row[columnIndex] !== undefined) {
            // Parse value based on field type
            let value = row[columnIndex];
            
            switch (field.type) {
              case 'number':
                value = parseFloat(value) || 0;
                break;
              case 'date':
                value = new Date(value);
                if (isNaN(value.getTime())) {
                  throw new Error(`Invalid date format in row ${index + 2}, column ${field.name}`);
                }
                break;
              case 'boolean':
                value = ['true', '1', 'yes', 'y'].includes(String(value).toLowerCase());
                break;
              case 'text':
              default:
                value = String(value).trim();
                break;
            }
            
            rowData[field.name] = value;
          } else if (field.required) {
            throw new Error(`Required field '${field.name}' missing in row ${index + 2}`);
          }
        });
        
        return rowData;
      });
      
      logger.info('Spreadsheet file parsed successfully', {
        fileName: file.originalname,
        rowCount: parsedData.length,
        fieldCount: template.fields.length
      });
      
      return parsedData;
      
    } catch (error) {
      logger.error('Failed to parse spreadsheet file', {
        fileName: file.originalname,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw new Error(`Spreadsheet parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Helper method to validate data against template
   */
  private validateData(data: any[], template: SpreadsheetTemplate): ValidationResult[] {
    const results: ValidationResult[] = [];
    
    data.forEach((row, rowIndex) => {
      template.fields.forEach(field => {
        const value = row[field.name];
        const validationResult: ValidationResult = {
          row: rowIndex + 1,
          field: field.name,
          value,
          isValid: true,
        };

        // Check required fields
        if (field.required && (value === undefined || value === null || value === '')) {
          validationResult.isValid = false;
          validationResult.errorMessage = `${field.displayName} is required`;
        }

        // Check type validation
        if (value !== undefined && value !== null && value !== '') {
          switch (field.type) {
            case 'number':
              if (isNaN(Number(value))) {
                validationResult.isValid = false;
                validationResult.errorMessage = `${field.displayName} must be a number`;
              }
              break;
            case 'date':
              if (isNaN(Date.parse(value))) {
                validationResult.isValid = false;
                validationResult.errorMessage = `${field.displayName} must be a valid date`;
              }
              break;
            case 'boolean':
              if (typeof value !== 'boolean') {
                validationResult.isValid = false;
                validationResult.errorMessage = `${field.displayName} must be true or false`;
              }
              break;
          }
        }

        // Check range validation
        if (field.validation?.min !== undefined && Number(value) < field.validation.min) {
          validationResult.isValid = false;
          validationResult.errorMessage = `${field.displayName} must be at least ${field.validation.min}`;
        }

        if (field.validation?.max !== undefined && Number(value) > field.validation.max) {
          validationResult.isValid = false;
          validationResult.errorMessage = `${field.displayName} must be at most ${field.validation.max}`;
        }

        // Check pattern validation
        if (field.validation?.pattern && !new RegExp(field.validation.pattern).test(value)) {
          validationResult.isValid = false;
          validationResult.errorMessage = `${field.displayName} format is invalid`;
        }

        // Check dropdown validation
        if (field.validation?.options && !field.validation.options.includes(value)) {
          validationResult.isValid = false;
          validationResult.errorMessage = `${field.displayName} must be one of: ${field.validation.options.join(', ')}`;
        }

        results.push(validationResult);
      });
    });

    return results;
  }
}