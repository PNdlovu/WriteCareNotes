import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { RehabilitationPlan, RehabilitationType, FunctionalLevel, RehabilitationGoalStatus } from '../../entities/rehabilitation/RehabilitationPlan';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export class RehabilitationService {
  private rehabilitationRepository: Repository<RehabilitationPlan>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;

  constructor() {
    this.rehabilitationRepository = AppDataSource.getRepository(RehabilitationPlan);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  async createRehabilitationPlan(planData: Partial<RehabilitationPlan>): Promise<RehabilitationPlan> {
    try {
      const planId = await this.generatePlanId();
      
      const plan = this.rehabilitationRepository.create({
        ...planData,
        planId,
        rehabilitationStartDate: new Date(),
        functionalAssessments: [],
        rehabilitationGoals: await this.generateInitialGoals(planData),
        therapySessions: [],
        outcomeTracking: await this.initializeOutcomeTracking(),
        multidisciplinaryTeam: await this.assembleRehabilitationTeam(planData.primaryRehabilitationType!),
        equipmentAndAdaptations: []
      });

      const savedPlan = await this.rehabilitationRepository.save(plan);
      
      await this.auditService.logEvent({
        resource: 'RehabilitationPlan',
        entityType: 'RehabilitationPlan',
        entityId: savedPlan.id,
        action: 'CREATE_REHABILITATION_PLAN',
        details: { planId: savedPlan.planId, rehabilitationType: savedPlan.primaryRehabilitationType },
        userId: 'rehabilitation_system'
      });

      return savedPlan;
    } catch (error: unknown) {
      console.error('Error creating rehabilitation plan:', error);
      throw error;
    }
  }

  async getRehabilitationAnalytics(): Promise<any> {
    try {
      const allPlans = await this.rehabilitationRepository.find();
      
      return {
        totalPlans: allPlans.length,
        activePlans: allPlans.filter(plan => plan.isActive()).length,
        averageProgress: allPlans.reduce((sum, plan) => sum + plan.calculateOverallProgress(), 0) / allPlans.length,
        dischargeReadiness: allPlans.filter(plan => plan.isReadyForDischarge()).length,
        typeDistribution: this.calculateTypeDistribution(allPlans),
        outcomeMetrics: this.calculateOutcomeMetrics(allPlans)
      };
    } catch (error: unknown) {
      console.error('Error getting rehabilitation analytics:', error);
      throw error;
    }
  }

  private async generatePlanId(): Promise<string> {
    const year = new Date().getFullYear();
    const count = await this.rehabilitationRepository.count();
    return `RHB${year}${String(count + 1).padStart(4, '0')}`;
  }

  private async generateInitialGoals(planData: any): Promise<any[]> {
    const commonGoals = [
      {
        goalId: crypto.randomUUID(),
        goalDescription: 'Improve mobility and independence',
        goalType: 'mobility',
        targetFunctionalLevel: FunctionalLevel.MODIFIED_INDEPENDENT,
        currentFunctionalLevel: FunctionalLevel.MODERATE_ASSISTANCE,
        measurableOutcomes: [
          {
            outcome: 'Walking distance',
            targetValue: 100,
            currentValue: 30,
            unit: 'meters',
            measurementMethod: '6-minute walk test'
          }
        ],
        interventions: [
          {
            interventionType: 'Gait training',
            frequency: 'daily',
            duration: 30,
            intensity: 'moderate',
            equipment: ['Walking frame', 'Parallel bars'],
            techniques: ['Weight shifting', 'Step training']
          }
        ],
        timeframe: {
          startDate: new Date(),
          targetDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000), // 60 days
          reviewDates: [new Date(Date.now() + 14 * 24 * 60 * 60 * 1000)] // 14 days
        },
        status: RehabilitationGoalStatus.NOT_STARTED,
        progressNotes: []
      }
    ];
    
    return commonGoals;
  }

  private async initializeOutcomeTracking(): Promise<any> {
    return {
      functionalImprovements: [],
      qualityOfLifeMetrics: {
        physicalWellbeing: 6,
        emotionalWellbeing: 7,
        socialWellbeing: 6,
        functionalWellbeing: 5,
        overallQualityOfLife: 6
      },
      dischargeReadiness: {
        functionalReadiness: 40,
        safetyReadiness: 60,
        equipmentReadiness: 80,
        supportSystemReadiness: 70,
        overallReadiness: 62.5
      },
      costEffectiveness: {
        totalCost: 0,
        costPerSession: 85,
        functionalGainCost: 0,
        qualityAdjustedLifeYears: 0,
        costEffectivenessRatio: 0
      }
    };
  }

  private async assembleRehabilitationTeam(primaryType: RehabilitationType): Promise<any[]> {
    const teamMembers = [
      {
        teamMemberId: 'physiotherapist_001',
        role: 'Physiotherapist',
        specialization: 'Mobility and strength',
        contactDetails: '+44 121 123 4567',
        availability: 'Monday-Friday 9-5',
        lastSession: new Date(),
        nextSession: new Date(Date.now() + 24 * 60 * 60 * 1000)
      }
    ];
    
    if (primaryType === RehabilitationType.OCCUPATIONAL_THERAPY) {
      teamMembers.push({
        teamMemberId: 'occupational_therapist_001',
        role: 'Occupational Therapist',
        specialization: 'Activities of daily living',
        contactDetails: '+44 121 123 4568',
        availability: 'Monday-Friday 9-5',
        lastSession: new Date(),
        nextSession: new Date(Date.now() + 48 * 60 * 60 * 1000)
      });
    }
    
    return teamMembers;
  }

  private calculateTypeDistribution(plans: RehabilitationPlan[]): any {
    return plans.reduce((acc, plan) => {
      acc[plan.primaryRehabilitationType] = (acc[plan.primaryRehabilitationType] || 0) + 1;
      return acc;
    }, {});
  }

  private calculateOutcomeMetrics(plans: RehabilitationPlan[]): any {
    const completedPlans = plans.filter(plan => plan.actualDischargeDate);
    
    return {
      averageFunctionalImprovement: completedPlans.reduce((sum, plan) => sum + plan.calculateFunctionalImprovement(), 0) / completedPlans.length,
      successfulDischarges: completedPlans.filter(plan => plan.calculateFunctionalImprovement() >= 15).length,
      averageLengthOfStay: this.calculateAverageLengthOfStay(completedPlans),
      costEffectiveness: this.calculateOverallCostEffectiveness(completedPlans)
    };
  }

  private calculateAverageLengthOfStay(plans: RehabilitationPlan[]): number {
    if (plans.length === 0) return 0;
    
    const totalDays = plans.reduce((sum, plan) => {
      const endDate = plan.actualDischargeDate || new Date();
      const startDate = new Date(plan.rehabilitationStartDate);
      return sum + Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    }, 0);
    
    return totalDays / plans.length;
  }

  private calculateOverallCostEffectiveness(plans: RehabilitationPlan[]): number {
    if (plans.length === 0) return 0;
    
    const totalCostEffectiveness = plans.reduce((sum, plan) => 
      sum + plan.outcomeTracking.costEffectiveness.costEffectivenessRatio, 0
    );
    
    return totalCostEffectiveness / plans.length;
  }
}