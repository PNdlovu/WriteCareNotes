import { Injectable } from '@nestjs/common';
import { EventEmitter2 } from 'eventemitter2';
import { AuditTrailService } from '../audit/AuditTrailService';
import { Logger } from '@nestjs/common';

export interface VoiceCommand {
  id: string;
  command: string;
  intent: string;
  parameters: Record<string, any>;
  userId: string;
  tenantId: string;
  timestamp: Date;
  confidence: number;
  response: string;
  status: 'processed' | 'failed' | 'pending';
  executionTime: number;
  auditTrail: AuditEntry[];
}

export interface VoiceMedicationLog {
  id: string;
  residentId: string;
  medicationName: string;
  dosage: string;
  time: Date;
  administeredBy: string;
  notes?: string;
  voiceTranscript: string;
  confidence: number;
  status: 'completed' | 'pending_review' | 'failed';
  createdAt: Date;
}

export interface VoiceCarePlanUpdate {
  id: string;
  residentId: string;
  updateType: 'medication' | 'activity' | 'assessment' | 'note' | 'alert';
  content: string;
  voiceTranscript: string;
  confidence: number;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status: 'completed' | 'pending_review' | 'failed';
  createdAt: Date;
  updatedAt: Date;
}

export interface VoiceEmergencyProtocol {
  id: string;
  residentId: string;
  emergencyType: 'medical' | 'fall' | 'behavioral' | 'environmental';
  severity: 'low' | 'medium' | 'high' | 'critical';
  location: string;
  voiceTranscript: string;
  timestamp: Date;
  status: 'active' | 'resolved' | 'escalated';
  actions: EmergencyAction[];
  createdAt: Date;
}

export interface EmergencyAction {
  id: string;
  action: string;
  assignedTo: string;
  status: 'pending' | 'in_progress' | 'completed';
  timestamp: Date;
  notes?: string;
}

export interface VoiceQuery {
  id: string;
  query: string;
  intent: 'resident_info' | 'medication_status' | 'care_plan' | 'schedule' | 'emergency' | 'general';
  residentId?: string;
  userId: string;
  tenantId: string;
  response: string;
  confidence: number;
  data: Record<string, any>;
  timestamp: Date;
}

export interface VoiceSettings {
  userId: string;
  tenantId: string;
  language: string;
  voice: string;
  speed: number;
  volume: number;
  wakeWord: string;
  privacyMode: boolean;
  dataRetention: number;
  enabledFeatures: string[];
  handsFreeMode: boolean;
  autoTranscribe: boolean;
  clinicalMode: boolean;
  emergencyMode: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface AuditEntry {
  action: string;
  timestamp: Date;
  userId: string;
  details: Record<string, any>;
  complianceFlags: string[];
}

@Injectable()
export class EnhancedVoiceAssistantService {
  private readonly logger = new Logger(EnhancedVoiceAssistantService.name);
  private eventEmitter: EventEmitter2;
  private auditService: AuditTrailService;

  constructor() {
    this.eventEmitter = new EventEmitter2();
    this.auditService = new AuditTrailService();
  }

  /**
   * Process hands-free voice command
   */
  async processHandsFreeCommand(
    command: string,
    userId: string,
    tenantId: string,
    device: string,
    location?: string
  ): Promise<VoiceCommand> {
    const startTime = Date.now();
    
    try {
      // Enhanced intent parsing for hands-free operations
      const intent = await this.parseHandsFreeIntent(command);
      const parameters = await this.extractHandsFreeParameters(command, intent);
      const confidence = await this.calculateConfidence(command, intent);

      // Generate response based on intent
      const response = await this.generateHandsFreeResponse(intent, parameters, userId, tenantId);

      const voiceCommand: VoiceCommand = {
        id: this.generateId(),
        command,
        intent,
        parameters,
        userId,
        tenantId,
        timestamp: new Date(),
        confidence,
        response,
        status: 'processed',
        executionTime: Date.now() - startTime,
        auditTrail: [{
          action: 'hands_free_command_processed',
          timestamp: new Date(),
          userId,
          details: {
            command,
            intent,
            confidence,
            executionTime: Date.now() - startTime,
            device,
            location
          },
          complianceFlags: ['Voice Assistant', 'Hands-Free Operation', 'Data Processing']
        }]
      };

      await this.auditService.logEvent({
        action: 'hands_free_command_processed',
        resource: 'enhanced_voice_assistant',
        entityType: 'voice_command',
        entityId: voiceCommand.id,
        details: {
          commandId: voiceCommand.id,
          userId,
          tenantId,
          intent,
          confidence,
          executionTime: voiceCommand.executionTime
        },
        userId,
        timestamp: new Date()
      });

      this.logger.log(`Processed hands-free command: ${intent} for user ${userId}`);
      return voiceCommand;

    } catch (error) {
      this.logger.error(`Failed to process hands-free command: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Log medication using voice
   */
  async logMedicationByVoice(
    voiceTranscript: string,
    residentId: string,
    userId: string,
    tenantId: string
  ): Promise<VoiceMedicationLog> {
    try {
      // Parse medication information from voice transcript
      const medicationInfo = await this.parseMedicationFromVoice(voiceTranscript);
      
      const medicationLog: VoiceMedicationLog = {
        id: this.generateId(),
        residentId,
        medicationName: medicationInfo.name,
        dosage: medicationInfo.dosage,
        time: medicationInfo.time || new Date(),
        administeredBy: userId,
        notes: medicationInfo.notes,
        voiceTranscript,
        confidence: medicationInfo.confidence,
        status: medicationInfo.confidence > 0.8 ? 'completed' : 'pending_review',
        createdAt: new Date()
      };

      // Save to database (in real implementation)
      await this.saveMedicationLog(medicationLog);

      await this.auditService.logEvent({
        action: 'medication_logged_by_voice',
        resource: 'enhanced_voice_assistant',
        entityType: 'medication_log',
        entityId: medicationLog.id,
        details: {
          medicationLogId: medicationLog.id,
          residentId,
          medicationName: medicationInfo.name,
          dosage: medicationInfo.dosage,
          confidence: medicationInfo.confidence
        },
        userId,
        timestamp: new Date()
      });

      this.logger.log(`Medication logged by voice: ${medicationInfo.name} for resident ${residentId}`);
      return medicationLog;

    } catch (error) {
      this.logger.error(`Failed to log medication by voice: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Update care plan using voice
   */
  async updateCarePlanByVoice(
    voiceTranscript: string,
    residentId: string,
    userId: string,
    tenantId: string
  ): Promise<VoiceCarePlanUpdate> {
    try {
      // Parse care plan update from voice transcript
      const updateInfo = await this.parseCarePlanFromVoice(voiceTranscript);
      
      const carePlanUpdate: VoiceCarePlanUpdate = {
        id: this.generateId(),
        residentId,
        updateType: updateInfo.type,
        content: updateInfo.content,
        voiceTranscript,
        confidence: updateInfo.confidence,
        priority: updateInfo.priority,
        status: updateInfo.confidence > 0.8 ? 'completed' : 'pending_review',
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // Save to database (in real implementation)
      await this.saveCarePlanUpdate(carePlanUpdate);

      await this.auditService.logEvent({
        action: 'care_plan_updated_by_voice',
        resource: 'enhanced_voice_assistant',
        entityType: 'care_plan_update',
        entityId: carePlanUpdate.id,
        details: {
          carePlanUpdateId: carePlanUpdate.id,
          residentId,
          updateType: updateInfo.type,
          priority: updateInfo.priority,
          confidence: updateInfo.confidence
        },
        userId,
        timestamp: new Date()
      });

      this.logger.log(`Care plan updated by voice: ${updateInfo.type} for resident ${residentId}`);
      return carePlanUpdate;

    } catch (error) {
      this.logger.error(`Failed to update care plan by voice: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Activate emergency protocol using voice
   */
  async activateEmergencyProtocol(
    voiceTranscript: string,
    residentId: string,
    userId: string,
    tenantId: string,
    location: string
  ): Promise<VoiceEmergencyProtocol> {
    try {
      // Parse emergency information from voice transcript
      const emergencyInfo = await this.parseEmergencyFromVoice(voiceTranscript);
      
      const emergencyProtocol: VoiceEmergencyProtocol = {
        id: this.generateId(),
        residentId,
        emergencyType: emergencyInfo.type,
        severity: emergencyInfo.severity,
        location,
        voiceTranscript,
        timestamp: new Date(),
        status: 'active',
        actions: await this.generateEmergencyActions(emergencyInfo, residentId, tenantId),
        createdAt: new Date()
      };

      // Save to database and trigger emergency procedures
      await this.saveEmergencyProtocol(emergencyProtocol);
      await this.triggerEmergencyProcedures(emergencyProtocol);

      await this.auditService.logEvent({
        action: 'emergency_protocol_activated',
        resource: 'enhanced_voice_assistant',
        entityType: 'emergency_protocol',
        entityId: emergencyProtocol.id,
        details: {
          emergencyProtocolId: emergencyProtocol.id,
          residentId,
          emergencyType: emergencyInfo.type,
          severity: emergencyInfo.severity,
          location
        },
        userId,
        timestamp: new Date()
      });

      this.logger.log(`Emergency protocol activated: ${emergencyInfo.type} for resident ${residentId}`);
      return emergencyProtocol;

    } catch (error) {
      this.logger.error(`Failed to activate emergency protocol: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Query resident information using voice
   */
  async queryResidentInfo(
    query: string,
    residentId: string,
    userId: string,
    tenantId: string
  ): Promise<VoiceQuery> {
    try {
      // Parse query intent
      const intent = await this.parseQueryIntent(query) as 'resident_info' | 'medication_status' | 'care_plan' | 'schedule' | 'emergency' | 'general';
      
      // Retrieve resident information
      const residentData = await this.getResidentData(residentId, tenantId);
      
      // Generate response based on query
      const response = await this.generateResidentInfoResponse(query, intent, residentData);
      
      const voiceQuery: VoiceQuery = {
        id: this.generateId(),
        query,
        intent,
        residentId,
        userId,
        tenantId,
        response,
        confidence: 0.9, // High confidence for data queries
        data: residentData,
        timestamp: new Date()
      };

      await this.auditService.logEvent({
        action: 'resident_info_queried_by_voice',
        resource: 'enhanced_voice_assistant',
        entityType: 'voice_query',
        entityId: voiceQuery.id,
        details: {
          voiceQueryId: voiceQuery.id,
          residentId,
          query,
          intent
        },
        userId,
        timestamp: new Date()
      });

      this.logger.log(`Resident info queried by voice: ${intent} for resident ${residentId}`);
      return voiceQuery;

    } catch (error) {
      this.logger.error(`Failed to query resident info: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Get voice settings for user
   */
  async getVoiceSettings(userId: string, tenantId: string): Promise<VoiceSettings> {
    try {
      // In a real implementation, this would query the database
      const settings: VoiceSettings = {
        userId,
        tenantId,
        language: 'en-GB',
        voice: 'female',
        speed: 1.0,
        volume: 0.8,
        wakeWord: 'WriteCare',
        privacyMode: true,
        dataRetention: 30,
        enabledFeatures: [
          'medication_logging',
          'care_plan_updates',
          'emergency_protocols',
          'resident_queries',
          'hands_free_mode'
        ],
        handsFreeMode: true,
        autoTranscribe: true,
        clinicalMode: true,
        emergencyMode: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      return settings;
    } catch (error) {
      this.logger.error(`Failed to get voice settings: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Update voice settings
   */
  async updateVoiceSettings(
    userId: string,
    tenantId: string,
    updates: Partial<VoiceSettings>
  ): Promise<VoiceSettings> {
    try {
      const currentSettings = await this.getVoiceSettings(userId, tenantId);
      const updatedSettings = { ...currentSettings, ...updates, updatedAt: new Date() };

      // Save to database (in real implementation)
      await this.saveVoiceSettings(updatedSettings);

      await this.auditService.logEvent({
        action: 'voice_settings_updated',
        resource: 'enhanced_voice_assistant',
        entityType: 'voice_settings',
        entityId: userId,
        details: {
          userId,
          tenantId,
          updates
        },
        userId,
        timestamp: new Date()
      });

      this.logger.log(`Voice settings updated for user ${userId}`);
      return updatedSettings;

    } catch (error) {
      this.logger.error(`Failed to update voice settings: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Parse hands-free intent
   */
  private async parseHandsFreeIntent(command: string): Promise<string> {
    const lowerCommand = command.toLowerCase();
    
    // Medication logging
    if (lowerCommand.includes('medication') || lowerCommand.includes('medicine') || 
        lowerCommand.includes('drug') || lowerCommand.includes('pill')) {
      return 'medication_logging';
    }
    
    // Care plan updates
    if (lowerCommand.includes('care plan') || lowerCommand.includes('update') || 
        lowerCommand.includes('note') || lowerCommand.includes('assessment')) {
      return 'care_plan_update';
    }
    
    // Emergency protocols
    if (lowerCommand.includes('emergency') || lowerCommand.includes('urgent') || 
        lowerCommand.includes('help') || lowerCommand.includes('alert')) {
      return 'emergency_protocol';
    }
    
    // Resident queries
    if (lowerCommand.includes('resident') || lowerCommand.includes('patient') || 
        lowerCommand.includes('show') || lowerCommand.includes('tell me')) {
      return 'resident_query';
    }
    
    // Schedule queries
    if (lowerCommand.includes('schedule') || lowerCommand.includes('appointment') || 
        lowerCommand.includes('meeting') || lowerCommand.includes('when')) {
      return 'schedule_query';
    }
    
    return 'general_query';
  }

  /**
   * Extract hands-free parameters
   */
  private async extractHandsFreeParameters(command: string, intent: string): Promise<Record<string, any>> {
    const parameters: Record<string, any> = {};
    
    if (intent === 'medication_logging') {
      // Extract medication name
      const medicationMatch = command.match(/(?:medication|medicine|drug|pill)\s+(\w+)/i);
      if (medicationMatch) {
        parameters.medicationName = medicationMatch[1];
      }
      
      // Extract dosage
      const dosageMatch = command.match(/(\d+)\s*(mg|ml|tablets?|pills?)/i);
      if (dosageMatch) {
        parameters.dosage = dosageMatch[0];
      }
      
      // Extract time
      const timeMatch = command.match(/(\d{1,2}):(\d{2})/);
      if (timeMatch) {
        parameters.time = timeMatch[0];
      }
    }
    
    if (intent === 'emergency_protocol') {
      // Extract emergency type
      if (command.toLowerCase().includes('medical')) {
        parameters.emergencyType = 'medical';
      } else if (command.toLowerCase().includes('fall')) {
        parameters.emergencyType = 'fall';
      } else if (command.toLowerCase().includes('behavior')) {
        parameters.emergencyType = 'behavioral';
      } else {
        parameters.emergencyType = 'environmental';
      }
      
      // Extract severity
      if (command.toLowerCase().includes('critical') || command.toLowerCase().includes('urgent')) {
        parameters.severity = 'critical';
      } else if (command.toLowerCase().includes('high')) {
        parameters.severity = 'high';
      } else if (command.toLowerCase().includes('medium')) {
        parameters.severity = 'medium';
      } else {
        parameters.severity = 'low';
      }
    }
    
    return parameters;
  }

  /**
   * Generate hands-free response
   */
  private async generateHandsFreeResponse(
    intent: string,
    parameters: Record<string, any>,
    userId: string,
    tenantId: string
  ): Promise<string> {
    switch (intent) {
      case 'medication_logging':
        return `I've logged the medication ${parameters.medicationName || 'information'} for you. The details have been recorded and will be reviewed by the clinical team.`;
      
      case 'care_plan_update':
        return `I've updated the care plan based on your input. The changes have been recorded and will be reviewed by the care team.`;
      
      case 'emergency_protocol':
        return `Emergency protocol activated. I've alerted the appropriate staff members and initiated the necessary procedures. Help is on the way.`;
      
      case 'resident_query':
        return `I'm retrieving the resident information you requested. Please hold while I gather the details.`;
      
      case 'schedule_query':
        return `I'm checking the schedule for you. Let me pull up the relevant information.`;
      
      default:
        return `I understand you're asking about something. Could you please be more specific so I can help you better?`;
    }
  }

  /**
   * Parse medication information from voice
   */
  private async parseMedicationFromVoice(transcript: string): Promise<any> {
    // Enhanced medication parsing logic
    const medicationMatch = transcript.match(/(?:medication|medicine|drug|pill)\s+(\w+)/i);
    const dosageMatch = transcript.match(/(\d+)\s*(mg|ml|tablets?|pills?)/i);
    const timeMatch = transcript.match(/(\d{1,2}):(\d{2})/);
    
    return {
      name: medicationMatch ? medicationMatch[1] : 'Unknown medication',
      dosage: dosageMatch ? dosageMatch[0] : 'As prescribed',
      time: timeMatch ? new Date(`2000-01-01 ${timeMatch[0]}`) : new Date(),
      notes: transcript,
      confidence: 0.8
    };
  }

  /**
   * Parse care plan information from voice
   */
  private async parseCarePlanFromVoice(transcript: string): Promise<any> {
    // Enhanced care plan parsing logic
    let type = 'note';
    if (transcript.toLowerCase().includes('medication')) type = 'medication';
    if (transcript.toLowerCase().includes('activity')) type = 'activity';
    if (transcript.toLowerCase().includes('assessment')) type = 'assessment';
    if (transcript.toLowerCase().includes('alert')) type = 'alert';
    
    let priority = 'medium';
    if (transcript.toLowerCase().includes('urgent') || transcript.toLowerCase().includes('critical')) {
      priority = 'urgent';
    } else if (transcript.toLowerCase().includes('high')) {
      priority = 'high';
    } else if (transcript.toLowerCase().includes('low')) {
      priority = 'low';
    }
    
    return {
      type,
      content: transcript,
      confidence: 0.8,
      priority
    };
  }

  /**
   * Parse emergency information from voice
   */
  private async parseEmergencyFromVoice(transcript: string): Promise<any> {
    // Enhanced emergency parsing logic
    let type = 'environmental';
    if (transcript.toLowerCase().includes('medical')) type = 'medical';
    if (transcript.toLowerCase().includes('fall')) type = 'fall';
    if (transcript.toLowerCase().includes('behavior')) type = 'behavioral';
    
    let severity = 'medium';
    if (transcript.toLowerCase().includes('critical') || transcript.toLowerCase().includes('urgent')) {
      severity = 'critical';
    } else if (transcript.toLowerCase().includes('high')) {
      severity = 'high';
    } else if (transcript.toLowerCase().includes('low')) {
      severity = 'low';
    }
    
    return {
      type,
      severity,
      confidence: 0.9
    };
  }

  /**
   * Parse query intent
   */
  private async parseQueryIntent(query: string): Promise<string> {
    const lowerQuery = query.toLowerCase();
    
    if (lowerQuery.includes('medication') || lowerQuery.includes('medicine')) {
      return 'medication_status';
    } else if (lowerQuery.includes('care plan') || lowerQuery.includes('plan')) {
      return 'care_plan';
    } else if (lowerQuery.includes('schedule') || lowerQuery.includes('appointment')) {
      return 'schedule';
    } else if (lowerQuery.includes('emergency') || lowerQuery.includes('urgent')) {
      return 'emergency';
    } else {
      return 'resident_info';
    }
  }

  /**
   * Generate emergency actions
   */
  private async generateEmergencyActions(emergencyInfo: any, residentId: string, tenantId: string): Promise<EmergencyAction[]> {
    const actions: EmergencyAction[] = [];
    
    // Always notify medical staff
    actions.push({
      id: this.generateId(),
      action: 'Notify medical staff',
      assignedTo: 'medical_team',
      status: 'pending',
      timestamp: new Date()
    });
    
    // Add specific actions based on emergency type
    if (emergencyInfo.type === 'medical') {
      actions.push({
        id: this.generateId(),
        action: 'Assess vital signs',
        assignedTo: 'nursing_staff',
        status: 'pending',
        timestamp: new Date()
      });
    } else if (emergencyInfo.type === 'fall') {
      actions.push({
        id: this.generateId(),
        action: 'Check for injuries',
        assignedTo: 'nursing_staff',
        status: 'pending',
        timestamp: new Date()
      });
    }
    
    return actions;
  }

  /**
   * Get resident data
   */
  private async getResidentData(residentId: string, tenantId: string): Promise<any> {
    // In a real implementation, this would query the database
    return {
      id: residentId,
      name: 'Resident Name',
      room: 'Room 101',
      careLevel: 'High',
      medications: ['Medication A', 'Medication B'],
      allergies: ['Allergy 1', 'Allergy 2'],
      lastAssessment: new Date(),
      nextAppointment: new Date(Date.now() + 24 * 60 * 60 * 1000)
    };
  }

  /**
   * Generate resident info response
   */
  private async generateResidentInfoResponse(query: string, intent: string, residentData: any): Promise<string> {
    switch (intent) {
      case 'medication_status':
        return `Resident ${residentData.name} is currently taking ${residentData.medications.join(', ')}.`;
      case 'care_plan':
        return `The care plan for ${residentData.name} is at ${residentData.careLevel} level. Last assessment was on ${residentData.lastAssessment.toLocaleDateString()}.`;
      case 'schedule':
        return `The next appointment for ${residentData.name} is scheduled for ${residentData.nextAppointment.toLocaleDateString()}.`;
      default:
        return `Resident ${residentData.name} is in ${residentData.room}. Care level is ${residentData.careLevel}.`;
    }
  }

  /**
   * Save medication log
   */
  private async saveMedicationLog(log: VoiceMedicationLog): Promise<void> {
    // In a real implementation, this would save to database
    console.log('Saving medication log:', log);
  }

  /**
   * Save care plan update
   */
  private async saveCarePlanUpdate(update: VoiceCarePlanUpdate): Promise<void> {
    // In a real implementation, this would save to database
    console.log('Saving care plan update:', update);
  }

  /**
   * Save emergency protocol
   */
  private async saveEmergencyProtocol(protocol: VoiceEmergencyProtocol): Promise<void> {
    // In a real implementation, this would save to database
    console.log('Saving emergency protocol:', protocol);
  }

  /**
   * Trigger emergency procedures
   */
  private async triggerEmergencyProcedures(protocol: VoiceEmergencyProtocol): Promise<void> {
    // In a real implementation, this would trigger actual emergency procedures
    console.log('Triggering emergency procedures:', protocol);
  }

  /**
   * Save voice settings
   */
  private async saveVoiceSettings(settings: VoiceSettings): Promise<void> {
    // In a real implementation, this would save to database
    console.log('Saving voice settings:', settings);
  }

  /**
   * Calculate confidence score
   */
  private async calculateConfidence(command: string, intent: string): Promise<number> {
    const baseConfidence = 0.7;
    const commandLength = command.length;
    const lengthFactor = Math.min(1, commandLength / 50);
    
    return Math.min(0.95, baseConfidence + lengthFactor * 0.2);
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

export default EnhancedVoiceAssistantService;