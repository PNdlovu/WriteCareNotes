import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Care Plan Template Service for WriteCareNotes
 * @module CarePlanTemplateService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-09
 * 
 * @description Service for managing care plan templates based on resident needs assessment,
 * including SMART goals integration and risk assessment-based template selection.
 * 
 * @compliance
 * - CQC (Care Quality Commission) - England
 * - Care Inspectorate - Scotland  
 * - CIW (Care Inspectorate Wales) - Wales
 * - RQIA (Regulation and Quality Improvement Authority) - Northern Ireland
 * 
 * @security
 * - Implements field-level encryption for sensitive care data
 * - Comprehensive audit trails for all operations
 * - Role-based access control integration
 */

import { Repository, DataSource } from 'typeorm';
import { validate, ValidationError } from 'class-validator';
import { CareDomain, DomainType, CurrentStatus, RiskLevel, MonitoringFrequency } from '../../entities/care-planning/CareDomain';
import { CareIntervention, InterventionType, Priority } from '../../entities/care-planning/CareIntervention';
import { CarePlan } from '../../entities/care-planning/CarePlan';
import { Resident } from '../../entities/resident/Resident';
import { AuditTrailService } from '../audit/AuditTrailService';
import { EventPublishingService } from '../events/EventPublishingService';
import { logger } from '../../utils/logger';

export interface ResidentNeedsAssessment {
  residentId: string;
  assessmentDate: Date;
  assessedBy: string;
  
  // Physical needs
  mobilityLevel: 'independent' | 'assisted' | 'dependent' | 'bedbound';
  fallRisk: 'low' | 'medium' | 'high' | 'critical';
  skinIntegrity: 'intact' | 'at_risk' | 'compromised' | 'critical';
  nutritionalStatus: 'adequate' | 'at_risk' | 'malnourished' | 'obese';
  continenceLevel: 'continent' | 'occasional' | 'frequent' | 'incontinent';
  
  // Cognitive needs
  cognitiveFunction: 'intact' | 'mild_impairment' | 'moderate_impairment' | 'severe_impairment';
  memoryIssues: boolean;
  disorientationRisk: boolean;
  behavioralChallenges: string[];
  
  // Psychosocial needs
  socialEngagement: 'active' | 'moderate' | 'limited' | 'isolated';
  moodStatus: 'stable' | 'anxious' | 'depressed' | 'variable';
  familySupport: 'strong' | 'moderate' | 'limited' | 'none';
  culturalNeeds: string[];
  religiousNeeds: string[];
  
  // Medical needs
  chronicConditions: string[];
  medicationComplexity: 'simple' | 'moderate' | 'complex' | 'high_risk';
  allergies: string[];
  specialDiets: string[];
  
  // Functional needs
  adlDependency: 'independent' | 'minimal_assist' | 'moderate_assist' | 'maximum_assist';
  communicationAbility: 'clear' | 'impaired' | 'non_verbal' | 'assistive_device';
  sensoryImpairments: string[];
  
  // Risk factors
  identifiedRisks: RiskFactor[];
  safeguardingConcerns: string[];
}

export interface RiskFactor {
  riskType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  likelihood: 'unlikely' | 'possible' | 'likely' | 'certain';
  impact: 'minimal' | 'moderate' | 'significant' | 'severe';
  mitigationStrategies: string[];
}

export interface SMARTGoal {
  id?: string;
  goalName: string;
  domainType: DomainType;
  
  // SMART criteria
  specific: string;
  measurable: string;
  achievable: string;
  relevant: string;
  timeBound: string;
  
  // Goal details
  targetOutcome: string;
  measurementMethod: string;
  reviewFrequency: 'daily' | 'weekly' | 'monthly' | 'quarterly';
  targetDate: Date;
  
  // Progress tracking
  baselineValue?: string;
  currentValue?: string;
  progressNotes?: string[];
  isAchieved?: boolean;
  achievedDate?: Date;
}

export interface CarePlanTemplate {
  id: string;
  templateName: string;
  description: string;
  applicableTo: string[];
  
  // Template domains
  domains: CareDomainTemplate[];
  
  // Template metadata
  createdBy: string;
  createdAt: Date;
  lastUpdated: Date;
  version: number;
  isActive: boolean;
}

export interface CareDomainTemplate {
  domainType: DomainType;
  domainName: string;
  defaultRiskLevel: RiskLevel;
  defaultMonitoringFrequency: MonitoringFrequency;
  
  // Template interventions
  interventions: CareInterventionTemplate[];
  
  // Template SMART goals
  smartGoals: SMARTGoal[];
  
  // Assessment criteria
  assessmentCriteria: string[];
  riskIndicators: string[];
}

export interface CareInterventionTemplate {
  interventionName: string;
  interventionType: InterventionType;
  description: string;
  frequency: string;
  timing?: string;
  priority: Priority;
  durationMinutes?: number;
  
  // Conditional application
  applicableWhen: string[];
  requiredSkills?: string[];
  equipmentNeeded?: string[];
  safetyConsiderations?: string[];
}

export interface GenerateCarePlanRequest {
  residentId: string;
  needsAssessment: ResidentNeedsAssessment;
  templateIds?: string[];
  customizations?: CarePlanCustomization[];
  createdBy: string;
}

export interface CarePlanCustomization {
  domainType: DomainType;
  customGoals?: SMARTGoal[];
  customInterventions?: CareInterventionTemplate[];
  riskLevelOverride?: RiskLevel;
  monitoringFrequencyOverride?: MonitoringFrequency;
}

export interface GeneratedCarePlan {
  carePlan: CarePlan;
  domains: CareDomain[];
  interventions: CareIntervention[];
  smartGoals: SMARTGoal[];
  riskAssessment: RiskAssessmentSummary;
}

export interface RiskAssessmentSummary {
  overallRiskLevel: RiskLevel;
  criticalRisks: RiskFactor[];
  recommendedActions: string[];
  monitoringRequirements: string[];
  reviewDate: Date;
}

export class CarePlanTemplateValidationError extends Error {
  constructor(
    message: string,
    public validationErrors: ValidationError[]
  ) {
    super(message);
    this.name = 'CarePlanTemplateValidationError';
  }
}

export class CarePlanTemplateService {
  private carePlanRepository: Repository<CarePlan>;
  private careDomainRepository: Repository<CareDomain>;
  private careInterventionRepository: Repository<CareIntervention>;
  private residentRepository: Repository<Resident>;

  // Built-in templates
  private readonly builtInTemplates: CarePlanTemplate[] = [
    {
      id: 'template-dementia-care',
      templateName: 'Dementia Care Plan',
      description: 'Comprehensive care plan for residents with dementia',
      applicableTo: ['dementia', 'alzheimers', 'cognitive_impairment'],
      domains: [
        {
          domainType: DomainType.MENTAL_HEALTH,
          domainName: 'Cognitive Support',
          defaultRiskLevel: RiskLevel.HIGH,
          defaultMonitoringFrequency: MonitoringFrequency.DAILY,
          interventions: [
            {
              interventionName: 'Cognitive Stimulation Activities',
              interventionType: InterventionType.THERAPEUTIC,
              description: 'Structured activities to maintain cognitive function',
              frequency: 'Daily',
              timing: 'Morning and afternoon',
              priority: Priority.HIGH,
              durationMinutes: 45,
              applicableWhen: ['cognitive_impairment'],
              requiredSkills: ['dementia_care_training'],
              safetyConsiderations: ['Monitor for agitation', 'Ensure safe environment']
            }
          ],
          smartGoals: [
            {
              goalName: 'Maintain Cognitive Engagement',
              domainType: DomainType.MENTAL_HEALTH,
              specific: 'Participate in daily cognitive stimulation activities',
              measurable: 'Engage for at least 30 minutes per session',
              achievable: 'Based on current cognitive level',
              relevant: 'Helps maintain cognitive function and quality of life',
              timeBound: '3 months',
              targetOutcome: 'Sustained engagement in cognitive activities',
              measurementMethod: 'Activity participation logs',
              reviewFrequency: 'weekly',
              targetDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000)
            }
          ],
          assessmentCriteria: ['Cognitive function level', 'Behavioral patterns', 'Communication ability'],
          riskIndicators: ['Wandering behavior', 'Agitation', 'Confusion', 'Safety awareness']
        },
        {
          domainType: DomainType.PERSONAL_CARE,
          domainName: 'Personal Care Support',
          defaultRiskLevel: RiskLevel.MEDIUM,
          defaultMonitoringFrequency: MonitoringFrequency.DAILY,
          interventions: [
            {
              interventionName: 'Assisted Personal Hygiene',
              interventionType: InterventionType.PERSONAL_CARE,
              description: 'Support with daily personal hygiene tasks',
              frequency: 'Daily',
              timing: 'Morning',
              priority: Priority.HIGH,
              durationMinutes: 30,
              applicableWhen: ['adl_dependency'],
              requiredSkills: ['personal_care_training'],
              safetyConsiderations: ['Maintain dignity', 'Monitor skin integrity']
            }
          ],
          smartGoals: [
            {
              goalName: 'Maintain Personal Hygiene',
              domainType: DomainType.PERSONAL_CARE,
              specific: 'Complete daily personal hygiene routine',
              measurable: 'All hygiene tasks completed daily',
              achievable: 'With appropriate support level',
              relevant: 'Essential for health and dignity',
              timeBound: 'Ongoing',
              targetOutcome: 'Consistent personal hygiene maintenance',
              measurementMethod: 'Daily care records',
              reviewFrequency: 'weekly',
              targetDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
            }
          ],
          assessmentCriteria: ['ADL dependency level', 'Skin integrity', 'Cooperation level'],
          riskIndicators: ['Skin breakdown risk', 'Infection risk', 'Dignity concerns']
        }
      ],
      createdBy: 'system',
      createdAt: new Date(),
      lastUpdated: new Date(),
      version: 1,
      isActive: true
    },
    {
      id: 'template-mobility-support',
      templateName: 'Mobility Support Plan',
      description: 'Care plan for residents with mobility challenges',
      applicableTo: ['mobility_impairment', 'fall_risk', 'wheelchair_user'],
      domains: [
        {
          domainType: DomainType.MOBILITY,
          domainName: 'Mobility Enhancement',
          defaultRiskLevel: RiskLevel.HIGH,
          defaultMonitoringFrequency: MonitoringFrequency.DAILY,
          interventions: [
            {
              interventionName: 'Fall Prevention Program',
              interventionType: InterventionType.MOBILITY,
              description: 'Comprehensive fall prevention interventions',
              frequency: 'Daily',
              timing: 'Throughout day',
              priority: Priority.CRITICAL,
              durationMinutes: 0, // Ongoing
              applicableWhen: ['fall_risk'],
              requiredSkills: ['mobility_training', 'risk_assessment'],
              equipmentNeeded: ['mobility_aids', 'sensor_mats'],
              safetyConsiderations: ['Regular risk assessment', 'Environmental modifications']
            }
          ],
          smartGoals: [
            {
              goalName: 'Reduce Fall Risk',
              domainType: DomainType.MOBILITY,
              specific: 'Implement comprehensive fall prevention measures',
              measurable: 'Zero falls over 3-month period',
              achievable: 'With appropriate interventions and monitoring',
              relevant: 'Critical for resident safety and independence',
              timeBound: '3 months',
              targetOutcome: 'Maintained mobility without falls',
              measurementMethod: 'Incident reports and mobility assessments',
              reviewFrequency: 'weekly',
              targetDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000)
            }
          ],
          assessmentCriteria: ['Mobility level', 'Balance assessment', 'Fall history'],
          riskIndicators: ['Previous falls', 'Balance issues', 'Medication effects', 'Environmental hazards']
        }
      ],
      createdBy: 'system',
      createdAt: new Date(),
      lastUpdated: new Date(),
      version: 1,
      isActive: true
    }
  ];

  constructor(
    private dataSource: DataSource,
    private auditService: AuditTrailService,
    private eventPublisher: EventPublishingService
  ) {
    this.carePlanRepository = dataSource.getRepository(CarePlan);
    this.careDomainRepository = dataSource.getRepository(CareDomain);
    this.careInterventionRepository = dataSource.getRepository(CareIntervention);
    this.residentRepository = dataSource.getRepository(Resident);
  }

  /**
   * Generate care plan based on resident needs assessment
   */
  async generateCarePlan(request: GenerateCarePlanRequest): Promise<GeneratedCarePlan> {
    const correlationId = `care-plan-generate-${Date.now()}`;
    
    try {
      console.info('Generating care plan from needs assessment', { 
        residentId: request.residentId,
        correlationId 
      });

      // Validate resident exists
      const resident = await this.residentRepository.findOne({
        where: { id: request.residentId, deletedAt: null }
      });

      if (!resident) {
        throw new Error(`Resident with ID ${request.residentId} not found`);
      }

      // Select appropriate templates
      const selectedTemplates = await this.selectTemplates(request.needsAssessment, request.templateIds);
      
      // Perform risk assessment
      const riskAssessment = this.performRiskAssessment(request.needsAssessment);
      
      // Generate care plan structure
      const carePlan = await this.createCarePlanFromTemplates(
        resident,
        selectedTemplates,
        request.needsAssessment,
        request.customizations,
        request.createdBy
      );

      // Generate domains with SMART goals
      const domains = await this.generateDomainsWithSMARTGoals(
        carePlan.id,
        selectedTemplates,
        request.needsAssessment,
        request.customizations
      );

      // Generate interventions
      const interventions = await this.generateInterventions(
        domains,
        selectedTemplates,
        request.needsAssessment
      );

      // Extract all SMART goals
      const smartGoals = this.extractSMARTGoals(domains, selectedTemplates);

      // Log audit trail
      await this.auditService.log({
        action: 'CARE_PLAN_GENERATED_FROM_ASSESSMENT',
        resourceType: 'CarePlan',
        resourceId: carePlan.id,
        userId: request.createdBy,
        details: {
          residentId: request.residentId,
          templatesUsed: selectedTemplates.map(t => t.id),
          riskLevel: riskAssessment.overallRiskLevel,
          domainsGenerated: domains.length,
          interventionsGenerated: interventions.length,
          correlationId
        },
        correlationId
      });

      // Publish event
      await this.eventPublisher.publish('care-plan.generated', {
        carePlanId: carePlan.id,
        residentId: request.residentId,
        templatesUsed: selectedTemplates.map(t => t.id),
        riskLevel: riskAssessment.overallRiskLevel,
        generatedBy: request.createdBy,
        correlationId
      });

      console.info('Care plan generated successfully', { 
        carePlanId: carePlan.id,
        correlationId 
      });

      return {
        carePlan,
        domains,
        interventions,
        smartGoals,
        riskAssessment
      };

    } catch (error: unknown) {
      console.error('Failed to generate care plan', { 
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId: request.residentId,
        correlationId 
      });

      await this.auditService.log({
        action: 'CARE_PLAN_GENERATION_FAILED',
        resourceType: 'CarePlan',
        userId: request.createdBy,
        details: {
          error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
          residentId: request.residentId,
          correlationId
        },
        correlationId
      });

      throw error;
    }
  }

  /**
   * Get available templates
   */
  async getAvailableTemplates(): Promise<CarePlanTemplate[]> {
    return this.builtInTemplates.filter(template => template.isActive);
  }

  /**
   * Get template by ID
   */
  async getTemplateById(templateId: string): Promise<CarePlanTemplate | null> {
    return this.builtInTemplates.find(template => template.id === templateId) || null;
  }

  /**
   * Validate SMART goal criteria
   */
  validateSMARTGoal(goal: SMARTGoal): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!goal.specific || goal.specific.trim().length === 0) {
      errors.push({
        property: 'specific',
        constraints: { isNotEmpty: 'Specific criteria must be defined' }
      } as ValidationError);
    }

    if (!goal.measurable || goal.measurable.trim().length === 0) {
      errors.push({
        property: 'measurable',
        constraints: { isNotEmpty: 'Measurable criteria must be defined' }
      } as ValidationError);
    }

    if (!goal.achievable || goal.achievable.trim().length === 0) {
      errors.push({
        property: 'achievable',
        constraints: { isNotEmpty: 'Achievable criteria must be defined' }
      } as ValidationError);
    }

    if (!goal.relevant || goal.relevant.trim().length === 0) {
      errors.push({
        property: 'relevant',
        constraints: { isNotEmpty: 'Relevant criteria must be defined' }
      } as ValidationError);
    }

    if (!goal.timeBound || goal.timeBound.trim().length === 0) {
      errors.push({
        property: 'timeBound',
        constraints: { isNotEmpty: 'Time-bound criteria must be defined' }
      } as ValidationError);
    }

    if (!goal.targetDate || goal.targetDate <= new Date()) {
      errors.push({
        property: 'targetDate',
        constraints: { isFutureDate: 'Target date must be in the future' }
      } as ValidationError);
    }

    return errors;
  }

  // Private helper methods

  private async selectTemplates(
    needsAssessment: ResidentNeedsAssessment,
    templateIds?: string[]
  ): Promise<CarePlanTemplate[]> {
    if (templateIds && templateIds.length > 0) {
      return this.builtInTemplates.filter(template => 
        templateIds.includes(template.id) && template.isActive
      );
    }

    // Auto-select templates based on needs assessment
    const selectedTemplates: CarePlanTemplate[] = [];

    // Check for dementia/cognitive impairment
    if (needsAssessment.cognitiveFunction !== 'intact' || 
        needsAssessment.chronicConditions.some(condition => 
          condition.toLowerCase().includes('dementia') || 
          condition.toLowerCase().includes('alzheimer')
        )) {
      const dementiaTemplate = this.builtInTemplates.find(t => t.id === 'template-dementia-care');
      if (dementiaTemplate) selectedTemplates.push(dementiaTemplate);
    }

    // Check for mobility issues
    if (needsAssessment.mobilityLevel !== 'independent' || 
        needsAssessment.fallRisk !== 'low') {
      const mobilityTemplate = this.builtInTemplates.find(t => t.id === 'template-mobility-support');
      if (mobilityTemplate) selectedTemplates.push(mobilityTemplate);
    }

    return selectedTemplates;
  }

  private performRiskAssessment(needsAssessment: ResidentNeedsAssessment): RiskAssessmentSummary {
    const criticalRisks: RiskFactor[] = [];
    const recommendedActions: string[] = [];
    const monitoringRequirements: string[] = [];

    // Assess fall risk
    if (needsAssessment.fallRisk === 'high' || needsAssessment.fallRisk === 'critical') {
      criticalRisks.push({
        riskType: 'Fall Risk',
        severity: needsAssessment.fallRisk as any,
        likelihood: 'likely',
        impact: 'severe',
        mitigationStrategies: ['Fall prevention program', 'Environmental modifications', 'Mobility aids']
      });
      recommendedActions.push('Implement comprehensive fall prevention measures');
      monitoringRequirements.push('Daily fall risk assessment');
    }

    // Assess cognitive risks
    if (needsAssessment.cognitiveFunction === 'moderate_impairment' || 
        needsAssessment.cognitiveFunction === 'severe_impairment') {
      criticalRisks.push({
        riskType: 'Cognitive Impairment',
        severity: 'high',
        likelihood: 'certain',
        impact: 'significant',
        mitigationStrategies: ['Cognitive support', 'Safety monitoring', 'Structured environment']
      });
      recommendedActions.push('Provide cognitive support and safety monitoring');
      monitoringRequirements.push('Daily cognitive status monitoring');
    }

    // Determine overall risk level
    const overallRiskLevel = this.calculateOverallRiskLevel(criticalRisks);

    // Set review date based on risk level
    const reviewDate = new Date();
    switch (overallRiskLevel) {
      case RiskLevel.CRITICAL:
        reviewDate.setDate(reviewDate.getDate() + 7); // Weekly
        break;
      case RiskLevel.HIGH:
        reviewDate.setDate(reviewDate.getDate() + 14); // Bi-weekly
        break;
      case RiskLevel.MEDIUM:
        reviewDate.setMonth(reviewDate.getMonth() + 1); // Monthly
        break;
      default:
        reviewDate.setMonth(reviewDate.getMonth() + 3); // Quarterly
    }

    return {
      overallRiskLevel,
      criticalRisks,
      recommendedActions,
      monitoringRequirements,
      reviewDate
    };
  }

  private calculateOverallRiskLevel(risks: RiskFactor[]): RiskLevel {
    if (risks.some(risk => risk.severity === 'critical')) {
      return RiskLevel.CRITICAL;
    }
    if (risks.some(risk => risk.severity === 'high')) {
      return RiskLevel.HIGH;
    }
    if (risks.some(risk => risk.severity === 'medium')) {
      return RiskLevel.MEDIUM;
    }
    return RiskLevel.LOW;
  }

  private async createCarePlanFromTemplates(
    resident: Resident,
    templates: CarePlanTemplate[],
    needsAssessment: ResidentNeedsAssessment,
    customizations: CarePlanCustomization[] | undefined,
    createdBy: string
  ): Promise<CarePlan> {
    const carePlan = new CarePlan();
    carePlan.residentId = resident.id;
    carePlan.planName = `Comprehensive Care Plan - ${resident.firstName} ${resident.lastName}`;
    carePlan.planType = 'initial';
    carePlan.status = 'draft';
    carePlan.createdBy = createdBy;
    carePlan.effectiveFrom = new Date();
    carePlan.reviewFrequency = 'monthly';
    
    // Set next review date based on risk level
    const nextReviewDate = new Date();
    nextReviewDate.setMonth(nextReviewDate.getMonth() + 1);
    carePlan.nextReviewDate = nextReviewDate;

    return await this.carePlanRepository.save(carePlan);
  }

  private async generateDomainsWithSMARTGoals(
    carePlanId: string,
    templates: CarePlanTemplate[],
    needsAssessment: ResidentNeedsAssessment,
    customizations: CarePlanCustomization[] | undefined
  ): Promise<CareDomain[]> {
    const domains: CareDomain[] = [];

    for (const template of templates) {
      for (const domainTemplate of template.domains) {
        const domain = new CareDomain();
        domain.carePlanId = carePlanId;
        domain.domainType = domainTemplate.domainType;
        domain.domainName = domainTemplate.domainName;
        domain.currentStatus = this.determineCurrentStatus(domainTemplate.domainType, needsAssessment);
        domain.riskLevel = this.determineRiskLevel(domainTemplate, needsAssessment, customizations);
        domain.monitoringFrequency = this.determineMonitoringFrequency(domainTemplate, needsAssessment, customizations);
        domain.isActive = true;

        // Add SMART goals to domain
        const smartGoals = this.generateSMARTGoalsForDomain(domainTemplate, needsAssessment, customizations);
        domain.goals = smartGoals.map(goal => ({
          id: goal.id || `goal-${Date.now()}-${Math.random()}`,
          goalName: goal.goalName,
          targetOutcome: goal.targetOutcome,
          measurementMethod: goal.measurementMethod,
          targetDate: goal.targetDate,
          isSmartGoal: true,
          specific: goal.specific,
          measurable: goal.measurable,
          achievable: goal.achievable,
          relevant: goal.relevant,
          timeBound: goal.timeBound,
          progressNotes: []
        }));

        // Schedule next assessment
        domain.scheduleNextAssessment();

        const savedDomain = await this.careDomainRepository.save(domain);
        domains.push(savedDomain);
      }
    }

    return domains;
  }

  private async generateInterventions(
    domains: CareDomain[],
    templates: CarePlanTemplate[],
    needsAssessment: ResidentNeedsAssessment
  ): Promise<CareIntervention[]> {
    const interventions: CareIntervention[] = [];

    for (const domain of domains) {
      const domainTemplate = this.findDomainTemplate(domain.domainType, templates);
      if (!domainTemplate) continue;

      for (const interventionTemplate of domainTemplate.interventions) {
        if (this.isInterventionApplicable(interventionTemplate, needsAssessment)) {
          const intervention = new CareIntervention();
          intervention.careDomainId = domain.id;
          intervention.interventionName = interventionTemplate.interventionName;
          intervention.interventionType = interventionTemplate.interventionType;
          intervention.description = interventionTemplate.description;
          intervention.frequency = interventionTemplate.frequency;
          intervention.timing = interventionTemplate.timing;
          intervention.priority = interventionTemplate.priority;
          intervention.durationMinutes = interventionTemplate.durationMinutes;
          intervention.effectiveFrom = new Date();
          intervention.isActive = true;
          intervention.isPrn = false;

          const savedIntervention = await this.careInterventionRepository.save(intervention);
          interventions.push(savedIntervention);
        }
      }
    }

    return interventions;
  }

  private generateSMARTGoalsForDomain(
    domainTemplate: CareDomainTemplate,
    needsAssessment: ResidentNeedsAssessment,
    customizations: CarePlanCustomization[] | undefined
  ): SMARTGoal[] {
    const goals: SMARTGoal[] = [];

    // Add template SMART goals
    goals.push(...domainTemplate.smartGoals);

    // Add custom SMART goals if provided
    const customization = customizations?.find(c => c.domainType === domainTemplate.domainType);
    if (customization?.customGoals) {
      goals.push(...customization.customGoals);
    }

    // Validate all SMART goals
    for (const goal of goals) {
      const validationErrors = this.validateSMARTGoal(goal);
      if (validationErrors.length > 0) {
        console.warn('SMART goal validation failed', { 
          goalName: goal.goalName,
          errors: validationErrors 
        });
      }
    }

    return goals;
  }

  private extractSMARTGoals(domains: CareDomain[], templates: CarePlanTemplate[]): SMARTGoal[] {
    const smartGoals: SMARTGoal[] = [];

    for (const domain of domains) {
      if (domain.goals) {
        for (const goal of domain.goals) {
          if (goal.isSmartGoal) {
            smartGoals.push({
              id: goal.id,
              goalName: goal.goalName,
              domainType: domain.domainType,
              specific: goal.specific,
              measurable: goal.measurable,
              achievable: goal.achievable,
              relevant: goal.relevant,
              timeBound: goal.timeBound,
              targetOutcome: goal.targetOutcome,
              measurementMethod: goal.measurementMethod,
              reviewFrequency: 'weekly', // Default
              targetDate: goal.targetDate,
              progressNotes: goal.progressNotes,
              isAchieved: goal.isAchieved,
              achievedDate: goal.achievedDate
            });
          }
        }
      }
    }

    return smartGoals;
  }

  private determineCurrentStatus(domainType: DomainType, needsAssessment: ResidentNeedsAssessment): CurrentStatus {
    switch (domainType) {
      case DomainType.MOBILITY:
        return needsAssessment.mobilityLevel === 'independent' ? CurrentStatus.STABLE : CurrentStatus.NEEDS_ATTENTION;
      case DomainType.MENTAL_HEALTH:
        return needsAssessment.cognitiveFunction === 'intact' ? CurrentStatus.STABLE : CurrentStatus.DECLINING;
      case DomainType.PERSONAL_CARE:
        return needsAssessment.adlDependency === 'independent' ? CurrentStatus.STABLE : CurrentStatus.NEEDS_ATTENTION;
      case DomainType.NUTRITION:
        return needsAssessment.nutritionalStatus === 'adequate' ? CurrentStatus.STABLE : CurrentStatus.NEEDS_ATTENTION;
      case DomainType.SOCIAL:
        return needsAssessment.socialEngagement === 'active' ? CurrentStatus.STABLE : CurrentStatus.NEEDS_ATTENTION;
      case DomainType.MEDICAL:
        return needsAssessment.chronicConditions.length === 0 ? CurrentStatus.STABLE : CurrentStatus.NEEDS_ATTENTION;
      default:
        return CurrentStatus.STABLE;
    }
  }

  private determineRiskLevel(
    domainTemplate: CareDomainTemplate,
    needsAssessment: ResidentNeedsAssessment,
    customizations: CarePlanCustomization[] | undefined
  ): RiskLevel {
    const customization = customizations?.find(c => c.domainType === domainTemplate.domainType);
    if (customization?.riskLevelOverride) {
      return customization.riskLevelOverride;
    }

    // Risk assessment based on needs assessment
    switch (domainTemplate.domainType) {
      case DomainType.MOBILITY:
        if (needsAssessment.fallRisk === 'critical') return RiskLevel.CRITICAL;
        if (needsAssessment.fallRisk === 'high') return RiskLevel.HIGH;
        if (needsAssessment.fallRisk === 'medium') return RiskLevel.MEDIUM;
        return RiskLevel.LOW;
      
      case DomainType.MENTAL_HEALTH:
        if (needsAssessment.cognitiveFunction === 'severe_impairment') return RiskLevel.CRITICAL;
        if (needsAssessment.cognitiveFunction === 'moderate_impairment') return RiskLevel.HIGH;
        if (needsAssessment.cognitiveFunction === 'mild_impairment') return RiskLevel.MEDIUM;
        return RiskLevel.LOW;
      
      default:
        return domainTemplate.defaultRiskLevel;
    }
  }

  private determineMonitoringFrequency(
    domainTemplate: CareDomainTemplate,
    needsAssessment: ResidentNeedsAssessment,
    customizations: CarePlanCustomization[] | undefined
  ): MonitoringFrequency {
    const customization = customizations?.find(c => c.domainType === domainTemplate.domainType);
    if (customization?.monitoringFrequencyOverride) {
      return customization.monitoringFrequencyOverride;
    }

    return domainTemplate.defaultMonitoringFrequency;
  }

  private findDomainTemplate(domainType: DomainType, templates: CarePlanTemplate[]): CareDomainTemplate | undefined {
    for (const template of templates) {
      const domainTemplate = template.domains.find(d => d.domainType === domainType);
      if (domainTemplate) return domainTemplate;
    }
    return undefined;
  }

  private isInterventionApplicable(
    interventionTemplate: CareInterventionTemplate,
    needsAssessment: ResidentNeedsAssessment
  ): boolean {
    if (!interventionTemplate.applicableWhen || interventionTemplate.applicableWhen.length === 0) {
      return true; // Always applicable if no conditions specified
    }

    // Check if any of the applicable conditions are met
    return interventionTemplate.applicableWhen.some(condition => {
      switch (condition) {
        case 'cognitive_impairment':
          return needsAssessment.cognitiveFunction !== 'intact';
        case 'fall_risk':
          return needsAssessment.fallRisk !== 'low';
        case 'adl_dependency':
          return needsAssessment.adlDependency !== 'independent';
        case 'mobility_impairment':
          return needsAssessment.mobilityLevel !== 'independent';
        default:
          return false;
      }
    });
  }
}