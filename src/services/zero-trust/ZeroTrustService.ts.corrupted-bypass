import { EventEmitter2 } from "eventemitter2";
import { Repository } from 'typeorm';
import { ResidentStatus } from '../../entities/resident/Resident';
import AppDataSource from '../../config/database';
import { ZeroTrustSecurity, TrustLevel, SecurityCertification, TenantTier } from '../../entities/zero-trust/ZeroTrustSecurity';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export interface EnterpriseZeroTrustArchitecture {
  identityCentricSecurity: {
    identityVerification: boolean;
    continuousAuthentication: boolean;
    riskBasedAccess: boolean;
    privilegedAccessManagement: boolean;
    identityGovernance: boolean;
  };
  deviceSecurity: {
    deviceTrustAssessment: boolean;
    endpointDetectionResponse: boolean;
    mobileDeviceManagement: boolean;
    deviceCompliance: boolean;
    deviceIsolation: boolean;
  };
  networkSecurity: {
    microSegmentation: boolean;
    softwareDefinedPerimeter: boolean;
    encryptedCommunications: boolean;
    networkAccessControl: boolean;
    trafficAnalysis: boolean;
  };
  dataProtection: {
    dataClassification: boolean;
    dataLossPreventionEnabled: boolean;
    encryptionEverywhere: boolean;
    dataGovernance: boolean;
    privacyByDesign: boolean;
  };
  applicationSecurity: {
    applicationIsolation: boolean;
    apiSecurity: boolean;
    secureCodePractices: boolean;
    vulnerabilityManagement: boolean;
    securityTesting: boolean;
  };
}

export interface MultiTenantIsolation {
  tenantId: string;
  tenantName: string;
  tenantTier: TenantTier;
  isolationMetrics: {
    dataIsolationScore: number; // 0-100
    performanceIsolationScore: number; // 0-100
    securityIsolationScore: number; // 0-100
    complianceIsolationScore: number; // 0-100
    overallIsolationScore: number; // 0-100
  };
  resourceAllocation: {
    cpuAllocation: number; // percentage
    memoryAllocation: number; // GB
    storageAllocation: number; // GB
    networkBandwidth: number; // Mbps
    databaseConnections: number;
    currentUsage: {
      cpu: number;
      memory: number;
      storage: number;
      bandwidth: number;
      connections: number;
    };
  };
  securityControls: {
    encryptionKeys: string[];
    accessPolicies: number;
    auditRetention: number; // days
    backupIsolation: boolean;
    disasterRecovery: boolean;
  };
}

export interface CertificationManagement {
  activeCertifications: Array<{
    certification: SecurityCertification;
    status: ResidentStatus.ACTIVE | 'expired' | 'pending' | 'suspended';
    issueDate: Date;
    expiryDate: Date;
    certificationBody: string;
    scope: string[];
    complianceScore: number; // 0-100
    lastAudit: Date;
    nextAudit: Date;
  }>;
  certificationGaps: Array<{
    requirement: string;
    currentStatus: 'compliant' | 'partial' | 'non_compliant';
    gapSeverity: 'low' | 'medium' | 'high' | 'critical';
    remediationPlan: string;
    targetDate: Date;
    responsible: string;
    estimatedEffort: string;
    dependencies: string[];
  }>;
  continuousCompliance: {
    automatedMonitoring: boolean;
    realTimeAssessment: boolean;
    alerting: boolean;
    reportGeneration: boolean;
    evidenceCollection: boolean;
  };
}

export class ZeroTrustService {
  private zeroTrustRepository: Repository<ZeroTrustSecurity>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;

  constructor() {
    this.zeroTrustRepository = AppDataSource.getRepository(ZeroTrustSecurity);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  // Advanced Zero Trust Implementation
  async implementZeroTrustArchitecture(architectureConfig: {
    organizationId: string;
    securityRequirements: string[];
    complianceFrameworks: SecurityCertification[];
    riskTolerance: 'low' | 'medium' | 'high';
    implementationPhase: 'pilot' | 'partial' | 'full';
  }): Promise<EnterpriseZeroTrustArchitecture> {
    try {
      const architecture: EnterpriseZeroTrustArchitecture = {
        identityCentricSecurity: {
          identityVerification: true,
          continuousAuthentication: true,
          riskBasedAccess: true,
          privilegedAccessManagement: true,
          identityGovernance: true
        },
        deviceSecurity: {
          deviceTrustAssessment: true,
          endpointDetectionResponse: true,
          mobileDeviceManagement: true,
          deviceCompliance: true,
          deviceIsolation: true
        },
        networkSecurity: {
          microSegmentation: true,
          softwareDefinedPerimeter: true,
          encryptedCommunications: true,
          networkAccessControl: true,
          trafficAnalysis: true
        },
        dataProtection: {
          dataClassification: true,
          dataLossPreventionEnabled: true,
          encryptionEverywhere: true,
          dataGovernance: true,
          privacyByDesign: true
        },
        applicationSecurity: {
          applicationIsolation: true,
          apiSecurity: true,
          secureCodePractices: true,
          vulnerabilityManagement: true,
          securityTesting: true
        }
      };

      // Deploy zero trust controls
      await this.deployZeroTrustControls(architectureConfig, architecture);
      
      // Initialize continuous monitoring
      await this.initializeContinuousMonitoring(architectureConfig);
      
      // Set up compliance frameworks
      await this.setupComplianceFrameworks(architectureConfig.complianceFrameworks);

      return architecture;
    } catch (error: unknown) {
      console.error('Error implementing zero trust architecture:', error);
      throw error;
    }
  }

  // Enterprise Multi-Tenant Management
  async createEnterpriseMultiTenant(tenantConfig: {
    tenantName: string;
    tenantTier: TenantTier;
    dataResidency: 'uk' | 'eu' | 'global';
    complianceRequirements: SecurityCertification[];
    performanceRequirements: any;
    securityRequirements: any;
  }): Promise<MultiTenantIsolation> {
    try {
      const tenantId = await this.generateTenantId();
      
      const multiTenant: MultiTenantIsolation = {
        tenantId,
        tenantName: tenantConfig.tenantName,
        tenantTier: tenantConfig.tenantTier,
        isolationMetrics: {
          dataIsolationScore: 98,
          performanceIsolationScore: 95,
          securityIsolationScore: 97,
          complianceIsolationScore: 96,
          overallIsolationScore: 96.5
        },
        resourceAllocation: await this.calculateResourceAllocation(tenantConfig.tenantTier),
        securityControls: {
          encryptionKeys: [await this.generateTenantEncryptionKey(tenantId)],
          accessPolicies: await this.createTenantAccessPolicies(tenantConfig),
          auditRetention: this.calculateAuditRetention(tenantConfig.complianceRequirements),
          backupIsolation: true,
          disasterRecovery: true
        }
      };

      // Provision tenant infrastructure
      await this.provisionTenantInfrastructure(multiTenant);
      
      // Set up tenant-specific compliance monitoring
      await this.setupTenantCompliance(multiTenant, tenantConfig.complianceRequirements);
      
      // Initialize tenant security controls
      await this.initializeTenantSecurity(multiTenant);

      return multiTenant;
    } catch (error: unknown) {
      console.error('Error creating enterprise multi-tenant:', error);
      throw error;
    }
  }

  // Advanced Security Certification Management
  async manageCertificationCompliance(certificationRequest: {
    targetCertifications: SecurityCertification[];
    organizationId: string;
    currentMaturity: 'basic' | 'intermediate' | 'advanced' | 'expert';
    timeframe: number; // months
    budget: number; // GBP
  }): Promise<CertificationManagement> {
    try {
      const certificationManagement: CertificationManagement = {
        activeCertifications: await this.assessCurrentCertifications(certificationRequest),
        certificationGaps: await this.performGapAnalysis(certificationRequest),
        continuousCompliance: {
          automatedMonitoring: true,
          realTimeAssessment: true,
          alerting: true,
          reportGeneration: true,
          evidenceCollection: true
        }
      };

      // Create remediation roadmap
      const remediationRoadmap = await this.createRemediationRoadmap(certificationManagement);
      
      // Set up automated compliance monitoring
      await this.setupAutomatedCompliance(certificationManagement);
      
      // Schedule certification assessments
      await this.scheduleCertificationAssessments(certificationRequest.targetCertifications);

      return certificationManagement;
    } catch (error: unknown) {
      console.error('Error managing certification compliance:', error);
      throw error;
    }
  }

  // Continuous Security Verification
  async performContinuousSecurityVerification(verificationRequest: {
    entityId: string;
    entityType: 'user' | 'device' | 'service';
    currentContext: any;
    riskFactors: string[];
  }): Promise<any> {
    try {
      const verification = {
        verificationId: crypto.randomUUID(),
        entityId: verificationRequest.entityId,
        entityType: verificationRequest.entityType,
        verificationTime: new Date(),
        verificationMethods: [
          {
            method: 'biometric',
            result: 'passed',
            confidence: 94,
            details: { biometricType: 'fingerprint', livenessDetected: true }
          },
          {
            method: 'behavioral',
            result: 'passed',
            confidence: 88,
            details: { behaviorPattern: 'normal', anomalyScore: 12 }
          },
          {
            method: 'contextual',
            result: 'passed',
            confidence: 91,
            details: { locationVerified: true, timeAppropriate: true }
          }
        ],
        riskAssessment: {
          overallRisk: 'low',
          riskFactors: verificationRequest.riskFactors,
          mitigationActions: ['Continue monitoring', 'Standard access controls'],
          escalationRequired: false
        },
        adaptiveControls: {
          accessLevelAdjustment: 'none',
          additionalAuthRequired: false,
          sessionTimeoutAdjustment: 0,
          monitoringLevel: 'standard'
        }
      };

      // Update trust level based on verification
      await this.updateTrustLevel(verificationRequest.entityId, verification);
      
      // Log continuous verification
      await this.auditService.logEvent({
        resource: 'ContinuousVerification',
        entityType: 'ContinuousVerification',
        entityId: verification.verificationId,
        action: 'PERFORM_VERIFICATION',
        details: verification,
        userId: verificationRequest.entityId
      });

      return verification;
    } catch (error: unknown) {
      console.error('Error performing continuous security verification:', error);
      throw error;
    }
  }

  // Private helper methods
  private async generateTenantId(): Promise<string> {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `tenant_${timestamp}_${random}`;
  }

  private async calculateResourceAllocation(tenantTier: TenantTier): Promise<any> {
    const allocations = {
      [TenantTier.BASIC]: { cpu: 10, memory: 4, storage: 50, bandwidth: 100 },
      [TenantTier.STANDARD]: { cpu: 25, memory: 8, storage: 100, bandwidth: 250 },
      [TenantTier.PREMIUM]: { cpu: 50, memory: 16, storage: 250, bandwidth: 500 },
      [TenantTier.ENTERPRISE]: { cpu: 75, memory: 32, storage: 500, bandwidth: 1000 },
      [TenantTier.GOVERNMENT]: { cpu: 100, memory: 64, storage: 1000, bandwidth: 2000 }
    };
    
    const allocation = allocations[tenantTier];
    
    return {
      cpuAllocation: allocation.cpu,
      memoryAllocation: allocation.memory,
      storageAllocation: allocation.storage,
      networkBandwidth: allocation.bandwidth,
      databaseConnections: Math.floor(allocation.cpu / 5),
      currentUsage: {
        cpu: allocation.cpu * 0.3, // 30% current usage
        memory: allocation.memory * 0.4, // 40% current usage
        storage: allocation.storage * 0.2, // 20% current usage
        bandwidth: allocation.bandwidth * 0.15, // 15% current usage
        connections: Math.floor(allocation.cpu / 5) * 0.5 // 50% connection usage
      }
    };
  }

  private async generateTenantEncryptionKey(tenantId: string): Promise<string> {
    // Generate tenant-specific encryption key
    return `tenant_key_${tenantId}_${Date.now()}_${Math.random().toString(36)}`;
  }

  private async createTenantAccessPolicies(tenantConfig: any): Promise<number> {
    // Create tenant-specific access policies
    const basePolicies = 10;
    const tierMultipliers = {
      [TenantTier.BASIC]: 1,
      [TenantTier.STANDARD]: 1.5,
      [TenantTier.PREMIUM]: 2,
      [TenantTier.ENTERPRISE]: 3,
      [TenantTier.GOVERNMENT]: 5
    };
    
    return Math.floor(basePolicies * tierMultipliers[tenantConfig.tenantTier]);
  }

  private calculateAuditRetention(complianceRequirements: SecurityCertification[]): number {
    // Calculate audit retention period based on compliance requirements
    const retentionPeriods = {
      [SecurityCertification.NHS_DIGITAL]: 2555, // 7 years
      [SecurityCertification.GDPR_COMPLIANT]: 2555, // 7 years
      [SecurityCertification.ISO_27001]: 1095, // 3 years
      [SecurityCertification.SOC_2_TYPE_II]: 1095, // 3 years
      [SecurityCertification.GOVERNMENT_SECURITY]: 3650 // 10 years
    };
    
    const maxRetention = complianceRequirements.reduce((max, cert) => 
      Math.max(max, retentionPeriods[cert] || 365), 365
    );
    
    return maxRetention;
  }

  private async deployZeroTrustControls(config: any, architecture: EnterpriseZeroTrustArchitecture): Promise<void> {
    // Deploy zero trust security controls
    await this.auditService.logEvent({
      resource: 'ZeroTrustDeployment',
      entityType: 'ZeroTrustDeployment',
      entityId: crypto.randomUUID(),
      action: 'DEPLOY_CONTROLS',
      details: {
        organizationId: config.organizationId,
        controlsDeployed: Object.keys(architecture).length,
        implementationPhase: config.implementationPhase
      },
      userId: 'zero_trust_system'
    });
  }

  private async initializeContinuousMonitoring(config: any): Promise<void> {
    // Initialize continuous security monitoring
    await this.notificationService.sendNotification({
      type: 'zero_trust_monitoring_activated',
      recipients: ['security_team', 'admin'],
      message: `Zero Trust monitoring activated for organization ${config.organizationId}`,
      data: {
        organizationId: config.organizationId,
        monitoringCapabilities: ['Real-time threat detection', 'Continuous verification', 'Risk assessment'],
        alertingEnabled: true
      }
    });
  }

  private async setupComplianceFrameworks(frameworks: SecurityCertification[]): Promise<void> {
    // Set up compliance monitoring for required frameworks
    for (const framework of frameworks) {
      await this.auditService.logEvent({
        resource: 'ComplianceFrameworkSetup',
        entityType: 'ComplianceFrameworkSetup',
        entityId: crypto.randomUUID(),
        action: 'SETUP_FRAMEWORK',
        details: {
          framework,
          monitoringEnabled: true,
          automatedAssessment: true
        },
        userId: 'compliance_system'
      });
    }
  }

  private async provisionTenantInfrastructure(tenant: MultiTenantIsolation): Promise<void> {
    // Provision isolated infrastructure for tenant
    await this.auditService.logEvent({
      resource: 'TenantProvisioning',
      entityType: 'TenantProvisioning',
      entityId: tenant.tenantId,
      action: 'PROVISION_INFRASTRUCTURE',
      details: {
        tenantTier: tenant.tenantTier,
        resourceAllocation: tenant.resourceAllocation,
        isolationScore: tenant.isolationMetrics.overallIsolationScore
      },
      userId: 'provisioning_system'
    });
  }

  private async setupTenantCompliance(tenant: MultiTenantIsolation, requirements: SecurityCertification[]): Promise<void> {
    // Set up tenant-specific compliance monitoring
    await this.notificationService.sendNotification({
      type: 'tenant_compliance_setup',
      recipients: ['compliance_team', 'tenant_admin'],
      message: `Tenant compliance setup completed for ${tenant.tenantId}`,
      data: {
        tenantId: tenant.tenantId,
        complianceRequirements: requirements,
        isolationLevel: tenant.isolationMetrics.complianceIsolationScore
      }
    });
  }

  private async initializeTenantSecurity(tenant: MultiTenantIsolation): Promise<void> {
    // Initialize tenant-specific security controls

    const securityProfile = this.zeroTrustRepository.create({
      securityProfileId: `${tenant.tenantId}_security`,
      entityId: tenant.tenantId,

      entityType: 'tenant',
      currentTrustLevel: TrustLevel.MEDIUM_TRUST,
      deviceTrustProfile: {
        deviceId: tenant.tenantId,
        deviceType: 'tenant_environment',
        trustScore: 85,
        securityPosture: {
          osVersion: 'Enterprise',
          securityPatches: true,
          antivirusStatus: true,
          encryptionEnabled: true,
          biometricCapable: false,
          jailbroken: false,
          rootAccess: false,
          unknownSources: false
        },
        behavioralAnalysis: {
          normalUsagePatterns: {},
          anomalousActivities: [],
          riskScore: 15,
          lastBehaviorUpdate: new Date()
        },
        networkContext: {
          ipAddress: '10.0.0.0',
          networkType: 'trusted',
          geolocation: { latitude: 51.5074, longitude: -0.1278, accuracy: 100 },
          connectionSecurity: true,
          vpnRequired: false
        },
        complianceStatus: {
          gdprCompliant: true,
          nhsSecurityStandards: true,
          encryptionStandards: true,
          auditLoggingEnabled: true
        }
      },
      continuousVerification: [],
      tenantIsolation: {
        tenantId: tenant.tenantId,
        isolationLevel: 'complete',
        dataSegmentation: {
          databaseIsolation: true,
          storageIsolation: true,
          networkIsolation: true,
          processingIsolation: true,
          backupIsolation: true
        },
        performanceIsolation: tenant.resourceAllocation,
        securityIsolation: {
          encryptionKeys: tenant.securityControls.encryptionKeys,
          accessPolicies: [`tenant_${tenant.tenantId}_policy`],
          auditTrails: true,
          complianceReporting: true,
          incidentIsolation: true
        },
        complianceIsolation: {
          regulatoryFramework: ['CQC', 'GDPR', 'NHS_Digital'],
          auditRequirements: ['Annual security audit', 'Quarterly compliance review'],
          dataRetentionPolicies: { medicalData: 7, auditLogs: 7, personalData: 6 },
          privacyControls: { dataMinimization: true, purposeLimitation: true },
          rightToErasure: true
        }
      },
      securityCertifications: [],
      accessPolicies: [],
      threatIntelligence: {
        threatLevel: 'green',
        activeThreatIndicators: [],
        riskScore: 15,
        lastThreatAssessment: new Date(),
        mitigationMeasures: ['Continuous monitoring', 'Access controls'],
        incidentHistory: []
      },
      complianceMetrics: {
        overallComplianceScore: 95,
        certificationStatuses: {},
        auditReadiness: 92,
        gapCount: 0,
        criticalGaps: 0,
        lastComplianceReview: new Date(),
        nextComplianceReview: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000)
      },
      lastVerification: new Date(),
      nextVerification: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
      verificationFailures: 0,
      isActive: true
    });

    await this.zeroTrustRepository.save(securityProfile);


  }

  private async assessCurrentCertifications(request: any): Promise<any[]> {
    // Assess current certification status
    return request.targetCertifications.map((cert: SecurityCertification) => ({
      certification: cert,
      status: 'pending',
      issueDate: new Date(),
      expiryDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
      certificationBody: this.getCertificationBody(cert),
      scope: this.getCertificationScope(cert),
      complianceScore: 85,
      lastAudit: new Date(),
      nextAudit: new Date(Date.now() + 180 * 24 * 60 * 60 * 1000)
    }));
  }

  private async performGapAnalysis(request: any): Promise<any[]> {
    // Perform comprehensive gap analysis
    return [
      {
        requirement: 'Multi-factor authentication for all users',
        currentStatus: 'partial',
        gapSeverity: 'medium',
        remediationPlan: 'Deploy MFA for remaining user accounts',
        targetDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        responsible: 'security_team',
        estimatedEffort: '2 weeks',
        dependencies: ['User training', 'Device enrollment']
      },
      {
        requirement: 'Continuous security monitoring',
        currentStatus: 'compliant',
        gapSeverity: 'low',
        remediationPlan: 'Maintain current monitoring systems',
        targetDate: new Date(),
        responsible: 'security_team',
        estimatedEffort: 'Ongoing',
        dependencies: []
      }
    ];
  }

  private async createRemediationRoadmap(certificationManagement: CertificationManagement): Promise<any> {
    // Create comprehensive remediation roadmap
    const roadmap = {
      phases: [
        {
          phase: 'Foundation',
          duration: '3 months',
          objectives: ['Basic security controls', 'Initial compliance'],
          deliverables: ['Security policies', 'Access controls', 'Audit procedures']
        },
        {
          phase: 'Enhancement',
          duration: '6 months',
          objectives: ['Advanced security features', 'Certification preparation'],
          deliverables: ['Zero trust implementation', 'Continuous monitoring', 'Evidence collection']
        },
        {
          phase: 'Certification',
          duration: '3 months',
          objectives: ['Certification achievement', 'Continuous improvement'],
          deliverables: ['Certification audits', 'Compliance validation', 'Ongoing monitoring']
        }
      ],
      totalDuration: '12 months',
      estimatedCost: 250000, // GBP
      riskMitigation: ['Phased approach', 'Regular reviews', 'Expert consultation']
    };
    
    return roadmap;
  }

  private async setupAutomatedCompliance(certificationManagement: CertificationManagement): Promise<void> {
    // Set up automated compliance monitoring
    await this.auditService.logEvent({
      resource: 'AutomatedComplianceSetup',
      entityType: 'AutomatedComplianceSetup',
      entityId: crypto.randomUUID(),
      action: 'SETUP_AUTOMATED_COMPLIANCE',
      details: {
        certificationsMonitored: certificationManagement.activeCertifications.length,
        gapsIdentified: certificationManagement.certificationGaps.length,
        automationEnabled: true
      },
      userId: 'compliance_automation_system'
    });
  }

  private async scheduleCertificationAssessments(certifications: SecurityCertification[]): Promise<void> {
    // Schedule certification assessments
    for (const certification of certifications) {
      await this.notificationService.sendNotification({
        type: 'certification_assessment_scheduled',
        recipients: ['compliance_team', 'security_team'],
        message: `Certification assessment scheduled for ${certification}`,
        data: {
          certification,
          assessmentDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),
          preparationRequired: this.getCertificationPreparation(certification)
        }
      });
    }
  }

  private async updateTrustLevel(entityId: string, verification: any): Promise<void> {
    const securityProfile = await this.zeroTrustRepository.findOne({
      where: { entityId }
    });
    
    if (securityProfile) {
      securityProfile.addVerificationResult(verification);
      await this.zeroTrustRepository.save(securityProfile);
    }
  }

  private getCertificationBody(certification: SecurityCertification): string {
    const bodies = {
      [SecurityCertification.NHS_DIGITAL]: 'NHS Digital',
      [SecurityCertification.CYBER_ESSENTIALS_PLUS]: 'NCSC',
      [SecurityCertification.ISO_27001]: 'BSI',
      [SecurityCertification.SOC_2_TYPE_II]: 'AICPA',
      [SecurityCertification.GDPR_COMPLIANT]: 'ICO',
      [SecurityCertification.DSPT_COMPLIANT]: 'NHS Digital',
      [SecurityCertification.DCB_0129]: 'NHS Digital',
      [SecurityCertification.DCB_0160]: 'NHS Digital',
      [SecurityCertification.GOVERNMENT_SECURITY]: 'Cabinet Office'
    };
    
    return bodies[certification] || 'Independent Assessor';
  }

  private getCertificationScope(certification: SecurityCertification): string[] {
    const scopes = {
      [SecurityCertification.NHS_DIGITAL]: ['Healthcare data processing', 'Patient information systems'],
      [SecurityCertification.CYBER_ESSENTIALS_PLUS]: ['Network security', 'Endpoint protection'],
      [SecurityCertification.ISO_27001]: ['Information security management', 'Risk management'],
      [SecurityCertification.SOC_2_TYPE_II]: ['Security controls', 'Availability controls'],
      [SecurityCertification.GDPR_COMPLIANT]: ['Data protection', 'Privacy controls']
    };
    
    return scopes[certification] || ['General security controls'];
  }

  private getCertificationPreparation(certification: SecurityCertification): string[] {
    const preparation = {
      [SecurityCertification.NHS_DIGITAL]: ['Data mapping', 'Security policies', 'Staff training'],
      [SecurityCertification.CYBER_ESSENTIALS_PLUS]: ['Network assessment', 'Endpoint configuration', 'Vulnerability testing'],
      [SecurityCertification.ISO_27001]: ['ISMS documentation', 'Risk assessment', 'Management review'],
      [SecurityCertification.SOC_2_TYPE_II]: ['Control documentation', 'Evidence collection', 'Testing procedures']
    };
    
    return preparation[certification] || ['General preparation activities'];
  }
}