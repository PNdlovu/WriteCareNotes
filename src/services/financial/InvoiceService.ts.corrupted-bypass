import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Invoice Service for WriteCareNotes
 * @module InvoiceService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive invoice management service with healthcare billing features,
 * payment tracking, and compliance reporting for care home operations.
 * 
 * @compliance
 * - PCI DSS (Payment Card Industry Data Security Standard)
 * - SOX (Sarbanes-Oxley Act) compliance
 * - GDPR Article 6 & 9 (Financial data processing)
 * - FCA (Financial Conduct Authority) regulations
 * - NHS Digital standards for healthcare billing
 */

import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, In, Like, IsNull, Not } from 'typeorm';
import { Decimal } from 'decimal.js';
import * as dayjs from 'dayjs';

import { Invoice, InvoiceStatus, InvoiceType, PaymentTerms } from '@/entities/financial/Invoice';
import { Payment, PaymentStatus, PaymentMethod } from '@/entities/financial/Payment';
import { ChartOfAccounts } from '@/entities/financial/ChartOfAccounts';
import { FinancialTransaction } from '@/entities/financial/FinancialTransaction';
import { HealthcareEncryption } from '@/utils/encryption';
import { logger as appLogger } from '@/utils/logger';

export interface CreateInvoiceRequest {
  invoiceType: InvoiceType;
  residentId?: string;
  billingEntityId?: string;
  billingAddress: string;
  billingEmail?: string;
  billingPhone?: string;
  description: string;
  detailedDescription?: string;
  subtotal: number;
  taxRate?: number;
  paymentTerms?: PaymentTerms;
  dueDate?: Date;
  reference?: string;
  purchaseOrderNumber?: string;
  notes?: string;
  termsAndConditions?: string;
  isVATApplicable?: boolean;
  vatNumber?: string;
  costCenter?: string;
  departmentId?: string;
  projectCode?: string;
  createdBy: string;
}

export interface UpdateInvoiceRequest {
  description?: string;
  detailedDescription?: string;
  subtotal?: number;
  taxRate?: number;
  paymentTerms?: PaymentTerms;
  dueDate?: Date;
  reference?: string;
  purchaseOrderNumber?: string;
  notes?: string;
  termsAndConditions?: string;
  isVATApplicable?: boolean;
  vatNumber?: string;
  updatedBy: string;
}

export interface InvoiceFilters {
  status?: InvoiceStatus[];
  invoiceType?: InvoiceType[];
  residentId?: string;
  billingEntityId?: string;
  dateFrom?: Date;
  dateTo?: Date;
  amountFrom?: number;
  amountTo?: number;
  isOverdue?: boolean;
  isPaid?: boolean;
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
}

export interface InvoiceListResponse {
  invoices: Invoice[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  summary: {
    totalAmount: string;
    paidAmount: string;
    outstandingAmount: string;
    overdueAmount: string;
    overdueCount: number;
  };
}

export interface PaymentRequest {
  invoiceId: string;
  amount: number;
  paymentMethod: PaymentMethod;
  paymentDate: Date;
  reference?: string;
  notes?: string;
  cardLastFour?: string;
  cardExpiry?: string;
  bankAccountLastFour?: string;
  sortCode?: string;
  providerTransactionId?: string;
  providerReference?: string;
  providerName?: string;
  processedBy: string;
}

@Injectable()
export class InvoiceService {
  private readonly logger = new Logger(InvoiceService.name);

  constructor(
    @InjectRepository(Invoice)
    private invoiceRepository: Repository<Invoice>,
    @InjectRepository(Payment)
    private paymentRepository: Repository<Payment>,
    @InjectRepository(ChartOfAccounts)
    private chartOfAccountsRepository: Repository<ChartOfAccounts>,
    @InjectRepository(FinancialTransaction)
    private financialTransactionRepository: Repository<FinancialTransaction>,
  ) {}

  /**
   * Create a new invoice
   */
  async createInvoice(request: CreateInvoiceRequest): Promise<Invoice> {
    this.logger.log(`Creating invoice for ${request.invoiceType}`);
    
    try {
      // Validate request
      this.validateCreateInvoiceRequest(request);

      // Get default account for invoice type
      const account = await this.getAccountForInvoiceType(request.invoiceType);
      if (!account) {
        throw new Error(`No account found for invoice type: ${request.invoiceType}`);
      }

      // Calculate due date if not provided
      const dueDate = request.dueDate || this.calculateDueDate(request.paymentTerms);

      // Create invoice
      const invoice = this.invoiceRepository.create({
        invoiceType: request.invoiceType,
        residentId: request.residentId,
        billingEntityId: request.billingEntityId,
        billingAddress: request.billingAddress,
        billingEmail: request.billingEmail,
        billingPhone: request.billingPhone,
        description: request.description,
        detailedDescription: request.detailedDescription,
        subtotal: new Decimal(request.subtotal),
        taxRate: new Decimal(request.taxRate || 0),
        paymentTerms: request.paymentTerms || PaymentTerms.NET_30,
        dueDate,
        reference: request.reference,
        purchaseOrderNumber: request.purchaseOrderNumber,
        notes: request.notes,
        termsAndConditions: request.termsAndConditions,
        isVATApplicable: request.isVATApplicable || false,
        vatNumber: request.vatNumber,
        costCenter: request.costCenter,
        departmentId: request.departmentId,
        projectCode: request.projectCode,
        accountId: account.id,
        createdBy: request.createdBy,
        status: InvoiceStatus.DRAFT,
        invoiceDate: new Date(),
        currency: 'GBP',
      });

      const savedInvoice = await this.invoiceRepository.save(invoice);

      // Create financial transaction
      await this.createFinancialTransaction(savedInvoice);

      this.logger.log(`Invoice created successfully: ${savedInvoice.id}`);
      return savedInvoice;

    } catch (error) {
      this.logger.error(`Failed to create invoice: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Update an existing invoice
   */
  async updateInvoice(invoiceId: string, request: UpdateInvoiceRequest): Promise<Invoice> {
    this.logger.log(`Updating invoice: ${invoiceId}`);
    
    try {
      const invoice = await this.getInvoiceById(invoiceId);
      if (!invoice) {
        throw new Error('Invoice not found');
      }

      if (invoice.status !== InvoiceStatus.DRAFT) {
        throw new Error('Only draft invoices can be updated');
      }

      // Update fields
      if (request.description !== undefined) invoice.description = request.description;
      if (request.detailedDescription !== undefined) invoice.detailedDescription = request.detailedDescription;
      if (request.subtotal !== undefined) invoice.subtotal = new Decimal(request.subtotal);
      if (request.taxRate !== undefined) invoice.taxRate = new Decimal(request.taxRate);
      if (request.paymentTerms !== undefined) invoice.paymentTerms = request.paymentTerms;
      if (request.dueDate !== undefined) invoice.dueDate = request.dueDate;
      if (request.reference !== undefined) invoice.reference = request.reference;
      if (request.purchaseOrderNumber !== undefined) invoice.purchaseOrderNumber = request.purchaseOrderNumber;
      if (request.notes !== undefined) invoice.notes = request.notes;
      if (request.termsAndConditions !== undefined) invoice.termsAndConditions = request.termsAndConditions;
      if (request.isVATApplicable !== undefined) invoice.isVATApplicable = request.isVATApplicable;
      if (request.vatNumber !== undefined) invoice.vatNumber = request.vatNumber;

      invoice.updatedBy = request.updatedBy;

      const updatedInvoice = await this.invoiceRepository.save(invoice);

      this.logger.log(`Invoice updated successfully: ${invoiceId}`);
      return updatedInvoice;

    } catch (error) {
      this.logger.error(`Failed to update invoice: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Get invoice by ID
   */
  async getInvoiceById(invoiceId: string): Promise<Invoice | null> {
    return await this.invoiceRepository.findOne({
      where: { id: invoiceId },
      relations: ['payments', 'account'],
    });
  }

  /**
   * List invoices with filters and pagination
   */
  async listInvoices(filters: InvoiceFilters = {}): Promise<InvoiceListResponse> {
    this.logger.log('Listing invoices with filters');
    
    try {
      const query = this.invoiceRepository.createQueryBuilder('invoice')
        .leftJoinAndSelect('invoice.payments', 'payments')
        .leftJoinAndSelect('invoice.account', 'account');

      // Apply filters
      if (filters.status && filters.status.length > 0) {
        query.andWhere('invoice.status IN (:...status)', { status: filters.status });
      }

      if (filters.invoiceType && filters.invoiceType.length > 0) {
        query.andWhere('invoice.invoiceType IN (:...invoiceType)', { invoiceType: filters.invoiceType });
      }

      if (filters.residentId) {
        query.andWhere('invoice.residentId = :residentId', { residentId: filters.residentId });
      }

      if (filters.billingEntityId) {
        query.andWhere('invoice.billingEntityId = :billingEntityId', { billingEntityId: filters.billingEntityId });
      }

      if (filters.dateFrom) {
        query.andWhere('invoice.invoiceDate >= :dateFrom', { dateFrom: filters.dateFrom });
      }

      if (filters.dateTo) {
        query.andWhere('invoice.invoiceDate <= :dateTo', { dateTo: filters.dateTo });
      }

      if (filters.amountFrom) {
        query.andWhere('invoice.totalAmount >= :amountFrom', { amountFrom: filters.amountFrom });
      }

      if (filters.amountTo) {
        query.andWhere('invoice.totalAmount <= :amountTo', { amountTo: filters.amountTo });
      }

      if (filters.isOverdue) {
        query.andWhere('invoice.daysOverdue > 0');
      }

      if (filters.isPaid !== undefined) {
        if (filters.isPaid) {
          query.andWhere('invoice.status = :paidStatus', { paidStatus: InvoiceStatus.PAID });
        } else {
          query.andWhere('invoice.status != :paidStatus', { paidStatus: InvoiceStatus.PAID });
        }
      }

      if (filters.search) {
        query.andWhere(
          '(invoice.invoiceNumber ILIKE :search OR invoice.description ILIKE :search OR invoice.reference ILIKE :search)',
          { search: `%${filters.search}%` }
        );
      }

      // Apply sorting
      const sortBy = filters.sortBy || 'invoiceDate';
      const sortOrder = filters.sortOrder || 'DESC';
      query.orderBy(`invoice.${sortBy}`, sortOrder);

      // Apply pagination
      const page = filters.page || 1;
      const limit = filters.limit || 20;
      const offset = (page - 1) * limit;

      query.skip(offset).take(limit);

      const [invoices, total] = await query.getManyAndCount();

      // Calculate summary
      const summary = await this.calculateInvoiceSummary(filters);

      return {
        invoices,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
        summary,
      };

    } catch (error) {
      this.logger.error(`Failed to list invoices: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Send invoice to customer
   */
  async sendInvoice(invoiceId: string, sentBy: string): Promise<Invoice> {
    this.logger.log(`Sending invoice: ${invoiceId}`);
    
    try {
      const invoice = await this.getInvoiceById(invoiceId);
      if (!invoice) {
        throw new Error('Invoice not found');
      }

      if (invoice.status !== InvoiceStatus.DRAFT) {
        throw new Error('Only draft invoices can be sent');
      }

      invoice.markAsSent();
      invoice.updatedBy = sentBy;

      const updatedInvoice = await this.invoiceRepository.save(invoice);

      // TODO: Send email notification to customer
      // await this.notificationService.sendInvoiceEmail(invoice);

      this.logger.log(`Invoice sent successfully: ${invoiceId}`);
      return updatedInvoice;

    } catch (error) {
      this.logger.error(`Failed to send invoice: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Record payment for invoice
   */
  async recordPayment(request: PaymentRequest): Promise<Payment> {
    this.logger.log(`Recording payment for invoice: ${request.invoiceId}`);
    
    try {
      const invoice = await this.getInvoiceById(request.invoiceId);
      if (!invoice) {
        throw new Error('Invoice not found');
      }

      if (invoice.status === InvoiceStatus.CANCELLED) {
        throw new Error('Cannot record payment for cancelled invoice');
      }

      const paymentAmount = new Decimal(request.amount);
      if (paymentAmount.lessThanOrEqualTo(0)) {
        throw new Error('Payment amount must be positive');
      }

      if (paymentAmount.greaterThan(invoice.balanceAmount)) {
        throw new Error('Payment amount cannot exceed invoice balance');
      }

      // Create payment record
      const payment = this.paymentRepository.create({
        invoiceId: request.invoiceId,
        paymentType: 'invoice_payment',
        paymentMethod: request.paymentMethod,
        amount: paymentAmount,
        paymentDate: request.paymentDate,
        description: request.notes || `Payment for invoice ${invoice.invoiceNumber}`,
        reference: request.reference,
        cardLastFour: request.cardLastFour,
        cardExpiry: request.cardExpiry,
        bankAccountLastFour: request.bankAccountLastFour,
        sortCode: request.sortCode,
        providerTransactionId: request.providerTransactionId,
        providerReference: request.providerReference,
        providerName: request.providerName,
        accountId: invoice.accountId,
        createdBy: request.processedBy,
        status: PaymentStatus.PENDING,
        currency: invoice.currency,
      });

      const savedPayment = await this.paymentRepository.save(payment);

      // Update invoice with payment
      invoice.recordPayment(paymentAmount, savedPayment.id);
      await this.invoiceRepository.save(invoice);

      // Create financial transaction
      await this.createPaymentTransaction(savedPayment);

      this.logger.log(`Payment recorded successfully: ${savedPayment.id}`);
      return savedPayment;

    } catch (error) {
      this.logger.error(`Failed to record payment: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Reconcile payments for invoice
   */
  async reconcilePayments(invoiceId: string, reconciledBy: string): Promise<Invoice> {
    this.logger.log(`Reconciling payments for invoice: ${invoiceId}`);
    
    try {
      const invoice = await this.getInvoiceById(invoiceId);
      if (!invoice) {
        throw new Error('Invoice not found');
      }

      if (invoice.isFullyPaid()) {
        throw new Error('Invoice is already fully paid');
      }

      // Get all pending payments for this invoice
      const pendingPayments = await this.paymentRepository.find({
        where: {
          invoiceId,
          status: PaymentStatus.PENDING,
        },
      });

      // Process each pending payment
      for (const payment of pendingPayments) {
        payment.process();
        await this.paymentRepository.save(payment);
      }

      // Update invoice status
      if (invoice.isFullyPaid()) {
        invoice.status = InvoiceStatus.PAID;
        invoice.paidDate = new Date();
      } else if (invoice.isPartiallyPaid()) {
        invoice.status = InvoiceStatus.PARTIALLY_PAID;
      }

      invoice.updatedBy = reconciledBy;
      const updatedInvoice = await this.invoiceRepository.save(invoice);

      this.logger.log(`Payments reconciled successfully for invoice: ${invoiceId}`);
      return updatedInvoice;

    } catch (error) {
      this.logger.error(`Failed to reconcile payments: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Cancel invoice
   */
  async cancelInvoice(invoiceId: string, cancelledBy: string, reason: string): Promise<Invoice> {
    this.logger.log(`Cancelling invoice: ${invoiceId}`);
    
    try {
      const invoice = await this.getInvoiceById(invoiceId);
      if (!invoice) {
        throw new Error('Invoice not found');
      }

      if (invoice.status === InvoiceStatus.PAID) {
        throw new Error('Cannot cancel paid invoice');
      }

      invoice.status = InvoiceStatus.CANCELLED;
      invoice.notes = invoice.notes ? `${invoice.notes}\nCancelled: ${reason}` : `Cancelled: ${reason}`;
      invoice.updatedBy = cancelledBy;

      const updatedInvoice = await this.invoiceRepository.save(invoice);

      this.logger.log(`Invoice cancelled successfully: ${invoiceId}`);
      return updatedInvoice;

    } catch (error) {
      this.logger.error(`Failed to cancel invoice: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Get invoice statistics
   */
  async getInvoiceStatistics(period: 'month' | 'quarter' | 'year' = 'month'): Promise<{
    totalInvoices: number;
    totalAmount: string;
    paidAmount: string;
    outstandingAmount: string;
    overdueAmount: string;
    overdueCount: number;
    averageInvoiceValue: string;
    paymentRate: number;
  }> {
    const now = new Date();
    const startDate = new Date();

    switch (period) {
      case 'month':
        startDate.setMonth(now.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(now.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(now.getFullYear() - 1);
        break;
    }

    const invoices = await this.invoiceRepository.find({
      where: {
        invoiceDate: Between(startDate, now),
        status: Not(InvoiceStatus.CANCELLED),
      },
    });

    const stats = {
      totalInvoices: invoices.length,
      totalAmount: '0.00',
      paidAmount: '0.00',
      outstandingAmount: '0.00',
      overdueAmount: '0.00',
      overdueCount: 0,
      averageInvoiceValue: '0.00',
      paymentRate: 0,
    };

    let totalAmount = new Decimal(0);
    let paidAmount = new Decimal(0);
    let outstandingAmount = new Decimal(0);
    let overdueAmount = new Decimal(0);

    invoices.forEach(invoice => {
      totalAmount = totalAmount.plus(invoice.totalAmount);
      paidAmount = paidAmount.plus(invoice.paidAmount);
      outstandingAmount = outstandingAmount.plus(invoice.balanceAmount);
      
      if (invoice.isOverdue()) {
        overdueAmount = overdueAmount.plus(invoice.balanceAmount);
        stats.overdueCount++;
      }
    });

    stats.totalAmount = totalAmount.toFixed(2);
    stats.paidAmount = paidAmount.toFixed(2);
    stats.outstandingAmount = outstandingAmount.toFixed(2);
    stats.overdueAmount = overdueAmount.toFixed(2);
    stats.averageInvoiceValue = invoices.length > 0 ? totalAmount.dividedBy(invoices.length).toFixed(2) : '0.00';
    stats.paymentRate = totalAmount.greaterThan(0) ? paidAmount.dividedBy(totalAmount).times(100).toNumber() : 0;

    return stats;
  }

  /**
   * Validate create invoice request
   */
  private validateCreateInvoiceRequest(request: CreateInvoiceRequest): void {
    if (!request.invoiceType) {
      throw new Error('Invoice type is required');
    }

    if (!request.description || request.description.trim().length === 0) {
      throw new Error('Description is required');
    }

    if (!request.subtotal || request.subtotal <= 0) {
      throw new Error('Subtotal must be positive');
    }

    if (!request.billingAddress || request.billingAddress.trim().length === 0) {
      throw new Error('Billing address is required');
    }

    if (request.taxRate && (request.taxRate < 0 || request.taxRate > 1)) {
      throw new Error('Tax rate must be between 0 and 1');
    }
  }

  /**
   * Get account for invoice type
   */
  private async getAccountForInvoiceType(invoiceType: InvoiceType): Promise<ChartOfAccounts | null> {
    const accountMapping = {
      [InvoiceType.RESIDENT_FEES]: 'REVENUE-RESIDENT-FEES',
      [InvoiceType.NHS_FUNDING]: 'REVENUE-NHS-FUNDING',
      [InvoiceType.LOCAL_AUTHORITY_FUNDING]: 'REVENUE-LA-FUNDING',
      [InvoiceType.PRIVATE_INSURANCE]: 'REVENUE-INSURANCE',
      [InvoiceType.ADDITIONAL_SERVICES]: 'REVENUE-ADDITIONAL-SERVICES',
      [InvoiceType.MEDICATION]: 'REVENUE-MEDICATION',
      [InvoiceType.THERAPY]: 'REVENUE-THERAPY',
      [InvoiceType.TRANSPORT]: 'REVENUE-TRANSPORT',
      [InvoiceType.OTHER]: 'REVENUE-OTHER',
    };

    const accountCode = accountMapping[invoiceType];
    if (!accountCode) {
      return null;
    }

    return await this.chartOfAccountsRepository.findOne({
      where: { accountCode },
    });
  }

  /**
   * Calculate due date based on payment terms
   */
  private calculateDueDate(paymentTerms?: PaymentTerms): Date {
    const baseDate = new Date();
    
    switch (paymentTerms) {
      case PaymentTerms.DUE_ON_RECEIPT:
        return baseDate;
      case PaymentTerms.NET_15:
        return dayjs(baseDate).add(15, 'days').toDate();
      case PaymentTerms.NET_30:
        return dayjs(baseDate).add(30, 'days').toDate();
      case PaymentTerms.NET_45:
        return dayjs(baseDate).add(45, 'days').toDate();
      case PaymentTerms.NET_60:
        return dayjs(baseDate).add(60, 'days').toDate();
      case PaymentTerms.CASH_ON_DELIVERY:
        return baseDate;
      default:
        return dayjs(baseDate).add(30, 'days').toDate();
    }
  }

  /**
   * Create financial transaction for invoice
   */
  private async createFinancialTransaction(invoice: Invoice): Promise<void> {
    const transaction = this.financialTransactionRepository.create({
      transactionDate: invoice.invoiceDate,
      amount: invoice.totalAmount,
      currency: invoice.currency,
      description: `Invoice ${invoice.invoiceNumber}: ${invoice.description}`,
      category: 'REVENUE',
      status: 'APPROVED',
      reference: invoice.invoiceNumber,
      accountId: invoice.accountId,
      residentId: invoice.residentId,
      departmentId: invoice.departmentId,
      correlationId: invoice.correlationId,
      regulatoryCode: invoice.regulatoryCode,
      isVATApplicable: invoice.isVATApplicable,
      vatAmount: invoice.taxAmount,
      vatRate: invoice.taxRate,
      createdBy: invoice.createdBy,
    });

    await this.financialTransactionRepository.save(transaction);
  }

  /**
   * Create financial transaction for payment
   */
  private async createPaymentTransaction(payment: Payment): Promise<void> {
    const transaction = this.financialTransactionRepository.create({
      transactionDate: payment.paymentDate,
      amount: payment.amount,
      currency: payment.currency,
      description: `Payment ${payment.paymentReference}: ${payment.description}`,
      category: 'REVENUE',
      status: 'PROCESSED',
      reference: payment.paymentReference,
      paymentMethod: payment.paymentMethod,
      paymentReference: payment.providerReference,
      accountId: payment.accountId,
      correlationId: payment.correlationId,
      createdBy: payment.createdBy,
    });

    await this.financialTransactionRepository.save(transaction);
  }

  /**
   * Calculate invoice summary
   */
  private async calculateInvoiceSummary(filters: InvoiceFilters): Promise<{
    totalAmount: string;
    paidAmount: string;
    outstandingAmount: string;
    overdueAmount: string;
    overdueCount: number;
  }> {
    const query = this.invoiceRepository.createQueryBuilder('invoice');

    // Apply same filters as main query
    if (filters.status && filters.status.length > 0) {
      query.andWhere('invoice.status IN (:...status)', { status: filters.status });
    }

    if (filters.invoiceType && filters.invoiceType.length > 0) {
      query.andWhere('invoice.invoiceType IN (:...invoiceType)', { invoiceType: filters.invoiceType });
    }

    if (filters.residentId) {
      query.andWhere('invoice.residentId = :residentId', { residentId: filters.residentId });
    }

    if (filters.billingEntityId) {
      query.andWhere('invoice.billingEntityId = :billingEntityId', { billingEntityId: filters.billingEntityId });
    }

    if (filters.dateFrom) {
      query.andWhere('invoice.invoiceDate >= :dateFrom', { dateFrom: filters.dateFrom });
    }

    if (filters.dateTo) {
      query.andWhere('invoice.invoiceDate <= :dateTo', { dateTo: filters.dateTo });
    }

    if (filters.amountFrom) {
      query.andWhere('invoice.totalAmount >= :amountFrom', { amountFrom: filters.amountFrom });
    }

    if (filters.amountTo) {
      query.andWhere('invoice.totalAmount <= :amountTo', { amountTo: filters.amountTo });
    }

    if (filters.isOverdue) {
      query.andWhere('invoice.daysOverdue > 0');
    }

    if (filters.isPaid !== undefined) {
      if (filters.isPaid) {
        query.andWhere('invoice.status = :paidStatus', { paidStatus: InvoiceStatus.PAID });
      } else {
        query.andWhere('invoice.status != :paidStatus', { paidStatus: InvoiceStatus.PAID });
      }
    }

    if (filters.search) {
      query.andWhere(
        '(invoice.invoiceNumber ILIKE :search OR invoice.description ILIKE :search OR invoice.reference ILIKE :search)',
        { search: `%${filters.search}%` }
      );
    }

    const invoices = await query.getMany();

    let totalAmount = new Decimal(0);
    let paidAmount = new Decimal(0);
    let outstandingAmount = new Decimal(0);
    let overdueAmount = new Decimal(0);
    let overdueCount = 0;

    invoices.forEach(invoice => {
      totalAmount = totalAmount.plus(invoice.totalAmount);
      paidAmount = paidAmount.plus(invoice.paidAmount);
      outstandingAmount = outstandingAmount.plus(invoice.balanceAmount);
      
      if (invoice.isOverdue()) {
        overdueAmount = overdueAmount.plus(invoice.balanceAmount);
        overdueCount++;
      }
    });

    return {
      totalAmount: totalAmount.toFixed(2),
      paidAmount: paidAmount.toFixed(2),
      outstandingAmount: outstandingAmount.toFixed(2),
      overdueAmount: overdueAmount.toFixed(2),
      overdueCount,
    };
  }
}

export default InvoiceService;