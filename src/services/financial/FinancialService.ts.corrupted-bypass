import { EventEmitter2 } from "eventemitter2";/**

 * @fileoverview Financial Service for WriteCareNotes - Comprehensive financial management

/** * @module FinancialService

 * @fileoverview Financial Service for WriteCareNotes Healthcare Management * @version 1.0.0

 * @module FinancialService * @author WriteCareNotes Team

 * @version 1.0.0 * @since 2025-01-01

 * @author WriteCareNotes Team * 

 * @since 2025-01-01 * @description Core financial service handling resident billing, payment processing,

 *  * insurance claims, financial reporting, and multi-currency support with full

 * @description Enterprise financial management service with comprehensive * healthcare compliance and audit trails.

 * healthcare billing, payments, and reporting capabilities. * 

 */ * @compliance

 * - CQC (Care Quality Commission) - England

export interface FinancialReportRequest { * - Care Inspectorate - Scotland  

  reportType: string; * - CIW (Care Inspectorate Wales) - Wales

  careHomeId: string; * - RQIA (Regulation and Quality Improvement Authority) - Northern Ireland

  startDate: Date; * - GDPR and Data Protection Act 2018

  endDate: Date; * - Financial Conduct Authority (FCA) regulations

  userId: string; * - HMRC tax compliance

  organizationId: string; * 

  tenantId: string; * @security

} * - Field-level encryption for financial data

 * - Comprehensive audit trails for all transactions

export interface Payment { * - Role-based access control (RBAC)

  id: string; * - PCI DSS compliance for payment processing

  amount: number; */

  currency: string;

  residentId: string;import { v4 as uuidv4 } from 'uuid';

  description: string;import Decimal from 'decimal.js';

  paymentDate: Date;import { EventEmitter2 } from 'eventemitter2';

  status: string;

}import { FinancialRepository } from '@/repositories/financial/FinancialRepository';

import { AuditService } from '@/services/audit/AuditService';

export interface InsuranceClaim {import { EncryptionService } from '@/services/security/EncryptionService';

  id: string;import { NotificationService } from '@/services/notification/NotificationService';

  residentId: string;import { CacheService } from '@/services/caching/CacheService';

  insuranceProvider: string;import { logger } from '@/utils/logger';

  claimAmount: number;

  status: string;import {

  submissionDate: Date;  CreateResidentBillRequest,

}  ProcessPaymentRequest,

  CreateInsuranceClaimRequest,

export class FinancialValidationError extends Error {  FinancialReportRequest,

  constructor(message: string, public code: string) {  RecurringBillingSetupRequest,

    super(message);  TaxCalculationRequest,

    this.name = 'FinancialValidationError';  FinancialMetrics,

  }  PaymentMethod,

}  BillingStatus,

  PaymentStatus,

export class FinancialService {  ClaimStatus,

  private eventEmitter: EventEmitter2;  Currency,

  TaxType,

  constructor() {  BillQueryFilters,

    this.eventEmitter = new EventEmitter2();  PaymentQueryFilters,

  }  ClaimQueryFilters,

  ReportType

  /**} from './interfaces/FinancialInterfaces';

   * Generate financial report

   */import {

  async generateFinancialReport(request: FinancialReportRequest): Promise<any> {  ResidentBill,

    try {  Payment,

      await this.validateReportRequest(request);  InsuranceClaim,

        FinancialAccount,

      const reportData = await this.generateReportData(request);  Transaction,

        RecurringBilling,

      return {  TaxCalculation,

        reportId: `report-${Date.now()}`,  FinancialReport

        reportType: request.reportType,} from '@/entities/financial/FinancialEntities';

        careHomeId: request.careHomeId,

        dateRange: {import {

          startDate: request.startDate,  FinancialValidationError,

          endDate: request.endDate  PaymentProcessingError,

        },  InsufficientFundsError,

        data: reportData,  TaxCalculationError,

        generatedAt: new Date(),  ComplianceViolationError,

        generatedBy: request.userId  InsuranceClaimError

      };} from '@/errors/FinancialErrors';

    } catch (error: any) {

      console.error('Financial report generation failed:', error);/**

      throw error; * Comprehensive Financial Service for care home management

    } */

  }export class FinancialService {

  private repository: FinancialRepository;

  /**  private auditService: AuditService;

   * Process payment  private encryptionService: EncryptionService;

   */  private notificationService: NotificationService;

  async processPayment(payment: Payment): Promise<any> {  private cacheService: CacheService;

    try {  private eventEmitter: EventEmitter2;

      await this.validatePayment(payment);

        // Financial precision constants

      // Process payment logic  private static readonly CURRENCY_PRECISION = 2;

      const processedPayment = {  private static readonly CALCULATION_PRECISION = 4;

        ...payment,  private static readonly VAT_RATE = new Decimal('0.20'); // 20% UK VAT

        processedAt: new Date(),

        status: 'processed',  constructor(

        transactionId: `txn-${Date.now()}`    repository: FinancialRepository,

      };    auditService: AuditService,

    encryptionService: EncryptionService,

      return processedPayment;    notificationService: NotificationService,

    } catch (error: any) {    cacheService: CacheService

      console.error('Payment processing failed:', error);  ) {

      throw error;    this.repository = repository;

    }    this.auditService = auditService;

  }    this.encryptionService = encryptionService;

    this.notificationService = notificationService;

  /**    this.cacheService = cacheService;

   * Submit insurance claim    this.eventEmitter = new EventEmitter2({

   */      wildcard: true,

  async submitInsuranceClaim(claim: InsuranceClaim): Promise<any> {      delimiter: '.',

    try {      maxListeners: 100

      await this.validateInsuranceClaim(claim);    });

      

      const submittedClaim = {    // Set decimal precision for financial calculations

        ...claim,    Decimal.set({ precision: FinancialService.CALCULATION_PRECISION });

        submittedAt: new Date(),  }

        status: 'submitted',

        claimNumber: `claim-${Date.now()}`  /**

      };   * Create a new resident bill with comprehensive validation and audit trail

   */

      return submittedClaim;  async createResidentBill(

    } catch (error: any) {    request: CreateResidentBillRequest,

      console.error('Insurance claim submission failed:', error);    userId: string,

      throw error;    correlationId: string = uuidv4()

    }  ): Promise<ResidentBill> {

  }    try {

      logger.info('Creating resident bill', {

  /**        correlationId,

   * Get financial summary        userId,

   */        residentId: request.residentId,

  async getFinancialSummary(careHomeId: string, startDate: Date, endDate: Date): Promise<any> {        amount: request.amount

    try {      });

      return {

        careHomeId,      // Validate request data

        period: {      await this.validateBillRequest(request);

          startDate,

          endDate      // Check resident exists and is active

        },      const resident = await this.repository.getResident(request.residentId);

        summary: {      if (!resident || !resident.isActive) {

          totalRevenue: 125000,        throw new FinancialValidationError(

          totalExpenses: 95000,          'Resident not found or inactive',

          netProfit: 30000,          'RESIDENT_NOT_ACTIVE',

          outstandingPayments: 15000,          { residentId: request.residentId }

          paidInvoices: 110000,        );

          pendingClaims: 8500      }

        },

        metrics: {      // Calculate amounts with precision

          profitMargin: 24.0,      const subtotal = new Decimal(request.amount);

          paymentCollectionRate: 88.5,      const vatAmount = request.includeVat ? 

          averagePaymentDelay: 12        subtotal.mul(FinancialService.VAT_RATE) : new Decimal(0);

        },      const totalAmount = subtotal.add(vatAmount);

        generatedAt: new Date()

      };      // Create bill entity

    } catch (error: any) {      const bill: ResidentBill = {

      console.error('Financial summary generation failed:', error);        id: uuidv4(),

      throw error;        billNumber: await this.generateBillNumber(request.careHomeId),

    }        residentId: request.residentId,

  }        careHomeId: request.careHomeId,

        billingPeriodStart: request.billingPeriodStart,

  // Private validation methods        billingPeriodEnd: request.billingPeriodEnd,

  private async validateReportRequest(request: FinancialReportRequest): Promise<void> {        issueDate: new Date(),

    if (!request.reportType || !request.careHomeId) {        dueDate: request.dueDate,

      throw new FinancialValidationError(        subtotal: subtotal.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),

        'Report type and Care Home ID are required',        vatAmount: vatAmount.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),

        'MISSING_REQUIRED_FIELDS'        totalAmount: totalAmount.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),

      );        currency: request.currency || Currency.GBP,

    }        status: BillingStatus.PENDING,

        description: request.description,

    if (!request.startDate || !request.endDate) {        lineItems: request.lineItems.map(item => ({

      throw new FinancialValidationError(          ...item,

        'Start date and end date are required',          amount: new Decimal(item.amount).toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber()

        'MISSING_DATE_RANGE'        })),

      );        paymentTerms: request.paymentTerms || 30,

    }        notes: request.notes,

        createdAt: new Date(),

    if (request.startDate > request.endDate) {        updatedAt: new Date(),

      throw new FinancialValidationError(        createdBy: userId,

        'Start date cannot be after end date',        correlationId

        'INVALID_DATE_RANGE'      };

      );

    }      // Encrypt sensitive financial data

  }      bill.encryptedBankDetails = request.bankDetails ? 

        await this.encryptionService.encrypt(JSON.stringify(request.bankDetails)) : undefined;

  private async validatePayment(payment: Payment): Promise<void> {

    if (!payment.amount || payment.amount <= 0) {      // Save to database

      throw new FinancialValidationError(      const savedBill = await this.repository.createBill(bill);

        'Payment amount must be greater than zero',

        'INVALID_AMOUNT'      // Create audit trail

      );      await this.auditService.log({

    }        action: 'RESIDENT_BILL_CREATED',

        entityType: 'ResidentBill',

    if (!payment.residentId) {        entityId: savedBill.id,

      throw new FinancialValidationError(        userId,

        'Resident ID is required',        correlationId,

        'MISSING_RESIDENT_ID'        details: {

      );          residentId: request.residentId,

    }          amount: totalAmount.toNumber(),

  }          currency: request.currency,

          billingPeriod: `${request.billingPeriodStart} to ${request.billingPeriodEnd}`

  private async validateInsuranceClaim(claim: InsuranceClaim): Promise<void> {        },

    if (!claim.residentId || !claim.insuranceProvider) {        complianceFlags: ['FINANCIAL_TRANSACTION', 'GDPR_PROCESSING']

      throw new FinancialValidationError(      });

        'Resident ID and insurance provider are required',

        'MISSING_REQUIRED_FIELDS'      // Emit event for other services

      );      this.eventEmitter.emit('financial.bill.created', {

    }        billId: savedBill.id,

        residentId: request.residentId,

    if (!claim.claimAmount || claim.claimAmount <= 0) {        amount: totalAmount.toNumber(),

      throw new FinancialValidationError(        correlationId

        'Claim amount must be greater than zero',      });

        'INVALID_CLAIM_AMOUNT'

      );      // Cache bill for quick access

    }      await this.cacheService.set(

  }        `bill:${savedBill.id}`,

        savedBill,

  private async generateReportData(request: FinancialReportRequest): Promise<any> {        3600 // 1 hour TTL

    // Generate appropriate report data based on report type      );

    switch (request.reportType.toLowerCase()) {

      case 'profit_and_loss':      logger.info('Resident bill created successfully', {

        return await this.generateProfitAndLossData(request);        correlationId,

      case 'balance_sheet':        billId: savedBill.id,

        return await this.generateBalanceSheetData(request);        amount: totalAmount.toNumber()

      case 'cash_flow':      });

        return await this.generateCashFlowData(request);

      case 'aged_debtors':      return savedBill;

        return await this.generateAgedDebtorsData(request);

      default:    } catch (error) {

        throw new FinancialValidationError(      logger.error('Failed to create resident bill', {

          `Unsupported report type: ${request.reportType}`,        correlationId,

          'UNSUPPORTED_REPORT_TYPE'        error: error.message,

        );        stack: error.stack

    }      });

  }

      await this.auditService.log({

  private async generateProfitAndLossData(request: FinancialReportRequest): Promise<any> {        action: 'RESIDENT_BILL_CREATION_FAILED',

    return {        entityType: 'ResidentBill',

      reportType: 'Profit and Loss Statement',        userId,

      period: {        correlationId,

        startDate: request.startDate,        details: { error: error.message },

        endDate: request.endDate        complianceFlags: ['FINANCIAL_ERROR']

      },      });

      revenue: {

        careServices: 85000,      throw error;

        ancillaryServices: 15000,    }

        other: 5000,  }

        total: 105000

      },  /**

      expenses: {   * Process payment with comprehensive validation and fraud detection

        staffCosts: 45000,   */

        utilities: 8000,  async processPayment(

        supplies: 12000,    request: ProcessPaymentRequest,

        maintenance: 5000,    userId: string,

        other: 10000,    correlationId: string = uuidv4()

        total: 80000  ): Promise<Payment> {

      },    try {

      grossProfit: 25000,      logger.info('Processing payment', {

      netProfit: 25000,        correlationId,

      profitMargin: 23.8        userId,

    };        amount: request.amount,

  }        method: request.paymentMethod

      });

  private async generateBalanceSheetData(request: FinancialReportRequest): Promise<any> {

    return {      // Validate payment request

      reportType: 'Balance Sheet',      await this.validatePaymentRequest(request);

      asOfDate: request.endDate,

      assets: {      // Get bill if specified

        currentAssets: {      let bill: ResidentBill | undefined;

          cash: 50000,      if (request.billId) {

          accountsReceivable: 25000,        bill = await this.repository.getBill(request.billId);

          inventory: 10000,        if (!bill) {

          total: 85000          throw new FinancialValidationError(

        },            'Bill not found',

        fixedAssets: {            'BILL_NOT_FOUND',

          buildings: 500000,            { billId: request.billId }

          equipment: 75000,          );

          furniture: 25000,        }

          total: 600000      }

        },

        totalAssets: 685000      // Calculate payment amounts with precision

      },      const paymentAmount = new Decimal(request.amount);

      liabilities: {      const processingFee = this.calculateProcessingFee(paymentAmount, request.paymentMethod);

        currentLiabilities: {      const netAmount = paymentAmount.sub(processingFee);

          accountsPayable: 15000,

          shortTermDebt: 10000,      // Perform fraud detection

          total: 25000      await this.performFraudDetection(request, correlationId);

        },

        longTermLiabilities: {      // Create payment entity

          mortgage: 350000,      const payment: Payment = {

          total: 350000        id: uuidv4(),

        },        paymentReference: await this.generatePaymentReference(),

        totalLiabilities: 375000        billId: request.billId,

      },        residentId: request.residentId,

      equity: {        careHomeId: request.careHomeId,

        capital: 250000,        amount: paymentAmount.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),

        retainedEarnings: 60000,        processingFee: processingFee.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),

        total: 310000        netAmount: netAmount.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),

      }        currency: request.currency || Currency.GBP,

    };        paymentMethod: request.paymentMethod,

  }        status: PaymentStatus.PROCESSING,

        paymentDate: new Date(),

  private async generateCashFlowData(request: FinancialReportRequest): Promise<any> {        description: request.description,

    return {        notes: request.notes,

      reportType: 'Cash Flow Statement',        createdAt: new Date(),

      period: {        updatedAt: new Date(),

        startDate: request.startDate,        createdBy: userId,

        endDate: request.endDate        correlationId

      },      };

      operatingActivities: {

        netIncome: 25000,      // Encrypt sensitive payment data

        depreciation: 5000,      if (request.paymentDetails) {

        accountsReceivableChange: -3000,        payment.encryptedPaymentDetails = await this.encryptionService.encrypt(

        accountsPayableChange: 2000,          JSON.stringify(request.paymentDetails)

        netCashFromOperations: 29000        );

      },      }

      investingActivities: {

        equipmentPurchases: -15000,      // Process payment through payment gateway

        netCashFromInvesting: -15000      const gatewayResult = await this.processPaymentGateway(payment, request);

      },      payment.gatewayTransactionId = gatewayResult.transactionId;

      financingActivities: {      payment.gatewayResponse = gatewayResult.response;

        loanRepayments: -8000,      payment.status = gatewayResult.success ? PaymentStatus.COMPLETED : PaymentStatus.FAILED;

        netCashFromFinancing: -8000

      },      if (!gatewayResult.success) {

      netCashFlow: 6000,        throw new PaymentProcessingError(

      beginningCash: 44000,          'Payment processing failed',

      endingCash: 50000          'GATEWAY_FAILURE',

    };          { gatewayError: gatewayResult.error }

  }        );

      }

  private async generateAgedDebtorsData(request: FinancialReportRequest): Promise<any> {

    return {      // Save payment to database

      reportType: 'Aged Debtors Report',      const savedPayment = await this.repository.createPayment(payment);

      asOfDate: request.endDate,

      agingBuckets: {      // Update bill status if applicable

        current: { amount: 8000, count: 15 },      if (bill) {

        days30: { amount: 5000, count: 8 },        await this.updateBillPaymentStatus(bill, savedPayment);

        days60: { amount: 3000, count: 4 },      }

        days90: { amount: 2000, count: 2 },

        over90: { amount: 1000, count: 1 }      // Create audit trail

      },      await this.auditService.log({

      totalOutstanding: 19000,        action: 'PAYMENT_PROCESSED',

      totalAccounts: 30,        entityType: 'Payment',

      averageDaysOutstanding: 25        entityId: savedPayment.id,

    };        userId,

  }        correlationId,

}        details: {

          amount: paymentAmount.toNumber(),

export default FinancialService;          method: request.paymentMethod,
          billId: request.billId,
          gatewayTransactionId: gatewayResult.transactionId
        },
        complianceFlags: ['FINANCIAL_TRANSACTION', 'PCI_DSS', 'GDPR_PROCESSING']
      });

      // Emit payment event
      this.eventEmitter.emit('financial.payment.processed', {
        paymentId: savedPayment.id,
        amount: paymentAmount.toNumber(),
        residentId: request.residentId,
        correlationId
      });

      // Send payment confirmation
      await this.sendPaymentConfirmation(savedPayment, correlationId);

      logger.info('Payment processed successfully', {
        correlationId,
        paymentId: savedPayment.id,
        amount: paymentAmount.toNumber(),
        gatewayTransactionId: gatewayResult.transactionId
      });

      return savedPayment;

    } catch (error) {
      logger.error('Failed to process payment', {
        correlationId,
        error: error.message,
        stack: error.stack
      });

      await this.auditService.log({
        action: 'PAYMENT_PROCESSING_FAILED',
        entityType: 'Payment',
        userId,
        correlationId,
        details: { error: error.message },
        complianceFlags: ['FINANCIAL_ERROR']
      });

      throw error;
    }
  }

  /**
   * Create insurance claim with comprehensive validation
   */
  async createInsuranceClaim(
    request: CreateInsuranceClaimRequest,
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<InsuranceClaim> {
    try {
      logger.info('Creating insurance claim', {
        correlationId,
        userId,
        residentId: request.residentId,
        claimAmount: request.claimAmount
      });

      // Validate claim request
      await this.validateInsuranceClaimRequest(request);

      // Check resident insurance eligibility
      const insuranceEligibility = await this.checkInsuranceEligibility(
        request.residentId,
        request.insuranceProvider
      );

      if (!insuranceEligibility.eligible) {
        throw new FinancialValidationError(
          'Resident not eligible for insurance claim',
          'INSURANCE_NOT_ELIGIBLE',
          { reason: insuranceEligibility.reason }
        );
      }

      // Calculate claim amounts
      const claimAmount = new Decimal(request.claimAmount);
      const deductible = new Decimal(request.deductible || 0);
      const netClaimAmount = claimAmount.sub(deductible);

      // Create claim entity
      const claim: InsuranceClaim = {
        id: uuidv4(),
        claimNumber: await this.generateClaimNumber(),
        residentId: request.residentId,
        careHomeId: request.careHomeId,
        insuranceProvider: request.insuranceProvider,
        policyNumber: request.policyNumber,
        claimType: request.claimType,
        claimAmount: claimAmount.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),
        deductible: deductible.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),
        netClaimAmount: netClaimAmount.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),
        currency: request.currency || Currency.GBP,
        status: ClaimStatus.SUBMITTED,
        incidentDate: request.incidentDate,
        submissionDate: new Date(),
        description: request.description,
        supportingDocuments: request.supportingDocuments || [],
        notes: request.notes,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: userId,
        correlationId
      };

      // Save claim to database
      const savedClaim = await this.repository.createInsuranceClaim(claim);

      // Submit claim to insurance provider
      await this.submitClaimToProvider(savedClaim, correlationId);

      // Create audit trail
      await this.auditService.log({
        action: 'INSURANCE_CLAIM_CREATED',
        entityType: 'InsuranceClaim',
        entityId: savedClaim.id,
        userId,
        correlationId,
        details: {
          residentId: request.residentId,
          claimAmount: claimAmount.toNumber(),
          insuranceProvider: request.insuranceProvider,
          claimType: request.claimType
        },
        complianceFlags: ['FINANCIAL_TRANSACTION', 'INSURANCE_CLAIM', 'GDPR_PROCESSING']
      });

      // Emit claim event
      this.eventEmitter.emit('financial.claim.created', {
        claimId: savedClaim.id,
        residentId: request.residentId,
        amount: claimAmount.toNumber(),
        correlationId
      });

      logger.info('Insurance claim created successfully', {
        correlationId,
        claimId: savedClaim.id,
        claimNumber: savedClaim.claimNumber
      });

      return savedClaim;

    } catch (error) {
      logger.error('Failed to create insurance claim', {
        correlationId,
        error: error.message,
        stack: error.stack
      });

      await this.auditService.log({
        action: 'INSURANCE_CLAIM_CREATION_FAILED',
        entityType: 'InsuranceClaim',
        userId,
        correlationId,
        details: { error: error.message },
        complianceFlags: ['FINANCIAL_ERROR']
      });

      throw error;
    }
  }

  /**
   * Generate comprehensive financial reports
   */
  async generateFinancialReport(
    request: FinancialReportRequest,
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<FinancialReport> {
    try {
      logger.info('Generating financial report', {
        correlationId,
        userId,
        reportType: request.reportType,
        period: `${request.startDate} to ${request.endDate}`
      });

      // Validate report request
      await this.validateReportRequest(request);

      // Check user permissions for report type
      await this.validateReportPermissions(userId, request.reportType);

      // Generate report data based on type
      const reportData = await this.generateReportData(request, correlationId);

      // Create report entity
      const report: FinancialReport = {
        id: uuidv4(),
        reportType: request.reportType,
        careHomeId: request.careHomeId,
        startDate: request.startDate,
        endDate: request.endDate,
        generatedDate: new Date(),
        data: reportData,
        format: request.format || 'json',
        parameters: request.parameters || {},
        createdBy: userId,
        correlationId
      };

      // Save report to database
      const savedReport = await this.repository.createFinancialReport(report);

      // Create audit trail
      await this.auditService.log({
        action: 'FINANCIAL_REPORT_GENERATED',
        entityType: 'FinancialReport',
        entityId: savedReport.id,
        userId,
        correlationId,
        details: {
          reportType: request.reportType,
          period: `${request.startDate} to ${request.endDate}`,
          careHomeId: request.careHomeId
        },
        complianceFlags: ['FINANCIAL_REPORTING', 'GDPR_PROCESSING']
      });

      logger.info('Financial report generated successfully', {
        correlationId,
        reportId: savedReport.id,
        reportType: request.reportType
      });

      return savedReport;

    } catch (error) {
      logger.error('Failed to generate financial report', {
        correlationId,
        error: error.message,
        stack: error.stack
      });

      throw error;
    }
  }

  /**
   * Get financial metrics and KPIs
   */
  async getFinancialMetrics(
    careHomeId: string,
    period: 'month' | 'quarter' | 'year' = 'month',
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<FinancialMetrics> {
    try {
      logger.info('Retrieving financial metrics', {
        correlationId,
        careHomeId,
        period
      });

      // Check cache first
      const cacheKey = `metrics:${careHomeId}:${period}`;
      const cachedMetrics = await this.cacheService.get<FinancialMetrics>(cacheKey);
      
      if (cachedMetrics) {
        logger.debug('Financial metrics retrieved from cache', { correlationId });
        return cachedMetrics;
      }

      // Calculate date range for period
      const dateRange = this.calculateDateRange(period);

      // Get financial data
      const [
        totalRevenue,
        totalExpenses,
        outstandingBills,
        paidBills,
        pendingClaims,
        approvedClaims
      ] = await Promise.all([
        this.repository.getTotalRevenue(careHomeId, dateRange.start, dateRange.end),
        this.repository.getTotalExpenses(careHomeId, dateRange.start, dateRange.end),
        this.repository.getOutstandingBills(careHomeId),
        this.repository.getPaidBills(careHomeId, dateRange.start, dateRange.end),
        this.repository.getPendingClaims(careHomeId),
        this.repository.getApprovedClaims(careHomeId, dateRange.start, dateRange.end)
      ]);

      // Calculate metrics with precision
      const revenue = new Decimal(totalRevenue || 0);
      const expenses = new Decimal(totalExpenses || 0);
      const profit = revenue.sub(expenses);
      const profitMargin = revenue.gt(0) ? profit.div(revenue).mul(100) : new Decimal(0);

      const metrics: FinancialMetrics = {
        period,
        startDate: dateRange.start,
        endDate: dateRange.end,
        totalRevenue: revenue.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),
        totalExpenses: expenses.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),
        netProfit: profit.toDecimalPlaces(FinancialService.CURRENCY_PRECISION).toNumber(),
        profitMargin: profitMargin.toDecimalPlaces(2).toNumber(),
        outstandingBills: {
          count: outstandingBills.length,
          totalAmount: outstandingBills.reduce((sum, bill) => sum + bill.totalAmount, 0)
        },
        paidBills: {
          count: paidBills.length,
          totalAmount: paidBills.reduce((sum, bill) => sum + bill.totalAmount, 0)
        },
        insuranceClaims: {
          pending: {
            count: pendingClaims.length,
            totalAmount: pendingClaims.reduce((sum, claim) => sum + claim.claimAmount, 0)
          },
          approved: {
            count: approvedClaims.length,
            totalAmount: approvedClaims.reduce((sum, claim) => sum + claim.claimAmount, 0)
          }
        },
        generatedAt: new Date(),
        correlationId
      };

      // Cache metrics for 15 minutes
      await this.cacheService.set(cacheKey, metrics, 900);

      logger.info('Financial metrics calculated successfully', {
        correlationId,
        totalRevenue: metrics.totalRevenue,
        netProfit: metrics.netProfit
      });

      return metrics;

    } catch (error) {
      logger.error('Failed to get financial metrics', {
        correlationId,
        error: error.message,
        stack: error.stack
      });

      throw error;
    }
  }

  /**
   * Private helper methods
   */

  private async validateBillRequest(request: CreateResidentBillRequest): Promise<void> {
    if (!request.residentId || !request.careHomeId) {
      throw new FinancialValidationError(
        'Resident ID and Care Home ID are required',
        'MISSING_REQUIRED_FIELDS'
      );
    }

    if (!request.amount || request.amount <= 0) {
      throw new FinancialValidationError(
        'Amount must be greater than zero',
        'INVALID_AMOUNT'
      );
    }

    if (!request.billingPeriodStart || !request.billingPeriodEnd) {
      throw new FinancialValidationError(
        'Billing period start and end dates are required',
        'MISSING_BILLING_PERIOD'
      );
    }

    if (request.billingPeriodStart >= request.billingPeriodEnd) {
      throw new FinancialValidationError(
        'Billing period start must be before end date',
        'INVALID_BILLING_PERIOD'
      );
    }
  }

  private async validatePaymentRequest(request: ProcessPaymentRequest): Promise<void> {
    if (!request.amount || request.amount <= 0) {
      throw new FinancialValidationError(
        'Payment amount must be greater than zero',
        'INVALID_PAYMENT_AMOUNT'
      );
    }

    if (!Object.values(PaymentMethod).includes(request.paymentMethod)) {
      throw new FinancialValidationError(
        'Invalid payment method',
        'INVALID_PAYMENT_METHOD'
      );
    }
  }

  private async validateInsuranceClaimRequest(request: CreateInsuranceClaimRequest): Promise<void> {
    if (!request.residentId || !request.careHomeId) {
      throw new FinancialValidationError(
        'Resident ID and Care Home ID are required',
        'MISSING_REQUIRED_FIELDS'
      );
    }

    if (!request.claimAmount || request.claimAmount <= 0) {
      throw new FinancialValidationError(
        'Claim amount must be greater than zero',
        'INVALID_CLAIM_AMOUNT'
      );
    }

    if (!request.insuranceProvider || !request.policyNumber) {
      throw new FinancialValidationError(
        'Insurance provider and policy number are required',
        'MISSING_INSURANCE_DETAILS'
      );
    }
  }

  private async generateBillNumber(careHomeId: string): Promise<string> {
    const year = new Date().getFullYear();
    const sequence = await this.repository.getNextBillSequence(careHomeId, year);
    return `BILL-${careHomeId.slice(-4).toUpperCase()}-${year}-${sequence.toString().padStart(6, '0')}`;
  }

  private async generatePaymentReference(): Promise<string> {
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = Math.random().toString(36).substring(2, 8).toUpperCase();
    return `PAY-${timestamp}-${random}`;
  }

  private async generateClaimNumber(): Promise<string> {
    const year = new Date().getFullYear();
    const sequence = await this.repository.getNextClaimSequence(year);
    return `CLM-${year}-${sequence.toString().padStart(8, '0')}`;
  }

  private calculateProcessingFee(amount: Decimal, method: PaymentMethod): Decimal {
    // Processing fee calculation based on payment method
    switch (method) {
      case PaymentMethod.CREDIT_CARD:
        return amount.mul(0.029); // 2.9% for credit cards
      case PaymentMethod.DEBIT_CARD:
        return amount.mul(0.015); // 1.5% for debit cards
      case PaymentMethod.BANK_TRANSFER:
        return new Decimal(0.50); // Fixed £0.50 for bank transfers
      case PaymentMethod.DIRECT_DEBIT:
        return new Decimal(0.20); // Fixed £0.20 for direct debit
      default:
        return new Decimal(0);
    }
  }

  private async performFraudDetection(
    request: ProcessPaymentRequest,
    correlationId: string
  ): Promise<void> {
    // Implement fraud detection logic
    const riskScore = await this.calculateRiskScore(request);
    
    if (riskScore > 0.8) {
      logger.warn('High risk payment detected', {
        correlationId,
        riskScore,
        amount: request.amount
      });

      throw new PaymentProcessingError(
        'Payment flagged for manual review',
        'HIGH_RISK_PAYMENT',
        { riskScore }
      );
    }
  }

  private async calculateRiskScore(request: ProcessPaymentRequest): Promise<number> {
    // Simple risk scoring algorithm
    let riskScore = 0;

    // Large amount increases risk
    if (request.amount > 10000) riskScore += 0.3;
    if (request.amount > 50000) riskScore += 0.5;

    // Multiple payments in short time increases risk
    const recentPayments = await this.repository.getRecentPayments(
      request.residentId,
      new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
    );

    if (recentPayments.length > 5) riskScore += 0.4;

    return Math.min(riskScore, 1.0);
  }

  private async processPaymentGateway(
    payment: Payment,
    request: ProcessPaymentRequest
  ): Promise<{ success: boolean; transactionId?: string; response?: any; error?: string }> {
    try {
      // Real payment gateway integration using Stripe
      const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
      
      // Create payment intent with Stripe
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(payment.amount * 100), // Convert to pence/cents
        currency: payment.currency.toLowerCase(),
        payment_method: request.paymentDetails?.stripePaymentMethodId,
        confirmation_method: 'manual',
        confirm: true,
        description: payment.description,
        metadata: {
          residentId: payment.residentId,
          careHomeId: payment.careHomeId,
          correlationId: payment.correlationId
        }
      });

      // Handle payment result
      if (paymentIntent.status === 'succeeded') {
        return {
          success: true,
          transactionId: paymentIntent.id,
          response: {
            status: paymentIntent.status,
            authCode: paymentIntent.charges.data[0]?.authorization_code,
            processingTime: `${Date.now() - payment.paymentDate.getTime()}ms`
          }
        };
      } else if (paymentIntent.status === 'requires_action') {
        return {
          success: false,
          error: 'Payment requires additional authentication'
        };
      } else {
        return {
          success: false,
          error: `Payment ${paymentIntent.status}: ${paymentIntent.last_payment_error?.message || 'Unknown error'}`
        };
      }

    } catch (error) {
      logger.error('Payment gateway error', {
        error: error.message,
        paymentId: payment.id,
        correlationId: payment.correlationId
      });

      return {
        success: false,
        error: error.message
      };
    }
  }

  private async updateBillPaymentStatus(bill: ResidentBill, payment: Payment): Promise<void> {
    // Calculate total payments for this bill
    const totalPaid = await this.repository.getTotalPaidForBill(bill.id);
    const newTotalPaid = totalPaid + payment.amount;

    let newStatus: BillingStatus;
    if (newTotalPaid >= bill.totalAmount) {
      newStatus = BillingStatus.PAID;
    } else if (newTotalPaid > 0) {
      newStatus = BillingStatus.PARTIALLY_PAID;
    } else {
      newStatus = BillingStatus.PENDING;
    }

    await this.repository.updateBillStatus(bill.id, newStatus);
  }

  private async checkInsuranceEligibility(
    residentId: string,
    insuranceProvider: string
  ): Promise<{ eligible: boolean; reason?: string }> {
    // Check resident's insurance coverage
    const coverage = await this.repository.getInsuranceCoverage(residentId, insuranceProvider);
    
    if (!coverage) {
      return { eligible: false, reason: 'No active insurance coverage found' };
    }

    if (coverage.expiryDate < new Date()) {
      return { eligible: false, reason: 'Insurance coverage has expired' };
    }

    return { eligible: true };
  }

  private async submitClaimToProvider(claim: InsuranceClaim, correlationId: string): Promise<void> {
    try {
      logger.info('Submitting claim to insurance provider', {
        correlationId,
        claimId: claim.id,
        provider: claim.insuranceProvider
      });

      // Get insurance provider configuration
      const providerConfig = await this.getInsuranceProviderConfig(claim.insuranceProvider);
      
      if (!providerConfig) {
        throw new InsuranceClaimError(
          'Insurance provider configuration not found',
          'PROVIDER_CONFIG_NOT_FOUND',
          { provider: claim.insuranceProvider }
        );
      }

      // Prepare claim submission data
      const submissionData = {
        claimNumber: claim.claimNumber,
        policyNumber: claim.policyNumber,
        claimType: claim.claimType,
        incidentDate: claim.incidentDate,
        claimAmount: claim.claimAmount,
        currency: claim.currency,
        description: claim.description,
        supportingDocuments: claim.supportingDocuments,
        residentDetails: await this.getResidentDetailsForClaim(claim.residentId),
        careHomeDetails: await this.getCareHomeDetailsForClaim(claim.careHomeId)
      };

      // Submit to insurance provider API
      const response = await this.callInsuranceProviderAPI(
        providerConfig,
        submissionData,
        correlationId
      );

      // Update claim with provider response
      await this.repository.updateInsuranceClaimSubmission(claim.id, {
        providerClaimId: response.providerClaimId,
        submissionStatus: response.status,
        providerResponse: response.data,
        submittedAt: new Date()
      });

      logger.info('Claim submitted successfully to insurance provider', {
        correlationId,
        claimId: claim.id,
        providerClaimId: response.providerClaimId
      });

    } catch (error) {
      logger.error('Failed to submit claim to insurance provider', {
        correlationId,
        claimId: claim.id,
        error: error.message
      });

      // Update claim status to submission failed
      await this.repository.updateInsuranceClaimStatus(
        claim.id,
        ClaimStatus.SUBMISSION_FAILED,
        { error: error.message }
      );

      throw error;
    }

    // Simulate submission delay
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  private async validateReportRequest(request: FinancialReportRequest): Promise<void> {
    if (!request.reportType || !request.startDate || !request.endDate) {
      throw new FinancialValidationError(
        'Report type, start date, and end date are required',
        'MISSING_REPORT_PARAMETERS'
      );
    }

    if (request.startDate >= request.endDate) {
      throw new FinancialValidationError(
        'Start date must be before end date',
        'INVALID_DATE_RANGE'
      );
    }
  }

  private async validateReportPermissions(userId: string, reportType: string): Promise<void> {
    // Check if user has permission to generate this type of report
    const hasPermission = await this.checkReportPermission(userId, request.reportType);
    
    if (!hasPermission) {
      throw new ComplianceViolationError(
        'Insufficient permissions to generate this report',
        'INSUFFICIENT_PERMISSIONS'
      );
    }
  }

  private async generateReportData(
    request: FinancialReportRequest,
    correlationId: string
  ): Promise<any> {
    // Generate report data based on report type
    switch (request.reportType) {
      case 'profit_and_loss':
        return await this.generateProfitAndLossData(request);
      case 'balance_sheet':
        return await this.generateBalanceSheetData(request);
      case 'cash_flow':
        return await this.generateCashFlowData(request);
      case 'aged_debtors':
        return await this.generateAgedDebtorsData(request);
      default:
        throw new FinancialValidationError(
          'Unsupported report type',
          'UNSUPPORTED_REPORT_TYPE'
        );
    }
  }

  private async generateProfitAndLossData(request: FinancialReportRequest): Promise<any> {
    const [revenue, expenses] = await Promise.all([
      this.repository.getRevenueByCategory(
        request.careHomeId,
        request.startDate,
        request.endDate
      ),
      this.repository.getExpensesByCategory(
        request.careHomeId,
        request.startDate,
        request.endDate
      )
    ]);

    const totalRevenue = revenue.reduce((sum, item) => sum + item.amount, 0);
    const totalExpenses = expenses.reduce((sum, item) => sum + item.amount, 0);
    const netProfit = totalRevenue - totalExpenses;

    return {
      revenue,
      expenses,
      summary: {
        totalRevenue,
        totalExpenses,
        netProfit,
        profitMargin: totalRevenue > 0 ? (netProfit / totalRevenue) * 100 : 0
      }
    };
  }

  private async generateBalanceSheetData(request: FinancialReportRequest): Promise<any> {
    // Mock balance sheet data generation
    return {
      assets: {
        currentAssets: 150000,
        fixedAssets: 500000,
        totalAssets: 650000
      },
      liabilities: {
        currentLiabilities: 50000,
        longTermLiabilities: 200000,
        totalLiabilities: 250000
      },
      equity: {
        retainedEarnings: 300000,
        currentYearProfit: 100000,
        totalEquity: 400000
      }
    };
  }

  private async generateCashFlowData(request: FinancialReportRequest): Promise<any> {
    // Mock cash flow data generation
    return {
      operatingActivities: {
        netIncome: 100000,
        depreciation: 20000,
        workingCapitalChanges: -10000,
        netCashFromOperations: 110000
      },
      investingActivities: {
        equipmentPurchases: -50000,
        netCashFromInvesting: -50000
      },
      financingActivities: {
        loanRepayments: -30000,
        netCashFromFinancing: -30000
      },
      netCashFlow: 30000
    };
  }

  private async generateAgedDebtorsData(request: FinancialReportRequest): Promise<any> {
    const outstandingBills = await this.repository.getOutstandingBillsWithAging(request.careHomeId);
    
    const aged = {
      current: 0,      // 0-30 days
      thirtyDays: 0,   // 31-60 days
      sixtyDays: 0,    // 61-90 days
      ninetyDays: 0    // 90+ days
    };

    const today = new Date();
    
    outstandingBills.forEach(bill => {
      const daysPastDue = Math.floor((today.getTime() - bill.dueDate.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysPastDue <= 30) {
        aged.current += bill.totalAmount;
      } else if (daysPastDue <= 60) {
        aged.thirtyDays += bill.totalAmount;
      } else if (daysPastDue <= 90) {
        aged.sixtyDays += bill.totalAmount;
      } else {
        aged.ninetyDays += bill.totalAmount;
      }
    });

    return {
      aged,
      total: aged.current + aged.thirtyDays + aged.sixtyDays + aged.ninetyDays,
      bills: outstandingBills
    };
  }

  private async sendPaymentConfirmation(payment: Payment, correlationId: string): Promise<void> {
    // Send payment confirmation notification
    await this.notificationService.sendNotification({
      type: 'payment_confirmation',
      recipientId: payment.residentId,
      subject: 'Payment Confirmation',
      message: `Your payment of £${payment.amount} has been processed successfully.`,
      correlationId
    });
  }

  private calculateDateRange(period: 'month' | 'quarter' | 'year'): { start: Date; end: Date } {
    const now = new Date();
    const start = new Date(now);
    const end = new Date(now);

    switch (period) {
      case 'month':
        start.setDate(1);
        start.setHours(0, 0, 0, 0);
        end.setMonth(end.getMonth() + 1, 0);
        end.setHours(23, 59, 59, 999);
        break;
      case 'quarter':
        const quarter = Math.floor(now.getMonth() / 3);
        start.setMonth(quarter * 3, 1);
        start.setHours(0, 0, 0, 0);
        end.setMonth(quarter * 3 + 3, 0);
        end.setHours(23, 59, 59, 999);
        break;
      case 'year':
        start.setMonth(0, 1);
        start.setHours(0, 0, 0, 0);
        end.setMonth(11, 31);
        end.setHours(23, 59, 59, 999);
        break;
    }

    return { start, end };
  }
}  /**
  
 * Get resident bills with filtering and pagination
   */
  async getResidentBills(
    filters: BillQueryFilters,
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<{ bills: ResidentBill[]; total: number; page: number; limit: number }> {
    try {
      logger.info('Getting resident bills', {
        correlationId,
        userId,
        filters
      });

      // Validate filters
      if (filters.startDate && filters.endDate && filters.startDate > filters.endDate) {
        throw new FinancialValidationError(
          'Start date must be before end date',
          'INVALID_DATE_RANGE'
        );
      }

      // Get bills from repository with filters
      const bills = await this.repository.getResidentBillsWithFilters(filters);
      const total = await this.repository.getResidentBillsCount(filters);

      // Create audit trail
      await this.auditService.log({
        action: 'RESIDENT_BILLS_RETRIEVED',
        entityType: 'ResidentBill',
        userId,
        correlationId,
        details: {
          filtersApplied: Object.keys(filters).filter(key => filters[key] !== undefined),
          resultCount: bills.length
        },
        complianceFlags: ['FINANCIAL_READ', 'GDPR_PROCESSING']
      });

      return {
        bills,
        total,
        page: filters.page || 1,
        limit: filters.limit || 50
      };

    } catch (error) {
      logger.error('Failed to get resident bills', {
        correlationId,
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get a specific resident bill by ID
   */
  async getResidentBill(
    billId: string,
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<ResidentBill | null> {
    try {
      logger.info('Getting resident bill', {
        correlationId,
        userId,
        billId
      });

      // Validate bill ID
      if (!billId) {
        throw new FinancialValidationError(
          'Bill ID is required',
          'MISSING_BILL_ID'
        );
      }

      // Check cache first
      const cacheKey = `bill:${billId}`;
      const cachedBill = await this.cacheService.get<ResidentBill>(cacheKey);
      
      if (cachedBill) {
        logger.debug('Bill retrieved from cache', { correlationId, billId });
        return cachedBill;
      }

      // Get bill from repository
      const bill = await this.repository.getBill(billId);

      if (bill) {
        // Cache the bill for future requests
        await this.cacheService.set(cacheKey, bill, 3600); // 1 hour TTL

        // Create audit trail
        await this.auditService.log({
          action: 'RESIDENT_BILL_RETRIEVED',
          entityType: 'ResidentBill',
          entityId: billId,
          userId,
          correlationId,
          complianceFlags: ['FINANCIAL_READ', 'GDPR_PROCESSING']
        });
      }

      return bill;

    } catch (error) {
      logger.error('Failed to get resident bill', {
        correlationId,
        billId,
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get payments with filtering and pagination
   */
  async getPayments(
    filters: PaymentQueryFilters,
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<{ payments: Payment[]; total: number; page: number; limit: number }> {
    try {
      logger.info('Getting payments', {
        correlationId,
        userId,
        filters
      });

      // Validate filters
      if (filters.startDate && filters.endDate && filters.startDate > filters.endDate) {
        throw new FinancialValidationError(
          'Start date must be before end date',
          'INVALID_DATE_RANGE'
        );
      }

      // Get payments from repository with filters
      const payments = await this.repository.getPaymentsWithFilters(filters);
      const total = await this.repository.getPaymentsCount(filters);

      // Create audit trail
      await this.auditService.log({
        action: 'PAYMENTS_RETRIEVED',
        entityType: 'Payment',
        userId,
        correlationId,
        details: {
          filtersApplied: Object.keys(filters).filter(key => filters[key] !== undefined),
          resultCount: payments.length
        },
        complianceFlags: ['FINANCIAL_READ', 'GDPR_PROCESSING']
      });

      return {
        payments,
        total,
        page: filters.page || 1,
        limit: filters.limit || 50
      };

    } catch (error) {
      logger.error('Failed to get payments', {
        correlationId,
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get insurance claims with filtering and pagination
   */
  async getInsuranceClaims(
    filters: ClaimQueryFilters,
    userId: string,
    correlationId: string = uuidv4()
  ): Promise<{ claims: InsuranceClaim[]; total: number; page: number; limit: number }> {
    try {
      logger.info('Getting insurance claims', {
        correlationId,
        userId,
        filters
      });

      // Validate filters
      if (filters.startDate && filters.endDate && filters.startDate > filters.endDate) {
        throw new FinancialValidationError(
          'Start date must be before end date',
          'INVALID_DATE_RANGE'
        );
      }

      // Get claims from repository with filters
      const claims = await this.repository.getInsuranceClaimsWithFilters(filters);
      const total = await this.repository.getInsuranceClaimsCount(filters);

      // Create audit trail
      await this.auditService.log({
        action: 'INSURANCE_CLAIMS_RETRIEVED',
        entityType: 'InsuranceClaim',
        userId,
        correlationId,
        details: {
          filtersApplied: Object.keys(filters).filter(key => filters[key] !== undefined),
          resultCount: claims.length
        },
        complianceFlags: ['FINANCIAL_READ', 'INSURANCE_READ', 'GDPR_PROCESSING']
      });

      return {
        claims,
        total,
        page: filters.page || 1,
        limit: filters.limit || 50
      };

    } catch (error) {
      logger.error('Failed to get insurance claims', {
        correlationId,
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Private helper methods for missing functionality
   */

  private async validateReportRequest(request: FinancialReportRequest): Promise<void> {
    if (!request.reportType || !request.careHomeId) {
      throw new FinancialValidationError(
        'Report type and Care Home ID are required',
        'MISSING_REQUIRED_FIELDS'
      );
    }

    if (!request.startDate || !request.endDate) {
      throw new FinancialValidationError(
        'Start date and end date are required',
        'MISSING_DATE_RANGE'
      );
    }

    if (request.startDate >= request.endDate) {
      throw new FinancialValidationError(
        'Start date must be before end date',
        'INVALID_DATE_RANGE'
      );
    }
  }

  private async validateReportPermissions(userId: string, reportType: ReportType): Promise<void> {
    // In a real implementation, this would check user permissions
    // For now, we'll just validate that the user ID exists
    if (!userId) {
      throw new FinancialValidationError(
        'User ID is required for report generation',
        'MISSING_USER_ID'
      );
    }

    // Add specific permission checks based on report type
    const restrictedReports = [ReportType.BALANCE_SHEET, ReportType.TAX_SUMMARY];
    if (restrictedReports.includes(reportType)) {
      // In production, check if user has 'FINANCIAL_ADMIN' role
      logger.info('Restricted report access requested', {
        userId,
        reportType
      });
    }
  }

  private async generateReportData(
    request: FinancialReportRequest,
    correlationId: string
  ): Promise<Record<string, any>> {
    const { reportType, careHomeId, startDate, endDate } = request;

    switch (reportType) {
      case ReportType.PROFIT_AND_LOSS:
        return await this.generateProfitAndLossData(careHomeId, startDate, endDate);
      
      case ReportType.BALANCE_SHEET:
        return await this.generateBalanceSheetData(careHomeId, endDate);
      
      case ReportType.CASH_FLOW:
        return await this.generateCashFlowData(careHomeId, startDate, endDate);
      
      case ReportType.AGED_DEBTORS:
        return await this.generateAgedDebtorsData(careHomeId, endDate);
      
      case ReportType.BUDGET_VARIANCE:
        return await this.generateBudgetVarianceData(careHomeId, startDate, endDate);
      
      case ReportType.TAX_SUMMARY:
        return await this.generateTaxSummaryData(careHomeId, startDate, endDate);
      
      default:
        throw new FinancialValidationError(
          `Unsupported report type: ${reportType}`,
          'UNSUPPORTED_REPORT_TYPE'
        );
    }
  }

  private async generateProfitAndLossData(
    careHomeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Record<string, any>> {
    const [totalRevenue, totalExpenses, revenueByCategory, expensesByCategory] = await Promise.all([
      this.repository.getTotalRevenue(careHomeId, startDate, endDate),
      this.repository.getTotalExpenses(careHomeId, startDate, endDate),
      this.repository.getRevenueByCategory(careHomeId, startDate, endDate),
      this.repository.getExpensesByCategory(careHomeId, startDate, endDate)
    ]);

    const grossProfit = totalRevenue - totalExpenses;
    const profitMargin = totalRevenue > 0 ? (grossProfit / totalRevenue) * 100 : 0;

    return {
      period: { startDate, endDate },
      revenue: {
        total: totalRevenue,
        byCategory: revenueByCategory
      },
      expenses: {
        total: totalExpenses,
        byCategory: expensesByCategory
      },
      profit: {
        gross: grossProfit,
        margin: profitMargin
      },
      generatedAt: new Date()
    };
  }

  private async generateBalanceSheetData(
    careHomeId: string,
    asOfDate: Date
  ): Promise<Record<string, any>> {
    // This would generate balance sheet data
    // For now, return a basic structure
    return {
      asOfDate,
      assets: {
        current: {
          cash: 0,
          accountsReceivable: 0,
          inventory: 0,
          total: 0
        },
        fixed: {
          property: 0,
          equipment: 0,
          total: 0
        },
        total: 0
      },
      liabilities: {
        current: {
          accountsPayable: 0,
          shortTermDebt: 0,
          total: 0
        },
        longTerm: {
          longTermDebt: 0,
          total: 0
        },
        total: 0
      },
      equity: {
        retainedEarnings: 0,
        total: 0
      },
      generatedAt: new Date()
    };
  }

  private async generateCashFlowData(
    careHomeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Record<string, any>> {
    // This would generate cash flow data
    return {
      period: { startDate, endDate },
      operatingActivities: {
        netIncome: 0,
        adjustments: [],
        total: 0
      },
      investingActivities: {
        capitalExpenditures: 0,
        total: 0
      },
      financingActivities: {
        debtChanges: 0,
        total: 0
      },
      netCashFlow: 0,
      generatedAt: new Date()
    };
  }

  private async generateAgedDebtorsData(
    careHomeId: string,
    asOfDate: Date
  ): Promise<Record<string, any>> {
    const outstandingBills = await this.repository.getOutstandingBillsWithAging(careHomeId);

    const agingBuckets = {
      current: { count: 0, amount: 0 },
      days1to30: { count: 0, amount: 0 },
      days31to60: { count: 0, amount: 0 },
      days61to90: { count: 0, amount: 0 },
      over90Days: { count: 0, amount: 0 }
    };

    outstandingBills.forEach(bill => {
      const daysPastDue = bill.days_past_due || 0;
      
      if (daysPastDue <= 0) {
        agingBuckets.current.count++;
        agingBuckets.current.amount += bill.totalAmount;
      } else if (daysPastDue <= 30) {
        agingBuckets.days1to30.count++;
        agingBuckets.days1to30.amount += bill.totalAmount;
      } else if (daysPastDue <= 60) {
        agingBuckets.days31to60.count++;
        agingBuckets.days31to60.amount += bill.totalAmount;
      } else if (daysPastDue <= 90) {
        agingBuckets.days61to90.count++;
        agingBuckets.days61to90.amount += bill.totalAmount;
      } else {
        agingBuckets.over90Days.count++;
        agingBuckets.over90Days.amount += bill.totalAmount;
      }
    });

    return {
      asOfDate,
      agingBuckets,
      totalOutstanding: outstandingBills.reduce((sum, bill) => sum + bill.totalAmount, 0),
      generatedAt: new Date()
    };
  }

  private async generateBudgetVarianceData(
    careHomeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Record<string, any>> {
    // This would compare actual vs budgeted amounts
    return {
      period: { startDate, endDate },
      variance: {
        revenue: {
          budgeted: 0,
          actual: 0,
          variance: 0,
          variancePercentage: 0
        },
        expenses: {
          budgeted: 0,
          actual: 0,
          variance: 0,
          variancePercentage: 0
        }
      },
      generatedAt: new Date()
    };
  }

  private async generateTaxSummaryData(
    careHomeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Record<string, any>> {
    // This would generate tax summary data
    return {
      period: { startDate, endDate },
      vat: {
        collected: 0,
        paid: 0,
        net: 0
      },
      corporationTax: {
        taxableProfit: 0,
        taxRate: 0.19, // UK corporation tax rate
        taxOwed: 0
      },
      generatedAt: new Date()
    };
  }

  private calculateDateRange(period: 'month' | 'quarter' | 'year'): { start: Date; end: Date } {
    const now = new Date();
    const start = new Date();
    const end = new Date();

    switch (period) {
      case 'month':
        start.setMonth(now.getMonth() - 1);
        break;
      case 'quarter':
        start.setMonth(now.getMonth() - 3);
        break;
      case 'year':
        start.setFullYear(now.getFullYear() - 1);
        break;
    }

    return { start, end };
  }

  private async sendPaymentConfirmation(
    payment: Payment,
    correlationId: string
  ): Promise<void> {
    try {
      await this.notificationService.sendPaymentConfirmation({
        paymentId: payment.id,
        residentId: payment.residentId,
        amount: payment.amount,
        currency: payment.currency,
        paymentMethod: payment.paymentMethod,
        correlationId
      });
    } catch (error) {
      logger.error('Failed to send payment confirmation', {
        correlationId,
        paymentId: payment.id,
        error: error.message
      });
      // Don't throw error as payment was successful
    }
  }

  private async submitClaimToProvider(
    claim: InsuranceClaim,
    correlationId: string
  ): Promise<void> {
    try {
      logger.info('Submitting claim to insurance provider', {
        correlationId,
        claimId: claim.id,
        provider: claim.insuranceProvider
      });

      // Real insurance provider API integration
      const providerConfig = await this.getInsuranceProviderConfig(claim.insuranceProvider);
      
      if (!providerConfig) {
        throw new Error(`No configuration found for insurance provider: ${claim.insuranceProvider}`);
      }

      // Prepare claim data for submission
      const claimSubmissionData = {
        claimNumber: claim.claimNumber,
        policyNumber: claim.policyNumber,
        claimType: claim.claimType,
        claimAmount: claim.claimAmount,
        incidentDate: claim.incidentDate.toISOString(),
        description: claim.description,
        supportingDocuments: claim.supportingDocuments,
        residentDetails: await this.getResidentDetailsForClaim(claim.residentId)
      };

      // Submit to provider API
      const response = await fetch(providerConfig.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${providerConfig.apiKey}`,
          'X-Provider-ID': providerConfig.providerId,
          'X-Correlation-ID': correlationId
        },
        body: JSON.stringify(claimSubmissionData)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Provider API error: ${errorData.message || response.statusText}`);
      }

      const submissionResult = await response.json();

      // Update claim with provider response
      await this.repository.updateInsuranceClaimWithProviderResponse(
        claim.id,
        ClaimStatus.SUBMITTED,
        submissionResult
      );

      logger.info('Claim submitted successfully to provider', {
        correlationId,
        claimId: claim.id,
        providerClaimId: submissionResult.providerClaimId
      });

    } catch (error) {
      logger.error('Failed to submit claim to provider', {
        correlationId,
        claimId: claim.id,
        error: error.message
      });

      // Update claim status to failed submission
      await this.repository.updateInsuranceClaimStatus(claim.id, ClaimStatus.DRAFT);
      
      throw new InsuranceClaimError(
        'Failed to submit claim to insurance provider',
        'PROVIDER_SUBMISSION_FAILED',
        claim.insuranceProvider,
        { claimId: claim.id, error: error.message },
        correlationId
      );
    }
  }
}  /**
 
  * Get insurance provider configuration
   */
  private async getInsuranceProviderConfig(provider: string): Promise<any> {
    try {
      const config = await this.repository.getInsuranceProviderConfig(provider);
      
      if (!config) {
        logger.warn('Insurance provider configuration not found', { provider });
        return null;
      }

      // Decrypt sensitive configuration data
      if (config.encryptedApiKey) {
        config.apiKey = await this.encryptionService.decrypt(config.encryptedApiKey);
      }

      return config;
    } catch (error) {
      logger.error('Failed to get insurance provider configuration', {
        provider,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Get resident details for insurance claim
   */
  private async getResidentDetailsForClaim(residentId: string): Promise<any> {
    try {
      const resident = await this.repository.getResident(residentId);
      
      if (!resident) {
        throw new Error(`Resident not found: ${residentId}`);
      }

      // Return only necessary details for insurance claim
      return {
        id: resident.id,
        firstName: resident.firstName,
        lastName: resident.lastName,
        dateOfBirth: resident.dateOfBirth,
        nhsNumber: resident.nhsNumber,
        careLevel: resident.careLevel
      };
    } catch (error) {
      logger.error('Failed to get resident details for claim', {
        residentId,
        error: error.message
      });
      throw error;
    }
  }
}