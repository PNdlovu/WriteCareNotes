import { EventEmitter2 } from "eventemitter2";
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/database';
import { Budget, BudgetStatus, BudgetType } from '../../entities/financial/Budget';
import { BudgetCategory } from '../../entities/financial/BudgetCategory';
import { AuditTrailService } from '../audit/AuditTrailService';
import { NotificationService } from '../notifications/NotificationService';
import { logger } from '../../utils/logger';
import { Decimal } from 'decimal.js';

export interface BudgetRequest {
  budgetName: string;
  budgetType: BudgetType;
  budgetYear: number;
  budgetPeriod: string;
  startDate: Date;
  endDate: Date;
  careHomeId?: string;
  department?: string;
  costCenter?: string;
  totalBudgetedRevenue: number;
  totalBudgetedExpenses: number;
  totalBudgetedProfit: number;
  categories: BudgetCategoryRequest[];
  notes?: string;
  attachments?: string[];
}

export interface BudgetCategoryRequest {
  categoryId: string;
  budgetedAmount: number;
  description?: string;
  notes?: string;
}

export interface BudgetUpdate {
  status?: BudgetStatus;
  budgetName?: string;
  totalBudgetedRevenue?: number;
  totalBudgetedExpenses?: number;
  totalBudgetedProfit?: number;
  notes?: string;
  attachments?: string[];
}

export interface BudgetSearchCriteria {
  budgetName?: string;
  status?: BudgetStatus;
  budgetType?: BudgetType;
  budgetYear?: number;
  budgetPeriod?: string;
  careHomeId?: string;
  department?: string;
  costCenter?: string;
  createdAfter?: Date;
  createdBefore?: Date;
  startDateAfter?: Date;
  startDateBefore?: Date;
  endDateAfter?: Date;
  endDateBefore?: Date;
  createdBy?: string;
  approvedBy?: string;
}

export interface BudgetReport {
  totalBudgets: number;
  activeBudgets: number;
  draftBudgets: number;
  approvedBudgets: number;
  rejectedBudgets: number;
  totalBudgetedRevenue: number;
  totalBudgetedExpenses: number;
  totalBudgetedProfit: number;
  budgetsByType: { [key in BudgetType]: number };
  budgetsByStatus: { [key in BudgetStatus]: number };
  departmentBreakdown: { [department: string]: number };
  costCenterBreakdown: { [costCenter: string]: number };
  yearBreakdown: { [year: number]: number };
  averageBudgetSize: number;
  varianceAnalysis: {
    totalVariance: number;
    revenueVariance: number;
    expenseVariance: number;
    profitVariance: number;
  };
}

export interface BudgetPerformanceReport {
  budgetId: string;
  budgetName: string;
  budgetYear: number;
  totalBudgeted: number;
  totalActual: number;
  variance: number;
  variancePercentage: number;
  performanceByCategory: Array<{
    categoryId: string;
    categoryName: string;
    budgeted: number;
    actual: number;
    variance: number;
    variancePercentage: number;
  }>;
  monthlyBreakdown: Array<{
    month: string;
    budgeted: number;
    actual: number;
    variance: number;
  }>;
  isOnTrack: boolean;
  recommendations: string[];
}

export interface BudgetVarianceReport {
  budgetId: string;
  budgetName: string;
  budgetYear: number;
  totalVariance: number;
  variancePercentage: number;
  favorableVariances: Array<{
    categoryId: string;
    categoryName: string;
    variance: number;
    variancePercentage: number;
  }>;
  unfavorableVariances: Array<{
    categoryId: string;
    categoryName: string;
    variance: number;
    variancePercentage: number;
  }>;
  significantVariances: Array<{
    categoryId: string;
    categoryName: string;
    variance: number;
    variancePercentage: number;
    threshold: number;
  }>;
  recommendations: string[];
}

export class BudgetService {
  private budgetRepository: Repository<Budget>;
  private budgetCategoryRepository: Repository<BudgetCategory>;
  private auditService: AuditTrailService;
  private notificationService: NotificationService;
  private eventEmitter: EventEmitter2;

  constructor() {
    this.budgetRepository = AppDataSource.getRepository(Budget);
    this.budgetCategoryRepository = AppDataSource.getRepository(BudgetCategory);
    this.auditService = new AuditTrailService();
    this.notificationService = new NotificationService(new EventEmitter2());
    this.eventEmitter = new EventEmitter2();
  }

  /**
   * Create a new budget
   */
  async createBudget(
    request: BudgetRequest,
    createdBy: string
  ): Promise<Budget> {
    // Validate budget dates
    if (request.startDate >= request.endDate) {
      throw new Error('Start date must be before end date');
    }

    // Validate budget year matches start date
    if (request.startDate.getFullYear() !== request.budgetYear) {
      throw new Error('Budget year must match start date year');
    }

    // Validate categories exist
    const categoryIds = request.categories.map(cat => cat.categoryId);
    const categories = await this.budgetCategoryRepository.findByIds(categoryIds);
    
    if (categories.length !== categoryIds.length) {
      throw new Error('One or more budget categories not found');
    }

    // Create budget
    const budget = this.budgetRepository.create({
      budgetName: request.budgetName,
      budgetType: request.budgetType,
      budgetYear: request.budgetYear,
      budgetPeriod: request.budgetPeriod,
      startDate: request.startDate,
      endDate: request.endDate,
      careHomeId: request.careHomeId,
      department: request.department,
      costCenter: request.costCenter,
      totalBudgetedRevenue: new Decimal(request.totalBudgetedRevenue),
      totalBudgetedExpenses: new Decimal(request.totalBudgetedExpenses),
      totalBudgetedProfit: new Decimal(request.totalBudgetedProfit),
      notes: request.notes,
      attachments: request.attachments,
      createdBy,
      status: BudgetStatus.DRAFT
    });

    const savedBudget = await this.budgetRepository.save(budget);

    // Create budget category entries
    for (const categoryRequest of request.categories) {
      const category = categories.find(cat => cat.id === categoryRequest.categoryId);
      if (!category) continue;

      const budgetCategoryEntry = {
        budgetId: savedBudget.id,
        categoryId: categoryRequest.categoryId,
        budgetedAmount: new Decimal(categoryRequest.budgetedAmount),
        description: categoryRequest.description,
        notes: categoryRequest.notes,
        createdBy
      };

      // This would be saved to a BudgetCategoryEntry entity
      // For now, we'll store it in the budget
      if (!savedBudget.categories) {
        savedBudget.categories = [];
      }
      savedBudget.categories.push(budgetCategoryEntry as any);
    }

    const finalBudget = await this.budgetRepository.save(savedBudget);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Budget',
      entityType: 'Budget',
      entityId: finalBudget.id,
      action: 'CREATE',
      details: {
        budgetName: request.budgetName,
        budgetType: request.budgetType,
        budgetYear: request.budgetYear,
        totalBudgetedRevenue: request.totalBudgetedRevenue,
        totalBudgetedExpenses: request.totalBudgetedExpenses
      },
      userId: createdBy
    });

    // Send notification
    await this.notificationService.sendNotification({
      message: 'Budget created',
      type: 'budget_created',
      recipients: ['finance_team', 'management_team'],
      data: {
        budgetId: finalBudget.id,
        budgetName: request.budgetName,
        budgetType: request.budgetType,
        budgetYear: request.budgetYear
      }
    });

    // Emit event
    this.eventEmitter.emit('budget.created', {
      budgetId: finalBudget.id,
      budgetName: request.budgetName,
      budgetType: request.budgetType,
      budgetYear: request.budgetYear
    });

    logger.info('Budget created', {
      budgetId: finalBudget.id,
      budgetName: request.budgetName,
      budgetType: request.budgetType,
      budgetYear: request.budgetYear,
      createdBy
    });

    return finalBudget;
  }

  /**
   * Get budget by ID
   */
  async getBudgetById(budgetId: string): Promise<Budget | null> {
    return await this.budgetRepository.findOne({
      where: { id: budgetId },
      relations: ['categories']
    });
  }

  /**
   * Search budgets with criteria
   */
  async searchBudgets(criteria: BudgetSearchCriteria): Promise<Budget[]> {
    const queryBuilder = this.budgetRepository.createQueryBuilder('b');

    if (criteria.budgetName) {
      queryBuilder.andWhere('b.budgetName ILIKE :budgetName', { budgetName: `%${criteria.budgetName}%` });
    }

    if (criteria.status) {
      queryBuilder.andWhere('b.status = :status', { status: criteria.status });
    }

    if (criteria.budgetType) {
      queryBuilder.andWhere('b.budgetType = :budgetType', { budgetType: criteria.budgetType });
    }

    if (criteria.budgetYear) {
      queryBuilder.andWhere('b.budgetYear = :budgetYear', { budgetYear: criteria.budgetYear });
    }

    if (criteria.budgetPeriod) {
      queryBuilder.andWhere('b.budgetPeriod = :budgetPeriod', { budgetPeriod: criteria.budgetPeriod });
    }

    if (criteria.careHomeId) {
      queryBuilder.andWhere('b.careHomeId = :careHomeId', { careHomeId: criteria.careHomeId });
    }

    if (criteria.department) {
      queryBuilder.andWhere('b.department = :department', { department: criteria.department });
    }

    if (criteria.costCenter) {
      queryBuilder.andWhere('b.costCenter = :costCenter', { costCenter: criteria.costCenter });
    }

    if (criteria.createdAfter) {
      queryBuilder.andWhere('b.createdAt >= :createdAfter', { createdAfter: criteria.createdAfter });
    }

    if (criteria.createdBefore) {
      queryBuilder.andWhere('b.createdAt <= :createdBefore', { createdBefore: criteria.createdBefore });
    }

    if (criteria.startDateAfter) {
      queryBuilder.andWhere('b.startDate >= :startDateAfter', { startDateAfter: criteria.startDateAfter });
    }

    if (criteria.startDateBefore) {
      queryBuilder.andWhere('b.startDate <= :startDateBefore', { startDateBefore: criteria.startDateBefore });
    }

    if (criteria.endDateAfter) {
      queryBuilder.andWhere('b.endDate >= :endDateAfter', { endDateAfter: criteria.endDateAfter });
    }

    if (criteria.endDateBefore) {
      queryBuilder.andWhere('b.endDate <= :endDateBefore', { endDateBefore: criteria.endDateBefore });
    }

    if (criteria.createdBy) {
      queryBuilder.andWhere('b.createdBy = :createdBy', { createdBy: criteria.createdBy });
    }

    if (criteria.approvedBy) {
      queryBuilder.andWhere('b.approvedBy = :approvedBy', { approvedBy: criteria.approvedBy });
    }

    return await queryBuilder
      .leftJoinAndSelect('b.categories', 'categories')
      .orderBy('b.createdAt', 'DESC')
      .getMany();
  }

  /**
   * Update budget
   */
  async updateBudget(
    budgetId: string,
    updates: BudgetUpdate,
    updatedBy: string
  ): Promise<Budget> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found');
    }

    if (budget.status === BudgetStatus.APPROVED) {
      throw new Error('Cannot update approved budget');
    }

    // Update fields
    Object.assign(budget, updates);
    budget.updatedBy = updatedBy;

    const updatedBudget = await this.budgetRepository.save(budget);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Budget',
      entityType: 'Budget',
      entityId: budgetId,
      action: 'UPDATE',
      details: updates,
      userId: updatedBy
    });

    // Emit event
    this.eventEmitter.emit('budget.updated', {
      budgetId,
      updates,
      updatedBy
    });

    logger.info('Budget updated', {
      budgetId,
      updates,
      updatedBy
    });

    return updatedBudget;
  }

  /**
   * Submit budget for approval
   */
  async submitBudgetForApproval(
    budgetId: string,
    submittedBy: string
  ): Promise<Budget> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found');
    }

    if (budget.status !== BudgetStatus.DRAFT) {
      throw new Error('Only draft budgets can be submitted for approval');
    }

    // Update budget status
    budget.status = BudgetStatus.PENDING_APPROVAL;
    budget.submittedAt = new Date();
    budget.submittedBy = submittedBy;

    const submittedBudget = await this.budgetRepository.save(budget);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Budget',
      entityType: 'Budget',
      entityId: budgetId,
      action: 'SUBMIT_FOR_APPROVAL',
      details: { submittedBy },
      userId: submittedBy
    });

    // Send notification
    await this.notificationService.sendNotification({
      message: 'Budget submitted for approval',
      type: 'budget_submitted_for_approval',
      recipients: ['management_team', 'finance_team'],
      data: {
        budgetId,
        budgetName: budget.budgetName,
        budgetType: budget.budgetType,
        budgetYear: budget.budgetYear,
        submittedBy
      }
    });

    // Emit event
    this.eventEmitter.emit('budget.submitted_for_approval', {
      budgetId,
      budgetName: budget.budgetName,
      budgetType: budget.budgetType,
      budgetYear: budget.budgetYear,
      submittedBy
    });

    logger.info('Budget submitted for approval', {
      budgetId,
      budgetName: budget.budgetName,
      budgetType: budget.budgetType,
      budgetYear: budget.budgetYear,
      submittedBy
    });

    return submittedBudget;
  }

  /**
   * Approve budget
   */
  async approveBudget(
    budgetId: string,
    approvedBy: string,
    approvalNotes?: string
  ): Promise<Budget> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found');
    }

    if (budget.status !== BudgetStatus.PENDING_APPROVAL) {
      throw new Error('Only pending budgets can be approved');
    }

    // Update budget status
    budget.status = BudgetStatus.APPROVED;
    budget.approvedAt = new Date();
    budget.approvedBy = approvedBy;
    budget.approvalNotes = approvalNotes;

    const approvedBudget = await this.budgetRepository.save(budget);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Budget',
      entityType: 'Budget',
      entityId: budgetId,
      action: 'APPROVE',
      details: { approvedBy, approvalNotes },
      userId: approvedBy
    });

    // Send notification
    await this.notificationService.sendNotification({
      message: 'Budget approved',
      type: 'budget_approved',
      recipients: ['finance_team', 'management_team'],
      data: {
        budgetId,
        budgetName: budget.budgetName,
        budgetType: budget.budgetType,
        budgetYear: budget.budgetYear,
        approvedBy
      }
    });

    // Emit event
    this.eventEmitter.emit('budget.approved', {
      budgetId,
      budgetName: budget.budgetName,
      budgetType: budget.budgetType,
      budgetYear: budget.budgetYear,
      approvedBy
    });

    logger.info('Budget approved', {
      budgetId,
      budgetName: budget.budgetName,
      budgetType: budget.budgetType,
      budgetYear: budget.budgetYear,
      approvedBy
    });

    return approvedBudget;
  }

  /**
   * Reject budget
   */
  async rejectBudget(
    budgetId: string,
    reason: string,
    rejectedBy: string
  ): Promise<Budget> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found');
    }

    if (budget.status !== BudgetStatus.PENDING_APPROVAL) {
      throw new Error('Only pending budgets can be rejected');
    }

    // Update budget status
    budget.status = BudgetStatus.REJECTED;
    budget.rejectedAt = new Date();
    budget.rejectedBy = rejectedBy;
    budget.rejectionReason = reason;

    const rejectedBudget = await this.budgetRepository.save(budget);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Budget',
      entityType: 'Budget',
      entityId: budgetId,
      action: 'REJECT',
      details: { reason },
      userId: rejectedBy
    });

    // Send notification
    await this.notificationService.sendNotification({
      message: 'Budget rejected',
      type: 'budget_rejected',
      recipients: ['finance_team', 'management_team'],
      data: {
        budgetId,
        budgetName: budget.budgetName,
        budgetType: budget.budgetType,
        budgetYear: budget.budgetYear,
        reason,
        rejectedBy
      }
    });

    logger.info('Budget rejected', {
      budgetId,
      budgetName: budget.budgetName,
      budgetType: budget.budgetType,
      budgetYear: budget.budgetYear,
      reason,
      rejectedBy
    });

    return rejectedBudget;
  }

  /**
   * Get budget report
   */
  async getBudgetReport(careHomeId?: string): Promise<BudgetReport> {
    const queryBuilder = this.budgetRepository.createQueryBuilder('b');

    if (careHomeId) {
      queryBuilder.andWhere('b.careHomeId = :careHomeId', { careHomeId });
    }

    const budgets = await queryBuilder.getMany();

    const totalBudgets = budgets.length;
    const activeBudgets = budgets.filter(b => b.status === BudgetStatus.APPROVED).length;
    const draftBudgets = budgets.filter(b => b.status === BudgetStatus.DRAFT).length;
    const approvedBudgets = budgets.filter(b => b.status === BudgetStatus.APPROVED).length;
    const rejectedBudgets = budgets.filter(b => b.status === BudgetStatus.REJECTED).length;

    const totalBudgetedRevenue = budgets.reduce((sum, b) => sum + b.totalBudgetedRevenue.toNumber(), 0);
    const totalBudgetedExpenses = budgets.reduce((sum, b) => sum + b.totalBudgetedExpenses.toNumber(), 0);
    const totalBudgetedProfit = budgets.reduce((sum, b) => sum + b.totalBudgetedProfit.toNumber(), 0);

    // Budgets by type
    const budgetsByType = Object.values(BudgetType).reduce((acc, type) => {
      acc[type] = budgets.filter(b => b.budgetType === type).length;
      return acc;
    }, {} as { [key in BudgetType]: number });

    // Budgets by status
    const budgetsByStatus = Object.values(BudgetStatus).reduce((acc, status) => {
      acc[status] = budgets.filter(b => b.status === status).length;
      return acc;
    }, {} as { [key in BudgetStatus]: number });

    // Department breakdown
    const departmentBreakdown = budgets.reduce((acc, b) => {
      const dept = b.department || 'Unknown';
      acc[dept] = (acc[dept] || 0) + 1;
      return acc;
    }, {} as { [department: string]: number });

    // Cost center breakdown
    const costCenterBreakdown = budgets.reduce((acc, b) => {
      const costCenter = b.costCenter || 'Unknown';
      acc[costCenter] = (acc[costCenter] || 0) + 1;
      return acc;
    }, {} as { [costCenter: string]: number });

    // Year breakdown
    const yearBreakdown = budgets.reduce((acc, b) => {
      acc[b.budgetYear] = (acc[b.budgetYear] || 0) + 1;
      return acc;
    }, {} as { [year: number]: number });

    const averageBudgetSize = totalBudgets > 0 ? totalBudgetedRevenue / totalBudgets : 0;

    // Variance analysis (simplified - would need actual vs budgeted data)
    const varianceAnalysis = {
      totalVariance: 0, // Would calculate actual vs budgeted
      revenueVariance: 0,
      expenseVariance: 0,
      profitVariance: 0
    };

    return {
      totalBudgets,
      activeBudgets,
      draftBudgets,
      approvedBudgets,
      rejectedBudgets,
      totalBudgetedRevenue,
      totalBudgetedExpenses,
      totalBudgetedProfit,
      budgetsByType,
      budgetsByStatus,
      departmentBreakdown,
      costCenterBreakdown,
      yearBreakdown,
      averageBudgetSize,
      varianceAnalysis
    };
  }

  /**
   * Delete budget
   */
  async deleteBudget(budgetId: string, deletedBy: string): Promise<void> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found');
    }

    if (budget.status === BudgetStatus.APPROVED) {
      throw new Error('Cannot delete approved budget');
    }

    // Soft delete
    await this.budgetRepository.softDelete(budgetId);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'Budget',
      entityType: 'Budget',
      entityId: budgetId,
      action: 'DELETE',
      details: { budgetName: budget.budgetName, budgetYear: budget.budgetYear },
      userId: deletedBy
    });

    logger.info('Budget deleted', {
      budgetId,
      budgetName: budget.budgetName,
      budgetYear: budget.budgetYear,
      deletedBy
    });
  }

  /**
   * Bulk update budget status
   */
  async bulkUpdateBudgetStatus(
    budgetIds: string[],
    status: BudgetStatus,
    updatedBy: string,
    notes?: string
  ): Promise<number> {
    let updatedCount = 0;

    for (const budgetId of budgetIds) {
      try {
        await this.updateBudget(budgetId, { status, notes }, updatedBy);
        updatedCount++;
      } catch (error) {
        logger.error('Failed to update budget', {
          budgetId,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return updatedCount;
  }

  /**
   * Get budget performance report
   */
  async getBudgetPerformanceReport(budgetId: string): Promise<BudgetPerformanceReport> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found.');
    }

    // This would typically involve querying actual financial data
    // For now, return a mock report structure
    return {
      budgetId: budget.id,
      budgetName: budget.budgetName,
      budgetYear: budget.budgetYear,
      totalBudgeted: budget.totalBudgetedAmount.toNumber(),
      totalActual: 0, // Would be calculated from actual transactions
      variance: 0,
      variancePercentage: 0,
      performanceByCategory: [],
      monthlyBreakdown: [],
      isOnTrack: true,
      recommendations: []
    };
  }

  /**
   * Get budget variance report
   */
  async getBudgetVarianceReport(budgetId: string): Promise<BudgetVarianceReport> {
    const budget = await this.getBudgetById(budgetId);
    if (!budget) {
      throw new Error('Budget not found.');
    }

    // This would typically involve querying actual financial data
    // For now, return a mock report structure
    return {
      budgetId: budget.id,
      budgetName: budget.budgetName,
      budgetYear: budget.budgetYear,
      totalVariance: 0,
      variancePercentage: 0,
      favorableVariances: [],
      unfavorableVariances: [],
      significantVariances: [],
      recommendations: []
    };
  }
}

export default BudgetService;