import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Family Engagement Service
 * @module FamilyEngagementService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive service for family engagement, communication,
 * and real-time updates about resident care and wellbeing.
 * 
 * @compliance
 * - CQC Regulation 10 - Dignity and respect
 * - CQC Regulation 11 - Need for consent
 * - GDPR and Data Protection Act 2018
 * - Mental Capacity Act 2005
 */

import { Injectable, Logger, HttpException, HttpStatus } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Cron, CronExpression } from '@nestjs/schedule';
import { FamilyMember } from '../../entities/family/FamilyMember';
import { FamilyMessage } from '../../entities/family/FamilyMessage';
import { CareUpdate } from '../../entities/family/CareUpdate';
import { VisitRequest } from '../../entities/family/VisitRequest';
import { FamilyFeedback } from '../../entities/family/FamilyFeedback';
import { Resident } from '../../entities/resident/Resident';
import { NotificationService } from '../notifications/NotificationService';
import { EncryptionService } from '../encryption/EncryptionService';
import { AuditTrailService } from '../audit/AuditTrailService';

interface FamilyEngagementConfig {
  enableRealTimeUpdates: boolean;
  updateFrequency: number; // minutes
  allowVideoRequests: boolean;
  enablePhotoSharing: boolean;
  maxDocumentSize: number; // MB
}

interface UpdatePreferences {
  dailyCareUpdates: boolean;
  medicalUpdates: boolean;
  activityUpdates: boolean;
  incidentNotifications: boolean;
  appointmentReminders: boolean;
  emergencyAlerts: boolean;
}


export class FamilyEngagementService {
  // Logger removed

  constructor(
    
    private readonly familyMemberRepository: Repository<FamilyMember>,
    
    private readonly familyMessageRepository: Repository<FamilyMessage>,
    
    private readonly careUpdateRepository: Repository<CareUpdate>,
    
    private readonly visitRequestRepository: Repository<VisitRequest>,
    
    private readonly familyFeedbackRepository: Repository<FamilyFeedback>,
    
    private readonly residentRepository: Repository<Resident>,
    private readonly notificationService: NotificationService,
    private readonly encryptionService: EncryptionService,
    private readonly auditTrailService: AuditTrailService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Get resident profile for family portal
   */
  async getResidentProfile(residentId: string, familyId: string): Promise<any> {
    try {
      // Verify family access to resident
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId, residentId },
        relations: ['resident'],
      });

      if (!familyMember) {
        throw new HttpException('Access denied to resident information', HttpStatus.FORBIDDEN);
      }

      const resident = await this.residentRepository.findOne({
        where: { id: residentId },
        select: [
          'id', 'firstName', 'lastName', 'roomNumber', 'admissionDate',
          'careLevel', 'primaryContact', 'emergencyContact'
        ],
      });

      if (!resident) {
        throw new HttpException('Resident not found', HttpStatus.NOT_FOUND);
      }

      await this.auditTrailService.log({
        action: 'FAMILY_PROFILE_ACCESS',
        entityType: 'Resident',
        entityId: residentId,
        userId: familyId,
        metadata: { accessType: 'family_portal' },
      });

      return {
        ...resident,
        lastUpdated: new Date(),
        familyAccessLevel: familyMember.accessLevel,
      };
    } catch (error: unknown) {
      console.error(`Failed to get resident profile: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get recent care updates for resident
   */
  async getCareUpdates(residentId: string, familyId: string, days: number = 7): Promise<CareUpdate[]> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const careUpdates = await this.careUpdateRepository.find({
        where: {
          residentId,
          careDate: Between(startDate, new Date()),
        },
        order: { careDate: 'DESC' },
        take: 20,
      });

      // Decrypt sensitive information for authorized family
      const decryptedUpdates = await Promise.all(
        careUpdates.map(async (update) => ({
          ...update,
          staffNotes: await this.encryptionService.decrypt(update.encryptedStaffNotes),
          medicalNotes: update.encryptedMedicalNotes 
            ? await this.encryptionService.decrypt(update.encryptedMedicalNotes)
            : undefined,
        }))
      );

      await this.auditTrailService.log({
        action: 'FAMILY_CARE_UPDATES_ACCESS',
        entityType: 'CareUpdate',
        entityId: residentId,
        userId: familyId,
        metadata: { daysRequested: days, updatesReturned: careUpdates.length },
      });

      return decryptedUpdates;
    } catch (error: unknown) {
      console.error(`Failed to get care updates: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get upcoming events and appointments
   */
  async getUpcomingEvents(residentId: string, familyId: string): Promise<UpcomingEvent[]> {
    try {
      await this.verifyFamilyAccess(familyId, residentId);

      // Get events from multiple sources
      const [appointments, activities, visits, therapies] = await Promise.all([
        this.getUpcomingAppointments(residentId),
        this.getUpcomingActivities(residentId),
        this.getScheduledVisits(residentId),
        this.getTherapySessions(residentId),
      ]);

      const allEvents = [...appointments, ...activities, ...visits, ...therapies]
        .sort((a, b) => a.scheduledTime.getTime() - b.scheduledTime.getTime())
        .slice(0, 10);

      await this.auditTrailService.log({
        action: 'FAMILY_EVENTS_ACCESS',
        entityType: 'Event',
        entityId: residentId,
        userId: familyId,
        metadata: { eventsReturned: allEvents.length },
      });

      return allEvents;
    } catch (error: unknown) {
      console.error(`Failed to get upcoming events: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get family messages
   */
  async getFamilyMessages(familyId: string, residentId: string): Promise<FamilyMessage[]> {
    try {
      await this.verifyFamilyAccess(familyId, residentId);

      const messages = await this.familyMessageRepository.find({
        where: { familyId, residentId },
        order: { createdAt: 'DESC' },
        take: 50,
      });

      // Decrypt message content
      const decryptedMessages = await Promise.all(
        messages.map(async (message) => ({
          ...message,
          content: await this.encryptionService.decrypt(message.encryptedContent),
        }))
      );

      await this.auditTrailService.log({
        action: 'FAMILY_MESSAGES_ACCESS',
        entityType: 'FamilyMessage',
        entityId: residentId,
        userId: familyId,
        metadata: { messagesReturned: messages.length },
      });

      return decryptedMessages;
    } catch (error: unknown) {
      console.error(`Failed to get family messages: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Send message from family to care team
   */
  async sendFamilyMessage(
    familyId: string,
    residentId: string,
    messageData: { subject: string; content: string; priority: string }
  ): Promise<FamilyMessage> {
    try {
      await this.verifyFamilyAccess(familyId, residentId);

      const encryptedContent = await this.encryptionService.encrypt(messageData.content);

      const message = this.familyMessageRepository.create({
        familyId,
        residentId,
        subject: messageData.subject,
        encryptedContent,
        priority: messageData.priority as any,
        fromFamily: true,
        read: false,
        createdAt: new Date(),
      });

      const savedMessage = await this.familyMessageRepository.save(message);

      // Notify care team
      await this.notificationService.sendNotification({
        message: 'Notification: FAMILY MESSAGE',
        type: 'FAMILY_MESSAGE',
        title: `New message from family: ${messageData.subject}`,
        message: `Family member has sent a ${messageData.priority} priority message`,
        recipients: await this.getCareTeamForResident(residentId),
        metadata: {
          residentId,
          familyId,
          messageId: savedMessage.id,
        },
      });

      await this.auditTrailService.log({
        action: 'FAMILY_MESSAGE_SENT',
        entityType: 'FamilyMessage',
        entityId: savedMessage.id,
        userId: familyId,
        metadata: { 
          residentId,
          subject: messageData.subject,
          priority: messageData.priority,
        },
      });

      // Emit real-time event
      this.eventEmitter.emit('family.message.sent', {
        residentId,
        familyId,
        messageId: savedMessage.id,
        priority: messageData.priority,
      });

      return {
        ...savedMessage,
        content: messageData.content, // Return decrypted for response
      };
    } catch (error: unknown) {
      console.error(`Failed to send family message: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Request video call with resident
   */
  async requestVideoCall(
    familyId: string,
    residentId: string,
    requestData: { preferredTime: Date; duration: number; participants: string[] }
  ): Promise<VisitRequest> {
    try {
      await this.verifyFamilyAccess(familyId, residentId);

      const visitRequest = this.visitRequestRepository.create({
        familyId,
        residentId,
        type: 'video_call',
        preferredTime: requestData.preferredTime,
        duration: requestData.duration,
        participants: requestData.participants,
        status: 'pending',
        requestedAt: new Date(),
      });

      const savedRequest = await this.visitRequestRepository.save(visitRequest);

      // Notify care team
      await this.notificationService.sendNotification({
        message: 'Notification: VIDEO CALL REQUEST',
        type: 'VIDEO_CALL_REQUEST',
        title: 'New video call request',
        message: `Family member has requested a video call for ${requestData.preferredTime.toLocaleString()}`,
        recipients: await this.getCareTeamForResident(residentId),
        metadata: {
          residentId,
          familyId,
          requestId: savedRequest.id,
          preferredTime: requestData.preferredTime,
        },
      });

      await this.auditTrailService.log({
        action: 'VIDEO_CALL_REQUESTED',
        entityType: 'VisitRequest',
        entityId: savedRequest.id,
        userId: familyId,
        metadata: { 
          residentId,
          preferredTime: requestData.preferredTime,
          duration: requestData.duration,
        },
      });

      return savedRequest;
    } catch (error: unknown) {
      console.error(`Failed to request video call: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Submit family feedback
   */
  async submitFamilyFeedback(
    familyId: string,
    residentId: string,
    feedbackData: { type: string; rating: number; comments: string; anonymous: boolean }
  ): Promise<FamilyFeedback> {
    try {
      await this.verifyFamilyAccess(familyId, residentId);

      const encryptedComments = await this.encryptionService.encrypt(feedbackData.comments);

      const feedback = this.familyFeedbackRepository.create({
        familyId: feedbackData.anonymous ? null : familyId,
        residentId,
        type: feedbackData.type,
        rating: feedbackData.rating,
        encryptedComments,
        anonymous: feedbackData.anonymous,
        submittedAt: new Date(),
      });

      const savedFeedback = await this.familyFeedbackRepository.save(feedback);

      // Notify management team for ratings below 4
      if (feedbackData.rating < 4) {
        await this.notificationService.sendNotification({
          message: 'Notification: LOW RATING FEEDBACK',
        type: 'LOW_RATING_FEEDBACK',
          title: 'Low rating feedback received',
          message: `Family feedback rating: ${feedbackData.rating}/5 for ${feedbackData.type}`,
          recipients: await this.getManagementTeam(),
          metadata: {
            residentId,
            familyId: feedbackData.anonymous ? 'anonymous' : familyId,
            rating: feedbackData.rating,
            type: feedbackData.type,
          },
        });
      }

      await this.auditTrailService.log({
        action: 'FAMILY_FEEDBACK_SUBMITTED',
        entityType: 'FamilyFeedback',
        entityId: savedFeedback.id,
        userId: feedbackData.anonymous ? 'anonymous' : familyId,
        metadata: { 
          residentId,
          type: feedbackData.type,
          rating: feedbackData.rating,
          anonymous: feedbackData.anonymous,
        },
      });

      return {
        ...savedFeedback,
        comments: feedbackData.comments, // Return decrypted for response
      };
    } catch (error: unknown) {
      console.error(`Failed to submit family feedback: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Mark message as read
   */
  async markMessageAsRead(messageId: string, familyId: string): Promise<void> {
    try {
      const message = await this.familyMessageRepository.findOne({
        where: { id: messageId, familyId },
      });

      if (!message) {
        throw new HttpException('Message not found', HttpStatus.NOT_FOUND);
      }

      await this.familyMessageRepository.update(messageId, {
        read: true,
        readAt: new Date(),
      });

      await this.auditTrailService.log({
        action: 'FAMILY_MESSAGE_READ',
        entityType: 'FamilyMessage',
        entityId: messageId,
        userId: familyId,
        metadata: { residentId: message.residentId },
      });

      // Emit real-time event
      this.eventEmitter.emit('family.message.read', {
        messageId,
        familyId,
        residentId: message.residentId,
      });
    } catch (error: unknown) {
      console.error(`Failed to mark message as read: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Create daily care update for family
   */
  async createCareUpdate(
    residentId: string,
    updateData: {
      activities: string[];
      meals: any;
      mood: string;
      socialInteraction: string;
      physicalActivity: string;
      medicalNotes?: string;
      photos?: string[];
      staffNotes: string;
      staffId: string;
    }
  ): Promise<CareUpdate> {
    try {
      const encryptedStaffNotes = await this.encryptionService.encrypt(updateData.staffNotes);
      const encryptedMedicalNotes = updateData.medicalNotes 
        ? await this.encryptionService.encrypt(updateData.medicalNotes)
        : null;

      const careUpdate = this.careUpdateRepository.create({
        residentId,
        careDate: new Date(),
        activities: updateData.activities,
        meals: updateData.meals,
        mood: updateData.mood as any,
        socialInteraction: updateData.socialInteraction,
        physicalActivity: updateData.physicalActivity,
        encryptedMedicalNotes,
        photos: updateData.photos || [],
        encryptedStaffNotes,
        staffId: updateData.staffId,
        createdAt: new Date(),
      });

      const savedUpdate = await this.careUpdateRepository.save(careUpdate);

      // Notify family members
      const familyMembers = await this.getFamilyMembersForResident(residentId);
      const notifications = familyMembers
        .filter(member => member.preferences.dailyCareUpdates)
        .map(member => ({
          type: 'DAILY_CARE_UPDATE',
          title: 'Daily care update available',
          message: `New care update for ${new Date().toLocaleDateString()}`,
          recipients: [member.email],
          metadata: {
            residentId,
            updateId: savedUpdate.id,
            mood: updateData.mood,
          },
        }));

      await Promise.all(notifications.map(notification => 
        this.notificationService.sendNotification(notification)
      ));

      await this.auditTrailService.log({
        action: 'CARE_UPDATE_CREATED',
        entityType: 'CareUpdate',
        entityId: savedUpdate.id,
        userId: updateData.staffId,
        metadata: { 
          residentId,
          mood: updateData.mood,
          activitiesCount: updateData.activities.length,
        },
      });

      // Emit real-time event
      this.eventEmitter.emit('care.update.created', {
        residentId,
        updateId: savedUpdate.id,
        mood: updateData.mood,
      });

      return savedUpdate;
    } catch (error: unknown) {
      console.error(`Failed to create care update: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Send update notification to family
   */
  async sendFamilyNotification(
    residentId: string,
    notificationData: {
      type: string;
      title: string;
      message: string;
      priority: 'low' | 'medium' | 'high' | 'urgent';
      requiresAcknowledgment?: boolean;
    }
  ): Promise<void> {
    try {
      const familyMembers = await this.getFamilyMembersForResident(residentId);
      
      // Filter based on notification preferences
      const relevantMembers = familyMembers.filter(member => {
        switch (notificationData.type) {
          case 'medical':
            return member.preferences.medicalUpdates;
          case 'activity':
            return member.preferences.activityUpdates;
          case 'incident':
            return member.preferences.incidentNotifications;
          case 'appointment':
            return member.preferences.appointmentReminders;
          case 'emergency':
            return member.preferences.emergencyAlerts;
          default:
            return true;
        }
      });

      // Create encrypted message for each family member
      const messages = relevantMembers.map(member => ({
        familyId: member.id,
        residentId,
        subject: notificationData.title,
        encryptedContent: this.encryptionService.encrypt(notificationData.message),
        priority: notificationData.priority,
        fromFamily: false,
        requiresAcknowledgment: notificationData.requiresAcknowledgment || false,
        read: false,
        createdAt: new Date(),
      }));

      await this.familyMessageRepository.save(messages);

      // Send immediate notifications for high priority
      if (notificationData.priority === 'high' || notificationData.priority === 'urgent') {
        const notifications = relevantMembers.map(member => ({
          type: 'URGENT_FAMILY_NOTIFICATION',
          title: notificationData.title,
          message: notificationData.message,
          recipients: [member.email, member.phone],
          metadata: {
            residentId,
            familyId: member.id,
            priority: notificationData.priority,
          },
        }));

        await Promise.all(notifications.map(notification => 
          this.notificationService.sendNotification(notification)
        ));
      }

      await this.auditTrailService.log({
        action: 'FAMILY_NOTIFICATION_SENT',
        entityType: 'FamilyMessage',
        entityId: residentId,
        userId: 'system',
        metadata: { 
          type: notificationData.type,
          priority: notificationData.priority,
          recipientsCount: relevantMembers.length,
        },
      });

      // Emit real-time event
      this.eventEmitter.emit('family.notification.sent', {
        residentId,
        type: notificationData.type,
        priority: notificationData.priority,
        recipientsCount: relevantMembers.length,
      });
    } catch (error: unknown) {
      console.error(`Failed to send family notification: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get family documents and reports
   */
  async getFamilyDocuments(residentId: string, familyId: string): Promise<any[]> {
    try {
      await this.verifyFamilyAccess(familyId, residentId);

      // Get documents from document management service
      const documents = await this.getAuthorizedDocuments(residentId, familyId);

      await this.auditTrailService.log({
        action: 'FAMILY_DOCUMENTS_ACCESS',
        entityType: 'Document',
        entityId: residentId,
        userId: familyId,
        metadata: { documentsReturned: documents.length },
      });

      return documents;
    } catch (error: unknown) {
      console.error(`Failed to get family documents: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Update family notification preferences
   */
  async updateNotificationPreferences(
    familyId: string,
    preferences: UpdatePreferences
  ): Promise<void> {
    try {
      await this.familyMemberRepository.update(familyId, {
        preferences,
        updatedAt: new Date(),
      });

      await this.auditTrailService.log({
        action: 'FAMILY_PREFERENCES_UPDATED',
        entityType: 'FamilyMember',
        entityId: familyId,
        userId: familyId,
        metadata: { preferences },
      });
    } catch (error: unknown) {
      console.error(`Failed to update notification preferences: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Automated daily care summaries
   */
  @Cron(CronExpression.EVERY_DAY_AT_6PM)
  async sendDailyCareUpdates(): Promise<void> {
    try {
      console.log('Starting daily care update notifications');

      // Get all residents with family members who want daily updates
      const residents = await this.residentRepository.find({
        relations: ['familyMembers'],
      });

      for (const resident of residents) {
        const familyMembers = resident.familyMembers?.filter(
          member => member.preferences.dailyCareUpdates
        );

        if (familyMembers && familyMembers.length > 0) {
          // Get today's care update
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const tomorrow = new Date(today);
          tomorrow.setDate(tomorrow.getDate() + 1);

          const careUpdate = await this.careUpdateRepository.findOne({
            where: {
              residentId: resident.id,
              careDate: Between(today, tomorrow),
            },
          });

          if (careUpdate) {
            await this.sendFamilyNotification(resident.id, {
              type: 'daily_summary',
              title: 'Daily care summary',
              message: `Daily care summary is now available for ${today.toLocaleDateString()}`,
              priority: 'low',
            });
          }
        }
      }

      console.log('Daily care update notifications completed');
    } catch (error: unknown) {
      console.error(`Failed to send daily care updates: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
    }
  }

  /**
   * Emergency notification system
   */
  async sendEmergencyNotification(
    residentId: string,
    emergencyData: {
      type: 'medical' | 'incident' | 'transfer' | 'other';
      severity: 'low' | 'medium' | 'high' | 'critical';
      description: string;
      immediateActions: string[];
      contactRequired: boolean;
    }
  ): Promise<void> {
    try {
      const familyMembers = await this.getFamilyMembersForResident(residentId);
      const emergencyContacts = familyMembers.filter(
        member => member.preferences.emergencyAlerts
      );

      if (emergencyContacts.length === 0) {
        console.warn(`No emergency contacts found for resident ${residentId}`);
        return;
      }

      // Create urgent messages
      const messages = emergencyContacts.map(member => ({
        familyId: member.id,
        residentId,
        subject: `URGENT: ${emergencyData.type.toUpperCase()} - ${emergencyData.severity.toUpperCase()}`,
        encryptedContent: this.encryptionService.encrypt(
          `${emergencyData.description}\n\nImmediate actions taken:\n${emergencyData.immediateActions.join('\n')}`
        ),
        priority: 'urgent' as const,
        fromFamily: false,
        requiresAcknowledgment: true,
        read: false,
        createdAt: new Date(),
      }));

      await this.familyMessageRepository.save(messages);

      // Send immediate multi-channel notifications
      const notifications = emergencyContacts.map(member => ({
        type: 'EMERGENCY_ALERT',
        title: `URGENT: ${emergencyData.type.toUpperCase()}`,
        message: emergencyData.description,
        recipients: [member.email, member.phone],
        channels: ['email', 'sms', 'push'] as const,
        metadata: {
          residentId,
          familyId: member.id,
          severity: emergencyData.severity,
          contactRequired: emergencyData.contactRequired,
        },
      }));

      await Promise.all(notifications.map(notification => 
        this.notificationService.sendUrgentNotification(notification)
      ));

      await this.auditTrailService.log({
        action: 'EMERGENCY_NOTIFICATION_SENT',
        entityType: 'Emergency',
        entityId: residentId,
        userId: 'system',
        metadata: { 
          type: emergencyData.type,
          severity: emergencyData.severity,
          recipientsCount: emergencyContacts.length,
        },
      });

      // Emit real-time emergency event
      this.eventEmitter.emit('emergency.notification.sent', {
        residentId,
        type: emergencyData.type,
        severity: emergencyData.severity,
        recipientsCount: emergencyContacts.length,
      });
    } catch (error: unknown) {
      console.error(`Failed to send emergency notification: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  // Private helper methods
  private async verifyFamilyAccess(familyId: string, residentId: string): Promise<void> {
    const familyMember = await this.familyMemberRepository.findOne({
      where: { id: familyId, residentId },
    });

    if (!familyMember) {
      throw new HttpException('Access denied to resident information', HttpStatus.FORBIDDEN);
    }
  }

  private async getFamilyMembersForResident(residentId: string): Promise<FamilyMember[]> {
    return this.familyMemberRepository.find({
      where: { residentId },
      relations: ['preferences'],
    });
  }

  private async getCareTeamForResident(residentId: string): Promise<string[]> {
    // Implementation would fetch care team members for the resident
    // This would integrate with HR management service
    return ['care-manager@example.com', 'senior-carer@example.com'];
  }

  private async getManagementTeam(): Promise<string[]> {
    return ['manager@example.com', 'deputy-manager@example.com'];
  }

  private async getUpcomingAppointments(residentId: string): Promise<UpcomingEvent[]> {
    // Integration with appointment scheduling system
    return [];
  }

  private async getUpcomingActivities(residentId: string): Promise<UpcomingEvent[]> {
    // Integration with activities management system
    return [];
  }

  private async getScheduledVisits(residentId: string): Promise<UpcomingEvent[]> {
    // Integration with visitor management system
    return [];
  }

  private async getTherapySessions(residentId: string): Promise<UpcomingEvent[]> {
    // Integration with therapy management system
    return [];
  }

  private async getAuthorizedDocuments(residentId: string, familyId: string): Promise<any[]> {
    // Integration with document management service
    // Return documents that family is authorized to access
    return [];
  }
}