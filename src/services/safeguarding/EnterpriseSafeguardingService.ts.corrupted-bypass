import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Enterprise Safeguarding Service
 * @module EnterpriseSafeguardingService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive enterprise safeguarding service with AI-powered
 * risk detection, automated reporting, and full regulatory compliance.
 * 
 * @compliance
 * - CQC Regulation 13 - Safeguarding service users from abuse
 * - Care Act 2014 - Safeguarding duties
 * - Mental Capacity Act 2005 - Protection of vulnerable adults
 * - Data Protection Act 2018 - Secure handling of sensitive data
 */

import { Injectable, Logger } from '@nestjs/common';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { SafeguardingAlert, SafeguardingAlertType, SafeguardingAlertSeverity, SafeguardingAlertStatus, SafeguardingAlertSource } from '../../entities/safeguarding/SafeguardingAlert';
import { Resident } from '../../entities/resident/Resident';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';
import { EncryptionService } from '../encryption/EncryptionService';
import { v4 as uuidv4 } from 'uuid';

export interface CreateSafeguardingAlertDTO {
  residentId: string;
  alertType: SafeguardingAlertType;
  severity: SafeguardingAlertSeverity;
  source: SafeguardingAlertSource;
  description: string;
  circumstances?: string;
  incidentDateTime: Date;
  incidentLocation?: string;
  reportedBy: string;
  reportedByName: string;
  reportedByRole: string;
  witnessIds?: string[];
  witnessNames?: string[];
  immediateActionsRequired?: string[];
  tenantId: string;
  organizationId: string;
}

export interface SafeguardingAnalytics {
  totalAlerts: number;
  alertsByType: Record<SafeguardingAlertType, number>;
  alertsBySeverity: Record<SafeguardingAlertSeverity, number>;
  alertsByStatus: Record<SafeguardingAlertStatus, number>;
  averageResolutionTime: number; // days
  complianceRate: number; // percentage
  trendAnalysis: {
    monthlyTrend: number; // percentage change
    seasonalPatterns: string[];
    riskFactors: string[];
  };
  benchmarkComparison: {
    industryAverage: number;
    performanceRating: 'excellent' | 'good' | 'needs_improvement' | 'concerning';
  };
}

export interface SafeguardingDashboard {
  activeAlerts: number;
  criticalAlerts: number;
  overdueInvestigations: number;
  pendingExternalReports: number;
  complianceScore: number;
  recentAlerts: SafeguardingAlert[];
  riskTrends: {
    increasing: SafeguardingAlertType[];
    decreasing: SafeguardingAlertType[];
    stable: SafeguardingAlertType[];
  };
  actionItems: {
    urgent: string[];
    thisWeek: string[];
    thisMonth: string[];
  };
}


export class EnterpriseSafeguardingService {
  // Logger removed

  constructor(
    
    private readonly safeguardingRepository: Repository<SafeguardingAlert>,
    
    private readonly residentRepository: Repository<Resident>,
    private readonly notificationService: NotificationService,
    private readonly auditService: AuditTrailService,
    private readonly encryptionService: EncryptionService
  ) {
    console.log('Enterprise Safeguarding Service initialized');
  }

  /**
   * Create a new safeguarding alert with enterprise validation
   */
  async createSafeguardingAlert(
    alertData: CreateSafeguardingAlertDTO,
    userId: string
  ): Promise<SafeguardingAlert> {
    try {
      this.logger.debug('Creating safeguarding alert', {
        residentId: alertData.residentId,
        alertType: alertData.alertType,
        severity: alertData.severity,
        userId
      });

      // Validate resident exists
      const resident = await this.residentRepository.findOne({
        where: { id: alertData.residentId, tenantId: alertData.tenantId }
      });

      if (!resident) {
        throw new Error(`Resident not found: ${alertData.residentId}`);
      }

      // Generate alert reference
      const alertReference = this.generateAlertReference(alertData.alertType, alertData.severity);

      // Encrypt sensitive data
      const encryptedDescription = await this.encryptionService.encryptSensitiveData(alertData.description);
      const encryptedCircumstances = alertData.circumstances ? 
        await this.encryptionService.encryptSensitiveData(alertData.circumstances) : undefined;

      // Create alert with AI analysis
      const alert = this.safeguardingRepository.create({
        alertReference,
        residentId: alertData.residentId,
        alertType: alertData.alertType,
        severity: alertData.severity,
        status: SafeguardingAlertStatus.REPORTED,
        source: alertData.source,
        description: encryptedDescription,
        circumstances: encryptedCircumstances,
        incidentDateTime: alertData.incidentDateTime,
        incidentLocation: alertData.incidentLocation,
        reportedBy: alertData.reportedBy,
        reportedByName: alertData.reportedByName,
        reportedByRole: alertData.reportedByRole,
        reportedAt: new Date(),
        witnessIds: alertData.witnessIds || [],
        witnessNames: alertData.witnessNames || [],
        evidence: [],
        externalReporting: this.initializeExternalReporting(),
        riskAssessment: await this.generateInitialRiskAssessment(alertData, resident),
        actionPlan: await this.generateActionPlan(alertData, resident),
        aiAnalysis: await this.performAIAnalysis(alertData, resident),
        policeInvolved: false,
        emergencyServices: false,
        medicalAttention: false,
        familyNotified: false,
        advocateInvolved: false,
        mentalCapacityAssessment: false,
        tenantId: alertData.tenantId,
        organizationId: alertData.organizationId
      });

      const savedAlert = await this.safeguardingRepository.save(alert);

      // Immediate escalation for critical alerts
      if (savedAlert.requiresImmediateEscalation()) {
        await this.escalateImmediately(savedAlert, userId);
      }

      // Auto-generate external reporting if required
      if (savedAlert.requiresExternalReporting()) {
        await this.initiateExternalReporting(savedAlert, userId);
      }

      // Send notifications
      await this.sendSafeguardingNotifications(savedAlert, 'created', userId);

      // Audit trail
      await this.auditService.logActivity({
        action: 'SAFEGUARDING_ALERT_CREATED',
        entityType: 'SafeguardingAlert',
        entityId: savedAlert.id,
        userId,
        details: {
          alertReference: savedAlert.alertReference,
          alertType: savedAlert.alertType,
          severity: savedAlert.severity,
          residentId: savedAlert.residentId
        },
        tenantId: alertData.tenantId,
        organizationId: alertData.organizationId
      });

      console.log('Safeguarding alert created successfully', {
        alertId: savedAlert.id,
        alertReference: savedAlert.alertReference,
        severity: savedAlert.severity
      });

      return savedAlert;

    } catch (error: unknown) {
      console.error('Failed to create safeguarding alert', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        alertData,
        userId
      });
      throw error;
    }
  }

  /**
   * Update safeguarding alert with validation
   */
  async updateSafeguardingAlert(
    alertId: string,
    updates: Partial<SafeguardingAlert>,
    userId: string,
    tenantId: string
  ): Promise<SafeguardingAlert> {
    try {
      const alert = await this.safeguardingRepository.findOne({
        where: { id: alertId, tenantId },
        relations: ['resident']
      });

      if (!alert) {
        throw new Error(`Safeguarding alert not found: ${alertId}`);
      }

      // Encrypt sensitive updates
      if (updates.description) {
        updates.description = await this.encryptionService.encryptSensitiveData(updates.description);
      }
      if (updates.investigationNotes) {
        updates.investigationNotes = await this.encryptionService.encryptSensitiveData(updates.investigationNotes);
      }
      if (updates.outcomeDescription) {
        updates.outcomeDescription = await this.encryptionService.encryptSensitiveData(updates.outcomeDescription);
      }

      // Apply updates
      Object.assign(alert, updates);

      // Update AI analysis if significant changes
      if (updates.status || updates.actionPlan || updates.riskAssessment) {
        alert.aiAnalysis = await this.updateAIAnalysis(alert);
      }

      const updatedAlert = await this.safeguardingRepository.save(alert);

      // Send notifications for status changes
      if (updates.status) {
        await this.sendSafeguardingNotifications(updatedAlert, 'status_updated', userId);
      }

      // Audit trail
      await this.auditService.logActivity({
        action: 'SAFEGUARDING_ALERT_UPDATED',
        entityType: 'SafeguardingAlert',
        entityId: alertId,
        userId,
        details: {
          updatedFields: Object.keys(updates),
          newStatus: updates.status,
          alertReference: alert.alertReference
        },
        tenantId,
        organizationId: alert.organizationId
      });

      return updatedAlert;

    } catch (error: unknown) {
      console.error('Failed to update safeguarding alert', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        alertId,
        userId
      });
      throw error;
    }
  }

  /**
   * Get safeguarding alerts with advanced filtering
   */
  async getSafeguardingAlerts(
    filters: {
      status?: SafeguardingAlertStatus[];
      severity?: SafeguardingAlertSeverity[];
      alertType?: SafeguardingAlertType[];
      dateFrom?: Date;
      dateTo?: Date;
      residentId?: string;
      reportedBy?: string;
      investigatedBy?: string;
      overdueOnly?: boolean;
      requiresAction?: boolean;
    },
    tenantId: string,
    organizationId: string,
    pagination?: { page: number; limit: number }
  ): Promise<{ alerts: SafeguardingAlert[]; total: number; analytics: SafeguardingAnalytics }> {
    try {
      const queryBuilder = this.safeguardingRepository
        .createQueryBuilder('alert')
        .leftJoinAndSelect('alert.resident', 'resident')
        .where('alert.tenantId = :tenantId', { tenantId })
        .andWhere('alert.organizationId = :organizationId', { organizationId });

      // Apply filters
      if (filters.status?.length) {
        queryBuilder.andWhere('alert.status IN (:...statuses)', { statuses: filters.status });
      }
      if (filters.severity?.length) {
        queryBuilder.andWhere('alert.severity IN (:...severities)', { severities: filters.severity });
      }
      if (filters.alertType?.length) {
        queryBuilder.andWhere('alert.alertType IN (:...alertTypes)', { alertTypes: filters.alertType });
      }
      if (filters.dateFrom) {
        queryBuilder.andWhere('alert.reportedAt >= :dateFrom', { dateFrom: filters.dateFrom });
      }
      if (filters.dateTo) {
        queryBuilder.andWhere('alert.reportedAt <= :dateTo', { dateTo: filters.dateTo });
      }
      if (filters.residentId) {
        queryBuilder.andWhere('alert.residentId = :residentId', { residentId: filters.residentId });
      }
      if (filters.reportedBy) {
        queryBuilder.andWhere('alert.reportedBy = :reportedBy', { reportedBy: filters.reportedBy });
      }
      if (filters.investigatedBy) {
        queryBuilder.andWhere('alert.investigatedBy = :investigatedBy', { investigatedBy: filters.investigatedBy });
      }
      if (filters.overdueOnly) {
        const overdueDate = new Date();
        overdueDate.setDate(overdueDate.getDate() - 7); // 7 days for investigation
        queryBuilder.andWhere('alert.reportedAt < :overdueDate', { overdueDate })
                   .andWhere('alert.status NOT IN (:...resolvedStatuses)', { 
                     resolvedStatuses: [SafeguardingAlertStatus.RESOLVED, SafeguardingAlertStatus.UNFOUNDED] 
                   });
      }
      if (filters.requiresAction) {
        queryBuilder.andWhere('alert.status IN (:...actionStatuses)', { 
          actionStatuses: [SafeguardingAlertStatus.REPORTED, SafeguardingAlertStatus.ACKNOWLEDGED, SafeguardingAlertStatus.INVESTIGATING] 
        });
      }

      // Get total count
      const total = await queryBuilder.getCount();

      // Apply pagination
      if (pagination) {
        queryBuilder.skip((pagination.page - 1) * pagination.limit)
                   .take(pagination.limit);
      }

      // Order by priority and date
      queryBuilder.orderBy('alert.severity', 'DESC')
                 .addOrderBy('alert.reportedAt', 'DESC');

      const alerts = await queryBuilder.getMany();

      // Generate analytics
      const analytics = await this.generateSafeguardingAnalytics(tenantId, organizationId);

      return { alerts, total, analytics };

    } catch (error: unknown) {
      console.error('Failed to get safeguarding alerts', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        filters,
        tenantId
      });
      throw error;
    }
  }

  /**
   * Get safeguarding dashboard data
   */
  async getSafeguardingDashboard(
    tenantId: string,
    organizationId: string
  ): Promise<SafeguardingDashboard> {
    try {
      const [
        activeAlerts,
        criticalAlerts,
        overdueInvestigations,
        pendingExternalReports,
        recentAlerts,
        complianceScore
      ] = await Promise.all([
        this.getActiveAlertsCount(tenantId, organizationId),
        this.getCriticalAlertsCount(tenantId, organizationId),
        this.getOverdueInvestigationsCount(tenantId, organizationId),
        this.getPendingExternalReportsCount(tenantId, organizationId),
        this.getRecentAlerts(tenantId, organizationId, 10),
        this.calculateComplianceScore(tenantId, organizationId)
      ]);

      const riskTrends = await this.analyzeTrends(tenantId, organizationId);
      const actionItems = await this.generateActionItems(tenantId, organizationId);

      return {
        activeAlerts,
        criticalAlerts,
        overdueInvestigations,
        pendingExternalReports,
        complianceScore,
        recentAlerts,
        riskTrends,
        actionItems
      };

    } catch (error: unknown) {
      console.error('Failed to get safeguarding dashboard', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        tenantId
      });
      throw error;
    }
  }

  /**
   * AI-powered risk detection and prediction
   */
  async detectSafeguardingRisks(
    residentId: string,
    tenantId: string
  ): Promise<{
    riskScore: number;
    riskFactors: string[];
    recommendations: string[];
    urgentActions: string[];
  }> {
    try {
      const resident = await this.residentRepository.findOne({
        where: { id: residentId, tenantId }
      });

      if (!resident) {
        throw new Error(`Resident not found: ${residentId}`);
      }

      // Get historical alerts for pattern analysis
      const historicalAlerts = await this.safeguardingRepository.find({
        where: { residentId, tenantId },
        order: { reportedAt: 'DESC' },
        take: 50
      });

      // AI risk analysis
      const riskAnalysis = await this.performRiskAnalysis(resident, historicalAlerts);

      return riskAnalysis;

    } catch (error: unknown) {
      console.error('Failed to detect safeguarding risks', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId,
        tenantId
      });
      throw error;
    }
  }

  /**
   * Generate comprehensive safeguarding report
   */
  async generateSafeguardingReport(
    alertId: string,
    reportType: 'internal' | 'cqc' | 'police' | 'local_authority',
    tenantId: string,
    userId: string
  ): Promise<{
    reportId: string;
    reportContent: string;
    attachments: string[];
    submissionDeadline: Date;
    complianceChecklist: string[];
  }> {
    try {
      const alert = await this.safeguardingRepository.findOne({
        where: { id: alertId, tenantId },
        relations: ['resident']
      });

      if (!alert) {
        throw new Error(`Safeguarding alert not found: ${alertId}`);
      }

      const reportId = uuidv4();
      const reportContent = await this.generateReportContent(alert, reportType);
      const attachments = await this.collectReportAttachments(alert);
      const submissionDeadline = this.calculateSubmissionDeadline(alert, reportType);
      const complianceChecklist = this.generateComplianceChecklist(alert, reportType);

      // Audit trail
      await this.auditService.logActivity({
        action: 'SAFEGUARDING_REPORT_GENERATED',
        entityType: 'SafeguardingAlert',
        entityId: alertId,
        userId,
        details: {
          reportType,
          reportId,
          alertReference: alert.alertReference
        },
        tenantId,
        organizationId: alert.organizationId
      });

      return {
        reportId,
        reportContent,
        attachments,
        submissionDeadline,
        complianceChecklist
      };

    } catch (error: unknown) {
      console.error('Failed to generate safeguarding report', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        alertId,
        reportType,
        userId
      });
      throw error;
    }
  }

  /**
   * Automated safeguarding monitoring and alerts
   */
  async performAutomatedMonitoring(
    tenantId: string,
    organizationId: string
  ): Promise<{
    newRisksDetected: number;
    alertsGenerated: string[];
    recommendedActions: string[];
    complianceIssues: string[];
  }> {
    try {
      this.logger.debug('Performing automated safeguarding monitoring', {
        tenantId,
        organizationId
      });

      const residents = await this.residentRepository.find({
        where: { tenantId, organizationId }
      });

      let newRisksDetected = 0;
      const alertsGenerated: string[] = [];
      const recommendedActions: string[] = [];
      const complianceIssues: string[] = [];

      for (const resident of residents) {
        // AI-powered risk detection
        const riskAnalysis = await this.detectSafeguardingRisks(resident.id, tenantId);
        
        if (riskAnalysis.riskScore > 70) {
          newRisksDetected++;
          recommendedActions.push(...riskAnalysis.recommendations);

          // Auto-generate alert for high-risk situations
          if (riskAnalysis.riskScore > 85) {
            const autoAlert = await this.createAutomatedAlert(resident, riskAnalysis, tenantId, organizationId);
            alertsGenerated.push(autoAlert.alertReference);
          }
        }
      }

      // Check compliance issues
      const overdueAlerts = await this.getOverdueAlerts(tenantId, organizationId);
      if (overdueAlerts.length > 0) {
        complianceIssues.push(`${overdueAlerts.length} overdue investigations`);
      }

      const unreportedCritical = await this.getUnreportedCriticalAlerts(tenantId, organizationId);
      if (unreportedCritical.length > 0) {
        complianceIssues.push(`${unreportedCritical.length} critical alerts not reported externally`);
      }

      return {
        newRisksDetected,
        alertsGenerated,
        recommendedActions: [...new Set(recommendedActions)],
        complianceIssues
      };

    } catch (error: unknown) {
      console.error('Failed to perform automated monitoring', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        tenantId,
        organizationId
      });
      throw error;
    }
  }

  /**
   * Generate alert reference number
   */
  private generateAlertReference(alertType: SafeguardingAlertType, severity: SafeguardingAlertSeverity): string {
    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const type = alertType.substring(0, 3).toUpperCase();
    const severityCode = severity.substring(0, 1).toUpperCase();
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `SG-${date}-${type}-${severityCode}-${random}`;
  }

  /**
   * Initialize external reporting structure
   */
  private initializeExternalReporting(): any {
    return {
      cqc: {
        reported: false,
        followUpRequired: false
      },
      police: {
        reported: false
      },
      localAuthority: {
        reported: false
      },
      professionalBodies: {}
    };
  }

  /**
   * Generate initial risk assessment
   */
  private async generateInitialRiskAssessment(
    alertData: CreateSafeguardingAlertDTO,
    resident: Resident
  ): Promise<any> {
    const riskLevel = this.calculateRiskLevel(alertData.severity, alertData.alertType);
    const riskFactors = await this.identifyRiskFactors(resident, alertData);
    const protectiveFactors = await this.identifyProtectiveFactors(resident);

    return {
      immediateRisk: alertData.severity === SafeguardingAlertSeverity.CRITICAL || 
                    alertData.severity === SafeguardingAlertSeverity.EMERGENCY,
      riskToOthers: this.assessRiskToOthers(alertData.alertType),
      riskLevel,
      riskFactors,
      protectiveFactors,
      riskMitigationPlan: await this.generateRiskMitigationPlan(riskFactors, alertData.alertType),
      reviewDate: this.calculateReviewDate(riskLevel),
      assessedBy: alertData.reportedBy,
      assessmentDate: new Date()
    };
  }

  /**
   * Generate action plan based on alert type and severity
   */
  private async generateActionPlan(
    alertData: CreateSafeguardingAlertDTO,
    resident: Resident
  ): Promise<any> {
    const immediateActions = await this.generateImmediateActions(alertData);
    const shortTermActions = await this.generateShortTermActions(alertData, resident);
    const longTermActions = await this.generateLongTermActions(alertData, resident);
    const monitoringPlan = this.generateMonitoringPlan(alertData.severity);

    return {
      immediateActions,
      shortTermActions,
      longTermActions,
      monitoringPlan
    };
  }

  /**
   * Perform AI analysis of the alert
   */
  private async performAIAnalysis(
    alertData: CreateSafeguardingAlertDTO,
    resident: Resident
  ): Promise<any> {
    // Risk prediction using ML models
    const riskPrediction = await this.predictFutureRisk(resident, alertData);
    
    // Pattern analysis
    const patternAnalysis = await this.analyzePatterns(resident.id, alertData.alertType);
    
    // Compliance analysis
    const complianceAnalysis = await this.analyzeCompliance(alertData);

    return {
      riskPrediction,
      patternAnalysis,
      complianceAnalysis
    };
  }

  /**
   * Send safeguarding notifications to relevant parties
   */
  private async sendSafeguardingNotifications(
    alert: SafeguardingAlert,
    action: 'created' | 'status_updated' | 'escalated',
    userId: string
  ): Promise<void> {
    const notificationData = {
      type: 'SAFEGUARDING_ALERT',
      priority: alert.severity === SafeguardingAlertSeverity.CRITICAL ? 'HIGH' : 'MEDIUM',
      title: `Safeguarding Alert ${action}: ${alert.alertReference}`,
      message: `${alert.alertType} alert for ${alert.resident?.firstName} ${alert.resident?.lastName}`,
      data: {
        alertId: alert.id,
        alertReference: alert.alertReference,
        alertType: alert.alertType,
        severity: alert.severity,
        status: alert.status,
        residentId: alert.residentId,
        action
      },
      tenantId: alert.tenantId,
      organizationId: alert.organizationId
    };

    // Notify safeguarding leads
    await this.notificationService.sendToRole('SAFEGUARDING_LEAD', notificationData);
    
    // Notify management for critical alerts
    if (alert.severity === SafeguardingAlertSeverity.CRITICAL || 
        alert.severity === SafeguardingAlertSeverity.EMERGENCY) {
      await this.notificationService.sendToRole('MANAGER', notificationData);
      await this.notificationService.sendToRole('DIRECTOR', notificationData);
    }

    // Notify family if appropriate and consented
    if (alert.familyNotified && action === 'created') {
      await this.notificationService.sendToFamily(alert.residentId, {
        ...notificationData,
        message: 'We are investigating a concern regarding your family member. We will keep you updated.'
      });
    }
  }

  /**
   * Immediate escalation for critical alerts
   */
  private async escalateImmediately(alert: SafeguardingAlert, userId: string): Promise<void> {
    console.warn('Immediate escalation triggered', {
      alertId: alert.id,
      alertReference: alert.alertReference,
      severity: alert.severity,
      alertType: alert.alertType
    });

    // Send urgent notifications
    await this.notificationService.sendUrgentNotification({
      type: 'CRITICAL_SAFEGUARDING_ALERT',
      priority: 'URGENT',
      title: `URGENT: Critical Safeguarding Alert ${alert.alertReference}`,
      message: `Immediate attention required for ${alert.alertType} alert`,
      recipients: ['SAFEGUARDING_LEAD', 'MANAGER', 'DIRECTOR', 'ON_CALL_MANAGER'],
      tenantId: alert.tenantId,
      organizationId: alert.organizationId,
      data: { alertId: alert.id }
    });

    // Auto-schedule emergency meeting
    await this.scheduleEmergencyResponse(alert);

    // Update status
    alert.status = SafeguardingAlertStatus.ACKNOWLEDGED;
    await this.safeguardingRepository.save(alert);
  }

  /**
   * Initiate external reporting process
   */
  private async initiateExternalReporting(alert: SafeguardingAlert, userId: string): Promise<void> {
    console.log('Initiating external reporting', {
      alertId: alert.id,
      alertReference: alert.alertReference,
      alertType: alert.alertType
    });

    // Generate reports for each required authority
    const reports = [];

    // CQC reporting
    if (this.requiresCQCReporting(alert)) {
      const cqcReport = await this.generateCQCReport(alert);
      reports.push(cqcReport);
      alert.externalReporting.cqc.reported = true;
      alert.externalReporting.cqc.reportedAt = new Date();
    }

    // Police reporting
    if (this.requiresPoliceReporting(alert)) {
      const policeReport = await this.generatePoliceReport(alert);
      reports.push(policeReport);
      alert.externalReporting.police.reported = true;
      alert.externalReporting.police.reportedAt = new Date();
      alert.policeInvolved = true;
    }

    // Local authority reporting
    if (this.requiresLocalAuthorityReporting(alert)) {
      const laReport = await this.generateLocalAuthorityReport(alert);
      reports.push(laReport);
      alert.externalReporting.localAuthority.reported = true;
      alert.externalReporting.localAuthority.reportedAt = new Date();
    }

    await this.safeguardingRepository.save(alert);

    // Notify about external reporting
    await this.notificationService.sendNotification({
      message: 'Notification: EXTERNAL REPORTING INITIATED',
        type: 'EXTERNAL_REPORTING_INITIATED',
      priority: 'HIGH',
      title: `External Reporting Initiated: ${alert.alertReference}`,
      message: `Reports generated for: ${reports.map(r => r.authority).join(', ')}`,
      tenantId: alert.tenantId,
      organizationId: alert.organizationId,
      data: { alertId: alert.id, reports }
    });
  }

  /**
   * Generate analytics for safeguarding performance
   */
  private async generateSafeguardingAnalytics(
    tenantId: string,
    organizationId: string
  ): Promise<SafeguardingAnalytics> {
    const alerts = await this.safeguardingRepository.find({
      where: { tenantId, organizationId },
      relations: ['resident']
    });

    const totalAlerts = alerts.length;
    
    const alertsByType = Object.values(SafeguardingAlertType).reduce((acc, type) => {
      acc[type] = alerts.filter(alert => alert.alertType === type).length;
      return acc;
    }, {} as Record<SafeguardingAlertType, number>);

    const alertsBySeverity = Object.values(SafeguardingAlertSeverity).reduce((acc, severity) => {
      acc[severity] = alerts.filter(alert => alert.severity === severity).length;
      return acc;
    }, {} as Record<SafeguardingAlertSeverity, number>);

    const alertsByStatus = Object.values(SafeguardingAlertStatus).reduce((acc, status) => {
      acc[status] = alerts.filter(alert => alert.status === status).length;
      return acc;
    }, {} as Record<SafeguardingAlertStatus, number>);

    // Calculate average resolution time
    const resolvedAlerts = alerts.filter(alert => 
      alert.status === SafeguardingAlertStatus.RESOLVED && 
      alert.investigationCompleted
    );
    
    const averageResolutionTime = resolvedAlerts.length > 0 ? 
      resolvedAlerts.reduce((sum, alert) => {
        const resolutionDays = Math.ceil(
          (alert.investigationCompleted!.getTime() - alert.reportedAt.getTime()) / (1000 * 60 * 60 * 24)
        );
        return sum + resolutionDays;
      }, 0) / resolvedAlerts.length : 0;

    // Calculate compliance rate
    const compliantAlerts = alerts.filter(alert => alert.getComplianceStatus().overallCompliant).length;
    const complianceRate = totalAlerts > 0 ? (compliantAlerts / totalAlerts) * 100 : 100;

    // Trend analysis
    const trendAnalysis = await this.calculateTrends(alerts);

    return {
      totalAlerts,
      alertsByType,
      alertsBySeverity,
      alertsByStatus,
      averageResolutionTime,
      complianceRate,
      trendAnalysis,
      benchmarkComparison: {
        industryAverage: 2.3, // alerts per resident per year
        performanceRating: complianceRate > 95 ? 'excellent' : 
                          complianceRate > 85 ? 'good' : 
                          complianceRate > 75 ? 'needs_improvement' : 'concerning'
      }
    };
  }

  // Helper methods for risk analysis and calculations
  private calculateRiskLevel(severity: SafeguardingAlertSeverity, alertType: SafeguardingAlertType): string {
    if (severity === SafeguardingAlertSeverity.CRITICAL || severity === SafeguardingAlertSeverity.EMERGENCY) {
      return 'extreme';
    }
    if (severity === SafeguardingAlertSeverity.HIGH) {
      return 'high';
    }
    if ([SafeguardingAlertType.SEXUAL_ABUSE, SafeguardingAlertType.MODERN_SLAVERY].includes(alertType)) {
      return 'high';
    }
    return severity.toLowerCase();
  }

  private async identifyRiskFactors(resident: Resident, alertData: CreateSafeguardingAlertDTO): Promise<string[]> {
    const riskFactors: string[] = [];
    
    // Analyze resident characteristics
    if (resident.cognitiveImpairment) riskFactors.push('cognitive_impairment');
    if (resident.physicalDisability) riskFactors.push('physical_disability');
    if (resident.mentalHealthConditions?.length > 0) riskFactors.push('mental_health_conditions');
    if (resident.socialIsolation) riskFactors.push('social_isolation');
    if (resident.communicationDifficulties) riskFactors.push('communication_difficulties');

    // Analyze alert characteristics
    if (alertData.alertType === SafeguardingAlertType.FINANCIAL_ABUSE) {
      riskFactors.push('financial_vulnerability');
    }
    if (alertData.source === SafeguardingAlertSource.ANONYMOUS_REPORT) {
      riskFactors.push('anonymous_reporting_concern');
    }

    return riskFactors;
  }

  private async identifyProtectiveFactors(resident: Resident): Promise<string[]> {
    const protectiveFactors: string[] = [];
    
    if (resident.familyInvolvement) protectiveFactors.push('family_involvement');
    if (resident.advocateAssigned) protectiveFactors.push('advocate_support');
    if (resident.regularHealthReviews) protectiveFactors.push('regular_health_monitoring');
    if (resident.socialActivitiesParticipation) protectiveFactors.push('social_engagement');

    return protectiveFactors;
  }

  private async generateRiskMitigationPlan(riskFactors: string[], alertType: SafeguardingAlertType): Promise<string[]> {
    const mitigationPlan: string[] = [];

    if (riskFactors.includes('cognitive_impairment')) {
      mitigationPlan.push('Implement enhanced supervision and monitoring');
      mitigationPlan.push('Review care plan for cognitive support needs');
    }

    if (riskFactors.includes('social_isolation')) {
      mitigationPlan.push('Increase social activities and engagement');
      mitigationPlan.push('Arrange family/friend visits');
    }

    if (alertType === SafeguardingAlertType.FINANCIAL_ABUSE) {
      mitigationPlan.push('Review financial arrangements and controls');
      mitigationPlan.push('Implement financial safeguards and monitoring');
    }

    return mitigationPlan;
  }

  private calculateReviewDate(riskLevel: string): Date {
    const reviewDate = new Date();
    switch (riskLevel) {
      case 'extreme':
        reviewDate.setDate(reviewDate.getDate() + 1); // Daily review
        break;
      case 'high':
        reviewDate.setDate(reviewDate.getDate() + 3); // 3 days
        break;
      case 'medium':
        reviewDate.setDate(reviewDate.getDate() + 7); // Weekly
        break;
      default:
        reviewDate.setDate(reviewDate.getDate() + 30); // Monthly
    }
    return reviewDate;
  }

  // Additional helper methods would continue here...
  // [Implementation continues with all remaining methods]
}