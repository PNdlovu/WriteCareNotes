import { Injectable } from '@nestjs/common';import { Injectable } from '@nestjs/common';import { EventEmitter2 } from '@nestjs/event-emitter';import { EventEmitter2 } from '@nestjs/event-emitter';/**

import { EventEmitter2 } from '@nestjs/event-emitter';

import { EventEmitter2 } from '@nestjs/event-emitter';

export interface CreateHealthRecordRequest {

  patientId: string;import { Injectable } from '@nestjs/common';

  recordType: string;

  title: string;export interface CreateHealthRecordRequest {

  description: string;

  data: any;  patientId: string;import { logger } from '../../utils/logger';import { Injectable } from '@nestjs/common'; * @fileoverview Health Records Service for WriteCareNotes

  providerId: string;

  organizationId: string;  recordType: string;

}

  title: string;

export interface HealthRecord {

  id: string;  description: string;

  patientId: string;

  organizationId: string;  data: any;export interface CreateHealthRecordRequest {import { logger } from '../../utils/logger'; * @module HealthRecordsService

  providerId: string;

  recordType: string;  providerId: string;

  title: string;

  description: string;  organizationId: string;  patientId: string;

  data: any;

  status: string;}

  createdAt: Date;

  updatedAt: Date;  recordType: RecordType; * @version 1.0.0

}

export interface HealthRecord {

export class HealthRecordValidationError extends Error {

  constructor(message: string) {  id: string;  title: string;

    super(message);

    this.name = 'HealthRecordValidationError';  patientId: string;

  }

}  organizationId: string;  description: string;export interface CreateHealthRecordRequest { * @author WriteCareNotes Team



@Injectable()  providerId: string;

export class HealthRecordsService extends EventEmitter2 {

  private readonly healthRecords: Map<string, HealthRecord> = new Map();  recordType: string;  data: any;



  constructor() {  title: string;

    super();

  }  description: string;  providerId: string;  patientId: string; * @since 2025-01-09



  async createHealthRecord(request: CreateHealthRecordRequest): Promise<HealthRecord> {  data: any;

    this.validateCreateRequest(request);

  status: string;  organizationId: string;

    const recordId = this.generateRecordId();

    const now = new Date();  createdAt: Date;



    const record: HealthRecord = {  updatedAt: Date;  tags?: string[];  recordType: RecordType; * 

      id: recordId,

      patientId: request.patientId,}

      organizationId: request.organizationId,

      providerId: request.providerId,  priority?: RecordPriority;

      recordType: request.recordType,

      title: request.title,export class HealthRecordValidationError extends Error {

      description: request.description,

      data: request.data,  constructor(message: string) {}  title: string; * @description Comprehensive health record management system with vital signs tracking,

      status: 'active',

      createdAt: now,    super(message);

      updatedAt: now

    };    this.name = 'HealthRecordValidationError';



    this.healthRecords.set(recordId, record);  }



    this.emit('health-record.created', {}export interface UpdateHealthRecordRequest {  description: string; * automated alerts, clinical observation recording, health trend analysis, predictive indicators,

      recordId,

      patientId: request.patientId,

      recordType: request.recordType,

      providerId: request.providerId,@Injectable()  recordId: string;

      timestamp: now

    });export class HealthRecordsService extends EventEmitter2 {



    return record;  private readonly healthRecords: Map<string, HealthRecord> = new Map();  title?: string;  data: any; * and integration with medical devices and IoT sensors.

  }



  async getHealthRecord(recordId: string): Promise<HealthRecord | null> {

    return this.healthRecords.get(recordId) || null;  constructor() {  description?: string;

  }

    super();

  private validateCreateRequest(request: CreateHealthRecordRequest): void {

    if (!request.patientId?.trim()) {  }  data?: any;  providerId: string; * 

      throw new HealthRecordValidationError('Patient ID is required');

    }



    if (!request.title?.trim()) {  async createHealthRecord(request: CreateHealthRecordRequest): Promise<HealthRecord> {  status?: RecordStatus;

      throw new HealthRecordValidationError('Title is required');

    }    this.validateCreateRequest(request);



    if (!request.providerId?.trim()) {  tags?: string[];  organizationId: string; * @compliance

      throw new HealthRecordValidationError('Provider ID is required');

    }    const recordId = this.generateRecordId();



    if (!request.organizationId?.trim()) {    const now = new Date();  priority?: RecordPriority;

      throw new HealthRecordValidationError('Organization ID is required');

    }

  }

    const record: HealthRecord = {}  tags?: string[]; * - CQC (Care Quality Commission) - England

  private generateRecordId(): string {

    return `hr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;      id: recordId,

  }

}      patientId: request.patientId,

      organizationId: request.organizationId,

      providerId: request.providerId,export interface HealthRecordQuery {  priority?: RecordPriority; * - Care Inspectorate - Scotland  

      recordType: request.recordType,

      title: request.title,  patientId?: string;

      description: request.description,

      data: request.data,  organizationId?: string;} * - CIW (Care Inspectorate Wales) - Wales

      status: 'active',

      createdAt: now,  recordType?: RecordType;

      updatedAt: now

    };  status?: RecordStatus; * - RQIA (Regulation and Quality Improvement Authority) - Northern Ireland



    this.healthRecords.set(recordId, record);  dateFrom?: Date;



    this.emit('health-record.created', {  dateTo?: Date;export interface UpdateHealthRecordRequest { * - NICE Guidelines for Health Monitoring

      recordId,

      patientId: request.patientId,  providerId?: string;

      recordType: request.recordType,

      providerId: request.providerId,  tags?: string[];  recordId: string; * - NHS Digital Standards

      timestamp: now

    });  limit?: number;



    return record;  offset?: number;  title?: string; * - FHIR R4 Compatibility

  }

}

  async getHealthRecord(recordId: string): Promise<HealthRecord | null> {

    return this.healthRecords.get(recordId) || null;  description?: string; * - Medical Device Regulation (MDR)

  }

export interface VitalSignsData {

  private validateCreateRequest(request: CreateHealthRecordRequest): void {

    if (!request.patientId?.trim()) {  temperature?: number;  data?: any; * 

      throw new HealthRecordValidationError('Patient ID is required');

    }  bloodPressureSystolic?: number;



    if (!request.title?.trim()) {  bloodPressureDiastolic?: number;  status?: RecordStatus; * @security

      throw new HealthRecordValidationError('Title is required');

    }  heartRate?: number;



    if (!request.providerId?.trim()) {  respiratoryRate?: number;  tags?: string[]; * - Implements field-level encryption for sensitive health data

      throw new HealthRecordValidationError('Provider ID is required');

    }  oxygenSaturation?: number;



    if (!request.organizationId?.trim()) {  weight?: number;  priority?: RecordPriority; * - Comprehensive audit trails for all health record operations

      throw new HealthRecordValidationError('Organization ID is required');

    }  height?: number;

  }

  bmi?: number;} * - Role-based access control for clinical data

  private generateRecordId(): string {

    return `hr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;  timestamp: Date;

  }

}} * - Medical device data integrity validation



export interface ClinicalObservationData {export interface HealthRecordQuery { */

  observationType: string;

  value: string | number;  patientId?: string;

  unit?: string;

  normalRange?: string;  organizationId?: string;import { DataSource, Repository } from 'typeorm';

  severity?: ObservationSeverity;

  notes?: string;  recordType?: RecordType;import { validate, ValidationError } from 'class-validator';

  timestamp: Date;

}  status?: RecordStatus;import { HealthRecord, RecordType, RecordStatus } from '../../entities/health-records/HealthRecord';



export interface HealthAlertData {  dateFrom?: Date;import { VitalSigns, VitalSignType } from '../../entities/health-records/VitalSigns';

  alertType: AlertType;

  severity: AlertSeverity;  dateTo?: Date;import { ClinicalObservation, ObservationType, ObservationSeverity } from '../../entities/health-records/ClinicalObservation';

  message: string;

  triggerCondition: string;  providerId?: string;import { HealthAlert, AlertType, AlertSeverity, AlertStatus } from '../../entities/health-records/HealthAlert';

  recommendedAction?: string;

  autoResolved?: boolean;  tags?: string[];import { MedicalDevice, DeviceType, DeviceStatus } from '../../entities/health-records/MedicalDevice';

}

  limit?: number;import { HealthTrend, TrendType, TrendDirection } from '../../entities/health-records/HealthTrend';

export enum RecordType {

  VITAL_SIGNS = 'vital_signs',  offset?: number;import { Resident } from '../../entities/resident/Resident';

  CLINICAL_OBSERVATION = 'clinical_observation',

  MEDICATION = 'medication',}import { HealthRecordsRepository } from '../../repositories/health-records/HealthRecordsRepository';

  DIAGNOSIS = 'diagnosis',

  TREATMENT_PLAN = 'treatment_plan',import { VitalSignsRepository } from '../../repositories/health-records/VitalSignsRepository';

  LAB_RESULT = 'lab_result',

  IMAGING = 'imaging',export interface VitalSignsData {import { ClinicalObservationRepository } from '../../repositories/health-records/ClinicalObservationRepository';

  PROGRESS_NOTE = 'progress_note',

  DISCHARGE_SUMMARY = 'discharge_summary',  temperature?: number;import { HealthAlertRepository } from '../../repositories/health-records/HealthAlertRepository';

  HEALTH_ALERT = 'health_alert'

}  bloodPressureSystolic?: number;import { AuditTrailService } from '../audit/AuditTrailService';



export enum RecordStatus {  bloodPressureDiastolic?: number;import { FieldLevelEncryptionService } from '../encryption/FieldLevelEncryptionService';

  DRAFT = 'draft',

  ACTIVE = 'active',  heartRate?: number;import { NotificationService } from '../notifications/NotificationService';

  COMPLETED = 'completed',

  CANCELLED = 'cancelled',  respiratoryRate?: number;import { EventPublishingService } from '../events/EventPublishingService';

  ARCHIVED = 'archived'

}  oxygenSaturation?: number;import { HealthcareCacheManager } from '../caching/HealthcareCacheManager';



export enum RecordPriority {  weight?: number;import { logger } from '../../utils/logger';

  LOW = 'low',

  NORMAL = 'normal',  height?: number;

  HIGH = 'high',

  URGENT = 'urgent',  bmi?: number;export interface CreateHealthRecordRequest {

  CRITICAL = 'critical'

}  timestamp: Date;  residentId: string;



export enum AlertType {}  recordType: RecordType;

  VITAL_SIGNS_ABNORMAL = 'vital_signs_abnormal',

  MEDICATION_DUE = 'medication_due',  title: string;

  APPOINTMENT_REMINDER = 'appointment_reminder',

  TEST_RESULT_CRITICAL = 'test_result_critical',export interface ClinicalObservationData {  description?: string;

  TREATMENT_OVERDUE = 'treatment_overdue',

  SYSTEM_ALERT = 'system_alert'  observationType: string;  clinicalNotes?: string;

}

  value: string | number;  recordedBy: string;

export enum AlertSeverity {

  INFO = 'info',  unit?: string;  recordedAt?: Date;

  WARNING = 'warning',

  ERROR = 'error',  normalRange?: string;  attachments?: string[];

  CRITICAL = 'critical'

}  severity?: ObservationSeverity;  tags?: string[];



export enum ObservationSeverity {  notes?: string;}

  NORMAL = 'normal',

  MILD = 'mild',  timestamp: Date;

  MODERATE = 'moderate',

  SEVERE = 'severe',}export interface RecordVitalSignsRequest {

  CRITICAL = 'critical'

}  residentId: string;



export interface HealthRecord {export interface HealthAlertData {  vitalSigns: VitalSignReading[];

  id: string;

  patientId: string;  alertType: AlertType;  recordedBy: string;

  organizationId: string;

  providerId: string;  severity: AlertSeverity;  recordedAt?: Date;

  recordType: RecordType;

  title: string;  message: string;  deviceId?: string;

  description: string;

  data: any;  triggerCondition: string;  notes?: string;

  status: RecordStatus;

  priority: RecordPriority;  recommendedAction?: string;}

  tags: string[];

  createdAt: Date;  autoResolved?: boolean;

  updatedAt: Date;

  version: number;}export interface VitalSignReading {

  attachments?: string[];

}  type: VitalSignType;



export interface ValidationError {export enum RecordType {  value: number;

  field: string;

  message: string;  VITAL_SIGNS = 'vital_signs',  unit: string;

  code: string;

}  CLINICAL_OBSERVATION = 'clinical_observation',  isNormal: boolean;



export class HealthRecordValidationError extends Error {  MEDICATION = 'medication',  referenceRange?: {

  constructor(

    message: string,  DIAGNOSIS = 'diagnosis',    min: number;

    public validationErrors: ValidationError[]

  ) {  TREATMENT_PLAN = 'treatment_plan',    max: number;

    super(message);

    this.name = 'HealthRecordValidationError';  LAB_RESULT = 'lab_result',  };

  }

}  IMAGING = 'imaging',}



export class HealthRecordNotFoundError extends Error {  PROGRESS_NOTE = 'progress_note',

  constructor(recordId: string) {

    super(`Health record with ID ${recordId} not found`);  DISCHARGE_SUMMARY = 'discharge_summary',export interface CreateClinicalObservationRequest {

    this.name = 'HealthRecordNotFoundError';

  }  HEALTH_ALERT = 'health_alert'  residentId: string;

}

}  observationType: ObservationType;

export class UnauthorizedAccessError extends Error {

  constructor(message: string) {  title: string;

    super(message);

    this.name = 'UnauthorizedAccessError';export enum RecordStatus {  description: string;

  }

}  DRAFT = 'draft',  severity: ObservationSeverity;



@Injectable()  ACTIVE = 'active',  observedBy: string;

export class HealthRecordsService extends EventEmitter2 {

  private readonly healthRecords: Map<string, HealthRecord> = new Map();  COMPLETED = 'completed',  observedAt?: Date;

  private readonly alertRules: Map<string, any> = new Map();

  CANCELLED = 'cancelled',  followUpRequired: boolean;

  constructor() {

    super();  ARCHIVED = 'archived'  followUpDate?: Date;

    this.initializeDefaultAlertRules();

  }}  relatedConditions?: string[];



  /**}

   * Create a new health record

   */export enum RecordPriority {

  async createHealthRecord(request: CreateHealthRecordRequest): Promise<HealthRecord> {

    try {  LOW = 'low',export interface HealthRecordSearchFilters {

      this.validateCreateRequest(request);

  NORMAL = 'normal',  residentId?: string;

      const recordId = this.generateRecordId();

      const now = new Date();  HIGH = 'high',  recordType?: RecordType;



      const record: HealthRecord = {  URGENT = 'urgent',  status?: RecordStatus;

        id: recordId,

        patientId: request.patientId,  CRITICAL = 'critical'  dateFrom?: Date;

        organizationId: request.organizationId,

        providerId: request.providerId,}  dateTo?: Date;

        recordType: request.recordType,

        title: request.title,  recordedBy?: string;

        description: request.description,

        data: request.data,export enum AlertType {  tags?: string[];

        status: RecordStatus.ACTIVE,

        priority: request.priority || RecordPriority.NORMAL,  VITAL_SIGNS_ABNORMAL = 'vital_signs_abnormal',  hasAlerts?: boolean;

        tags: request.tags || [],

        createdAt: now,  MEDICATION_DUE = 'medication_due',}

        updatedAt: now,

        version: 1  APPOINTMENT_REMINDER = 'appointment_reminder',

      };

  TEST_RESULT_CRITICAL = 'test_result_critical',export interface VitalSignsAnalysis {

      this.healthRecords.set(recordId, record);

  TREATMENT_OVERDUE = 'treatment_overdue',  residentId: string;

      // Check for alerts based on the new record

      await this.checkAndCreateAlerts(record);  SYSTEM_ALERT = 'system_alert'  timeframe: {



      // Emit event for audit logging}    from: Date;

      this.emit('health-record.created', {

        recordId,    to: Date;

        patientId: request.patientId,

        recordType: request.recordType,export enum AlertSeverity {  };

        providerId: request.providerId,

        timestamp: now  INFO = 'info',  vitalSignTrends: VitalSignTrend[];

      });

  WARNING = 'warning',  alerts: HealthAlert[];

      logger.info(`Health record created: ${recordId} for patient ${request.patientId}`);

        ERROR = 'error',  abnormalReadings: VitalSignReading[];

      return record;

    } catch (error) {  CRITICAL = 'critical'  recommendations: string[];

      logger.error('Error creating health record:', error);

      throw error;}  riskIndicators: RiskIndicator[];

    }

  }}



  /**export enum ObservationSeverity {

   * Update an existing health record

   */  NORMAL = 'normal',export interface VitalSignTrend {

  async updateHealthRecord(request: UpdateHealthRecordRequest): Promise<HealthRecord> {

    try {  MILD = 'mild',  type: VitalSignType;

      const existingRecord = this.healthRecords.get(request.recordId);

      if (!existingRecord) {  MODERATE = 'moderate',  readings: VitalSignDataPoint[];

        throw new HealthRecordNotFoundError(request.recordId);

      }  SEVERE = 'severe',  trend: TrendDirection;



      this.validateUpdateRequest(request);  CRITICAL = 'critical'  averageValue: number;



      const updatedRecord: HealthRecord = {}  minValue: number;

        ...existingRecord,

        title: request.title ?? existingRecord.title,  maxValue: number;

        description: request.description ?? existingRecord.description,

        data: request.data ?? existingRecord.data,export interface HealthRecord {  standardDeviation: number;

        status: request.status ?? existingRecord.status,

        tags: request.tags ?? existingRecord.tags,  id: string;  isWithinNormalRange: boolean;

        priority: request.priority ?? existingRecord.priority,

        updatedAt: new Date(),  patientId: string;  concernLevel: 'low' | 'medium' | 'high' | 'critical';

        version: existingRecord.version + 1

      };  organizationId: string;}



      this.healthRecords.set(request.recordId, updatedRecord);  providerId: string;



      // Check for alerts based on the updated record  recordType: RecordType;export interface VitalSignDataPoint {

      await this.checkAndCreateAlerts(updatedRecord);

  title: string;  timestamp: Date;

      // Emit event for audit logging

      this.emit('health-record.updated', {  description: string;  value: number;

        recordId: request.recordId,

        patientId: updatedRecord.patientId,  data: any;  isNormal: boolean;

        changes: this.getChanges(existingRecord, updatedRecord),

        timestamp: new Date()  status: RecordStatus;  deviceId?: string;

      });

  priority: RecordPriority;}

      logger.info(`Health record updated: ${request.recordId}`);

        tags: string[];

      return updatedRecord;

    } catch (error) {  createdAt: Date;export interface RiskIndicator {

      logger.error('Error updating health record:', error);

      throw error;  updatedAt: Date;  type: string;

    }

  }  version: number;  severity: 'low' | 'medium' | 'high' | 'critical';



  /**  attachments?: string[];  description: string;

   * Get health record by ID

   */}  recommendations: string[];

  async getHealthRecord(recordId: string): Promise<HealthRecord> {

    const record = this.healthRecords.get(recordId);  requiresImmediateAction: boolean;

    if (!record) {

      throw new HealthRecordNotFoundError(recordId);export interface ValidationError {}

    }

    return record;  field: string;

  }

  message: string;export interface HealthTrendAnalysis {

  /**

   * Query health records with filters  code: string;  residentId: string;

   */

  async queryHealthRecords(query: HealthRecordQuery): Promise<HealthRecord[]> {}  analysisType: TrendType;

    try {

      let records = Array.from(this.healthRecords.values());  timeframe: {



      // Apply filtersexport class HealthRecordValidationError extends Error {    from: Date;

      if (query.patientId) {

        records = records.filter(r => r.patientId === query.patientId);  constructor(    to: Date;

      }

    message: string,  };

      if (query.organizationId) {

        records = records.filter(r => r.organizationId === query.organizationId);    public validationErrors: ValidationError[]  overallHealthTrend: TrendDirection;

      }

  ) {  keyIndicators: HealthIndicator[];

      if (query.recordType) {

        records = records.filter(r => r.recordType === query.recordType);    super(message);  predictiveInsights: PredictiveInsight[];

      }

    this.name = 'HealthRecordValidationError';  recommendations: string[];

      if (query.status) {

        records = records.filter(r => r.status === query.status);  }  nextReviewDate: Date;

      }

}}

      if (query.providerId) {

        records = records.filter(r => r.providerId === query.providerId);

      }

export class HealthRecordNotFoundError extends Error {export interface HealthIndicator {

      if (query.dateFrom) {

        records = records.filter(r => r.createdAt >= query.dateFrom!);  constructor(recordId: string) {  name: string;

      }

    super(`Health record with ID ${recordId} not found`);  currentValue: number;

      if (query.dateTo) {

        records = records.filter(r => r.createdAt <= query.dateTo!);    this.name = 'HealthRecordNotFoundError';  previousValue: number;

      }

  }  changePercentage: number;

      if (query.tags && query.tags.length > 0) {

        records = records.filter(r => }  trend: TrendDirection;

          query.tags!.some(tag => r.tags.includes(tag))

        );  isSignificant: boolean;

      }

export class UnauthorizedAccessError extends Error {  normalRange: {

      // Sort by creation date (newest first)

      records.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());  constructor(message: string) {    min: number;



      // Apply pagination    super(message);    max: number;

      const offset = query.offset || 0;

      const limit = query.limit || 50;    this.name = 'UnauthorizedAccessError';  };

      

      return records.slice(offset, offset + limit);  }}

    } catch (error) {

      logger.error('Error querying health records:', error);}

      throw error;

    }export interface PredictiveInsight {

  }

@Injectable()  type: string;

  /**

   * Delete a health record (archive it)export class HealthRecordsService extends EventEmitter2 {  prediction: string;

   */

  async deleteHealthRecord(recordId: string): Promise<void> {  private readonly healthRecords: Map<string, HealthRecord> = new Map();  confidence: number;

    try {

      const record = this.healthRecords.get(recordId);  private readonly alertRules: Map<string, any> = new Map();  timeframe: string;

      if (!record) {

        throw new HealthRecordNotFoundError(recordId);  actionRequired: boolean;

      }

  constructor() {  recommendations: string[];

      // Archive instead of delete for compliance

      const archivedRecord: HealthRecord = {    super();}export c

        ...record,

        status: RecordStatus.ARCHIVED,    this.initializeDefaultAlertRules();lass HealthRecordValidationError extends Error {

        updatedAt: new Date(),

        version: record.version + 1  }  constructor(

      };

    message: string,

      this.healthRecords.set(recordId, archivedRecord);

  /**    public validationErrors: ValidationError[]

      // Emit event for audit logging

      this.emit('health-record.archived', {   * Create a new health record  ) {

        recordId,

        patientId: record.patientId,   */    super(message);

        timestamp: new Date()

      });  async createHealthRecord(request: CreateHealthRecordRequest): Promise<HealthRecord> {    this.name = 'HealthRecordValidationError';



      logger.info(`Health record archived: ${recordId}`);    try {  }

    } catch (error) {

      logger.error('Error archiving health record:', error);      this.validateCreateRequest(request);}

      throw error;

    }

  }

      const recordId = this.generateRecordId();export class HealthRecordNotFoundError extends Error {

  /**

   * Record vital signs      const now = new Date();  constructor(recordId: string) {

   */

  async recordVitalSigns(patientId: string, vitalSigns: VitalSignsData, providerId: string, organizationId: string): Promise<HealthRecord> {    super(`Health record with ID ${recordId} not found`);

    const request: CreateHealthRecordRequest = {

      patientId,      const record: HealthRecord = {    this.name = 'HealthRecordNotFoundError';

      recordType: RecordType.VITAL_SIGNS,

      title: `Vital Signs - ${vitalSigns.timestamp.toISOString()}`,        id: recordId,  }

      description: 'Vital signs measurement',

      data: vitalSigns,        patientId: request.patientId,}

      providerId,

      organizationId,        organizationId: request.organizationId,

      priority: this.calculateVitalSignsPriority(vitalSigns)

    };        providerId: request.providerId,export class VitalSignsValidationError extends Error {



    return this.createHealthRecord(request);        recordType: request.recordType,  constructor(message: string) {

  }

        title: request.title,    super(message);

  /**

   * Record clinical observation        description: request.description,    this.name = 'VitalSignsValidationError';

   */

  async recordClinicalObservation(        data: request.data,  }

    patientId: string, 

    observation: ClinicalObservationData,         status: RecordStatus.ACTIVE,}

    providerId: string, 

    organizationId: string        priority: request.priority || RecordPriority.NORMAL,

  ): Promise<HealthRecord> {

    const request: CreateHealthRecordRequest = {        tags: request.tags || [],export class MedicalDeviceError extends Error {

      patientId,

      recordType: RecordType.CLINICAL_OBSERVATION,        createdAt: now,  constructor(message: string) {

      title: `Clinical Observation - ${observation.observationType}`,

      description: observation.notes || 'Clinical observation',        updatedAt: now,    super(message);

      data: observation,

      providerId,        version: 1    this.name = 'MedicalDeviceError';

      organizationId,

      priority: this.mapObservationSeverityToPriority(observation.severity)      };  }

    };

}

    return this.createHealthRecord(request);

  }      this.healthRecords.set(recordId, record);



  /**export class HealthRecordsService {

   * Get patient's health summary

   */      // Check for alerts based on the new record  private healthRecordsRepository: HealthRecordsRepository;

  async getPatientHealthSummary(patientId: string, organizationId: string): Promise<any> {

    try {      await this.checkAndCreateAlerts(record);  private vitalSignsRepository: VitalSignsRepository;

      const records = await this.queryHealthRecords({

        patientId,  private clinicalObservationRepository: ClinicalObservationRepository;

        organizationId,

        status: RecordStatus.ACTIVE,      // Emit event for audit logging  private healthAlertRepository: HealthAlertRepository;

        limit: 100

      });      this.emit('health-record.created', {  private residentRepository: Repository<Resident>;



      const summary = {        recordId,  private medicalDeviceRepository: Repository<MedicalDevice>;

        totalRecords: records.length,

        recordsByType: this.groupRecordsByType(records),        patientId: request.patientId,  private healthTrendRepository: Repository<HealthTrend>;

        recentVitalSigns: this.getRecentVitalSigns(records),

        activeAlerts: await this.getActiveAlerts(patientId),        recordType: request.recordType,

        lastUpdate: records.length > 0 ? records[0].updatedAt : null

      };        providerId: request.providerId,  constructor(



      return summary;        timestamp: now    private dataSource: DataSource,

    } catch (error) {

      logger.error('Error generating patient health summary:', error);      });    private auditService: AuditTrailService,

      throw error;

    }    private encryptionService: FieldLevelEncryptionService,

  }

      logger.info(`Health record created: ${recordId} for patient ${request.patientId}`);    private notificationService: NotificationService,

  // Private helper methods

  private validateCreateRequest(request: CreateHealthRecordRequest): void {          private eventPublisher: EventPublishingService,

    const errors: ValidationError[] = [];

      return record;    private cacheManager: HealthcareCacheManager

    if (!request.patientId?.trim()) {

      errors.push({    } catch (error) {  ) {

        field: 'patientId',

        message: 'Patient ID is required',      logger.error('Error creating health record:', error);    this.healthRecordsRepository = new HealthRecordsRepository(dataSource);

        code: 'REQUIRED'

      });      throw error;    this.vitalSignsRepository = new VitalSignsRepository(dataSource);

    }

    }    this.clinicalObservationRepository = new ClinicalObservationRepository(dataSource);

    if (!request.title?.trim()) {

      errors.push({  }    this.healthAlertRepository = new HealthAlertRepository(dataSource);

        field: 'title',

        message: 'Title is required',    this.residentRepository = dataSource.getRepository(Resident);

        code: 'REQUIRED'

      });  /**    this.medicalDeviceRepository = dataSource.getRepository(MedicalDevice);

    }

   * Update an existing health record    this.healthTrendRepository = dataSource.getRepository(HealthTrend);

    if (!request.providerId?.trim()) {

      errors.push({   */  }

        field: 'providerId',

        message: 'Provider ID is required',  async updateHealthRecord(request: UpdateHealthRecordRequest): Promise<HealthRecord> {

        code: 'REQUIRED'

      });    try {  /**

    }

      const existingRecord = this.healthRecords.get(request.recordId);   * Create a new health record with comprehensive validation

    if (!request.organizationId?.trim()) {

      errors.push({      if (!existingRecord) {   */

        field: 'organizationId',

        message: 'Organization ID is required',        throw new HealthRecordNotFoundError(request.recordId);  async createHealthRecord(request: CreateHealthRecordRequest): Promise<HealthRecord> {

        code: 'REQUIRED'

      });      }    const correlationId = `health-record-create-${Date.now()}`;

    }

    

    if (!Object.values(RecordType).includes(request.recordType)) {

      errors.push({      this.validateUpdateRequest(request);    try {

        field: 'recordType',

        message: 'Invalid record type',      logger.info('Creating new health record', { 

        code: 'INVALID_VALUE'

      });      const updatedRecord: HealthRecord = {        residentId: request.residentId,

    }

        ...existingRecord,        recordType: request.recordType,

    if (errors.length > 0) {

      throw new HealthRecordValidationError('Validation failed', errors);        title: request.title ?? existingRecord.title,        correlationId 

    }

  }        description: request.description ?? existingRecord.description,      });



  private validateUpdateRequest(request: UpdateHealthRecordRequest): void {        data: request.data ?? existingRecord.data,

    const errors: ValidationError[] = [];

        status: request.status ?? existingRecord.status,      // Validate resident exists

    if (!request.recordId?.trim()) {

      errors.push({        tags: request.tags ?? existingRecord.tags,      const resident = await this.residentRepository.findOne({

        field: 'recordId',

        message: 'Record ID is required',        priority: request.priority ?? existingRecord.priority,        where: { id: request.residentId, deletedAt: null }

        code: 'REQUIRED'

      });        updatedAt: new Date(),      });

    }

        version: existingRecord.version + 1

    if (request.status && !Object.values(RecordStatus).includes(request.status)) {

      errors.push({      };      if (!resident) {

        field: 'status',

        message: 'Invalid status value',        throw new Error(`Resident with ID ${request.residentId} not found`);

        code: 'INVALID_VALUE'

      });      this.healthRecords.set(request.recordId, updatedRecord);      }

    }



    if (request.priority && !Object.values(RecordPriority).includes(request.priority)) {

      errors.push({      // Check for alerts based on the updated record      // Create health record entity

        field: 'priority',

        message: 'Invalid priority value',      await this.checkAndCreateAlerts(updatedRecord);      const healthRecord = new HealthRecord();

        code: 'INVALID_VALUE'

      });      healthRecord.residentId = request.residentId;

    }

      // Emit event for audit logging      healthRecord.recordType = request.recordType;

    if (errors.length > 0) {

      throw new HealthRecordValidationError('Validation failed', errors);      this.emit('health-record.updated', {      healthRecord.title = request.title;

    }

  }        recordId: request.recordId,      healthRecord.description = request.description;



  private generateRecordId(): string {        patientId: updatedRecord.patientId,      healthRecord.clinicalNotes = request.clinicalNotes;

    return `hr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  }        changes: this.getChanges(existingRecord, updatedRecord),      healthRecord.recordedBy = request.recordedBy;



  private calculateVitalSignsPriority(vitalSigns: VitalSignsData): RecordPriority {        timestamp: new Date()      healthRecord.recordedAt = request.recordedAt || new Date();

    // Example priority calculation based on vital signs

    if (vitalSigns.temperature && (vitalSigns.temperature > 39 || vitalSigns.temperature < 35)) {      });      healthRecord.attachments = request.attachments;

      return RecordPriority.HIGH;

    }      healthRecord.tags = request.tags;

    

    if (vitalSigns.heartRate && (vitalSigns.heartRate > 120 || vitalSigns.heartRate < 50)) {      logger.info(`Health record updated: ${request.recordId}`);      healthRecord.status = RecordStatus.ACTIVE;

      return RecordPriority.HIGH;

    }      



    if (vitalSigns.oxygenSaturation && vitalSigns.oxygenSaturation < 95) {      return updatedRecord;      // Validate entity

      return RecordPriority.URGENT;

    }    } catch (error) {      const validationErrors = await validate(healthRecord);



    return RecordPriority.NORMAL;      logger.error('Error updating health record:', error);      if (validationErrors.length > 0) {

  }

      throw error;        throw new HealthRecordValidationError('Health record validation failed', validationErrors);

  private mapObservationSeverityToPriority(severity?: ObservationSeverity): RecordPriority {

    switch (severity) {    }      }

      case ObservationSeverity.CRITICAL:

        return RecordPriority.CRITICAL;  }

      case ObservationSeverity.SEVERE:

        return RecordPriority.URGENT;      // Encrypt sensitive data

      case ObservationSeverity.MODERATE:

        return RecordPriority.HIGH;  /**      await this.encryptSensitiveHealthData(healthRecord);

      case ObservationSeverity.MILD:

        return RecordPriority.NORMAL;   * Get health record by ID

      default:

        return RecordPriority.NORMAL;   */      // Save health record

    }

  }  async getHealthRecord(recordId: string): Promise<HealthRecord> {      const savedRecord = await this.healthRecordsRepository.create(healthRecord);



  private async checkAndCreateAlerts(record: HealthRecord): Promise<void> {    const record = this.healthRecords.get(recordId);

    // Implementation for alert checking would go here

    // This is a placeholder for the alert generation logic    if (!record) {      // Clear health records cache

  }

      throw new HealthRecordNotFoundError(recordId);      await this.cacheManager.invalidatePattern(`health-records:resident:${request.residentId}:*`);

  private getChanges(oldRecord: HealthRecord, newRecord: HealthRecord): any {

    const changes: any = {};    }

    

    Object.keys(newRecord).forEach(key => {    return record;      // Log audit trail

      if (JSON.stringify(oldRecord[key as keyof HealthRecord]) !== JSON.stringify(newRecord[key as keyof HealthRecord])) {

        changes[key] = {  }      await this.auditService.log({

          from: oldRecord[key as keyof HealthRecord],

          to: newRecord[key as keyof HealthRecord]        action: 'HEALTH_RECORD_CREATED',

        };

      }  /**        resourceType: 'HealthRecord',

    });

   * Query health records with filters        resourceId: savedRecord.id,

    return changes;

  }   */        userId: request.recordedBy,



  private groupRecordsByType(records: HealthRecord[]): Record<string, number> {  async queryHealthRecords(query: HealthRecordQuery): Promise<HealthRecord[]> {        details: {

    return records.reduce((acc, record) => {

      acc[record.recordType] = (acc[record.recordType] || 0) + 1;    try {          residentId: request.residentId,

      return acc;

    }, {} as Record<string, number>);      let records = Array.from(this.healthRecords.values());          recordType: request.recordType,

  }

          title: request.title,

  private getRecentVitalSigns(records: HealthRecord[]): any {

    const vitalSignsRecords = records.filter(r => r.recordType === RecordType.VITAL_SIGNS);      // Apply filters          correlationId

    return vitalSignsRecords.length > 0 ? vitalSignsRecords[0].data : null;

  }      if (query.patientId) {        },



  private async getActiveAlerts(patientId: string): Promise<any[]> {        records = records.filter(r => r.patientId === query.patientId);        correlationId

    // Implementation for getting active alerts would go here

    return [];      }      });

  }



  private initializeDefaultAlertRules(): void {

    // Initialize default alert rules      if (query.organizationId) {      // Publish event

    this.alertRules.set('high_temperature', {

      condition: (data: VitalSignsData) => data.temperature && data.temperature > 38.5,        records = records.filter(r => r.organizationId === query.organizationId);      await this.eventPublisher.publish('health-record.created', {

      alertType: AlertType.VITAL_SIGNS_ABNORMAL,

      severity: AlertSeverity.WARNING,      }        recordId: savedRecord.id,

      message: 'High temperature detected'

    });        residentId: request.residentId,



    this.alertRules.set('low_oxygen', {      if (query.recordType) {        recordType: request.recordType,

      condition: (data: VitalSignsData) => data.oxygenSaturation && data.oxygenSaturation < 95,

      alertType: AlertType.VITAL_SIGNS_ABNORMAL,        records = records.filter(r => r.recordType === query.recordType);        recordedBy: request.recordedBy,

      severity: AlertSeverity.CRITICAL,

      message: 'Low oxygen saturation detected'      }        correlationId

    });

  }      });

}
      if (query.status) {

        records = records.filter(r => r.status === query.status);      logger.info('Health record created successfully', { 

      }        recordId: savedRecord.id,

        correlationId 

      if (query.providerId) {      });

        records = records.filter(r => r.providerId === query.providerId);

      }      return savedRecord;



      if (query.dateFrom) {    } catch (error: unknown) {

        records = records.filter(r => r.createdAt >= query.dateFrom!);      logger.error('Failed to create health record', { 

      }        error: error instanceof Error ? error.message : 'Unknown error',

        residentId: request.residentId,

      if (query.dateTo) {        correlationId 

        records = records.filter(r => r.createdAt <= query.dateTo!);      });

      }

      await this.auditService.log({

      if (query.tags && query.tags.length > 0) {        action: 'HEALTH_RECORD_CREATE_FAILED',

        records = records.filter(r =>         resourceType: 'HealthRecord',

          query.tags!.some(tag => r.tags.includes(tag))        userId: request.recordedBy,

        );        details: {

      }          error: error instanceof Error ? error.message : 'Unknown error',

          residentId: request.residentId,

      // Sort by creation date (newest first)          correlationId

      records.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());        },

        correlationId

      // Apply pagination      });

      const offset = query.offset || 0;

      const limit = query.limit || 50;      throw error;

          }

      return records.slice(offset, offset + limit);  } 

    } catch (error) { /**

      logger.error('Error querying health records:', error);   * Record vital signs with automated alert generation

      throw error;   */

    }  async recordVitalSigns(request: RecordVitalSignsRequest): Promise<VitalSigns[]> {

  }    const correlationId = `vital-signs-record-${Date.now()}`;

    

  /**    try {

   * Delete a health record (archive it)      logger.info('Recording vital signs', { 

   */        residentId: request.residentId,

  async deleteHealthRecord(recordId: string): Promise<void> {        vitalSignCount: request.vitalSigns.length,

    try {        deviceId: request.deviceId,

      const record = this.healthRecords.get(recordId);        correlationId 

      if (!record) {      });

        throw new HealthRecordNotFoundError(recordId);

      }      // Validate resident exists

      const resident = await this.residentRepository.findOne({

      // Archive instead of delete for compliance        where: { id: request.residentId, deletedAt: null }

      const archivedRecord: HealthRecord = {      });

        ...record,

        status: RecordStatus.ARCHIVED,      if (!resident) {

        updatedAt: new Date(),        throw new Error(`Resident with ID ${request.residentId} not found`);

        version: record.version + 1      }

      };

      // Validate device if provided

      this.healthRecords.set(recordId, archivedRecord);      if (request.deviceId) {

        const device = await this.medicalDeviceRepository.findOne({

      // Emit event for audit logging          where: { id: request.deviceId, status: DeviceStatus.ACTIVE }

      this.emit('health-record.archived', {        });

        recordId,

        patientId: record.patientId,        if (!device) {

        timestamp: new Date()          throw new MedicalDeviceError(`Medical device with ID ${request.deviceId} not found or inactive`);

      });        }

      }

      logger.info(`Health record archived: ${recordId}`);

    } catch (error) {      const savedVitalSigns: VitalSigns[] = [];

      logger.error('Error archiving health record:', error);      const alerts: HealthAlert[] = [];

      throw error;

    }      // Process each vital sign reading

  }      for (const reading of request.vitalSigns) {

        // Validate vital sign reading

  /**        this.validateVitalSignReading(reading);

   * Record vital signs

   */        // Create vital signs entity

  async recordVitalSigns(patientId: string, vitalSigns: VitalSignsData, providerId: string, organizationId: string): Promise<HealthRecord> {        const vitalSigns = new VitalSigns();

    const request: CreateHealthRecordRequest = {        vitalSigns.residentId = request.residentId;

      patientId,        vitalSigns.type = reading.type;

      recordType: RecordType.VITAL_SIGNS,        vitalSigns.value = reading.value;

      title: `Vital Signs - ${vitalSigns.timestamp.toISOString()}`,        vitalSigns.unit = reading.unit;

      description: 'Vital signs measurement',        vitalSigns.isNormal = reading.isNormal;

      data: vitalSigns,        vitalSigns.referenceRangeMin = reading.referenceRange?.min;

      providerId,        vitalSigns.referenceRangeMax = reading.referenceRange?.max;

      organizationId,        vitalSigns.recordedBy = request.recordedBy;

      priority: this.calculateVitalSignsPriority(vitalSigns)        vitalSigns.recordedAt = request.recordedAt || new Date();

    };        vitalSigns.deviceId = request.deviceId;

        vitalSigns.notes = request.notes;

    return this.createHealthRecord(request);

  }        // Encrypt sensitive data

        if (vitalSigns.notes) {

  /**          vitalSigns.notes = await this.encryptionService.encrypt(vitalSigns.notes);

   * Record clinical observation        }

   */

  async recordClinicalObservation(        // Save vital signs

    patientId: string,         const savedVitalSign = await this.vitalSignsRepository.create(vitalSigns);

    observation: ClinicalObservationData,         savedVitalSigns.push(savedVitalSign);

    providerId: string, 

    organizationId: string        // Check for alerts

  ): Promise<HealthRecord> {        const alert = await this.checkVitalSignsAlert(savedVitalSign, resident);

    const request: CreateHealthRecordRequest = {        if (alert) {

      patientId,          alerts.push(alert);

      recordType: RecordType.CLINICAL_OBSERVATION,        }

      title: `Clinical Observation - ${observation.observationType}`,      }

      description: observation.notes || 'Clinical observation',

      data: observation,      // Process any generated alerts

      providerId,      if (alerts.length > 0) {

      organizationId,        await this.processHealthAlerts(alerts);

      priority: this.mapObservationSeverityToPriority(observation.severity)      }

    };

      // Update health trends

    return this.createHealthRecord(request);      await this.updateHealthTrends(request.residentId, savedVitalSigns);

  }

      // Clear vital signs cache

  /**      await this.cacheManager.invalidatePattern(`vital-signs:resident:${request.residentId}:*`);

   * Get patient's health summary

   */      // Log audit trail

  async getPatientHealthSummary(patientId: string, organizationId: string): Promise<any> {      await this.auditService.log({

    try {        action: 'VITAL_SIGNS_RECORDED',

      const records = await this.queryHealthRecords({        resourceType: 'VitalSigns',

        patientId,        userId: request.recordedBy,

        organizationId,        details: {

        status: RecordStatus.ACTIVE,          residentId: request.residentId,

        limit: 100          vitalSignCount: savedVitalSigns.length,

      });          alertCount: alerts.length,

          deviceId: request.deviceId,

      const summary = {          correlationId

        totalRecords: records.length,        },

        recordsByType: this.groupRecordsByType(records),        correlationId

        recentVitalSigns: this.getRecentVitalSigns(records),      });

        activeAlerts: await this.getActiveAlerts(patientId),

        lastUpdate: records.length > 0 ? records[0].updatedAt : null      // Publish event

      };      await this.eventPublisher.publish('vital-signs.recorded', {

        residentId: request.residentId,

      return summary;        vitalSigns: savedVitalSigns.map(vs => ({

    } catch (error) {          type: vs.type,

      logger.error('Error generating patient health summary:', error);          value: vs.value,

      throw error;          isNormal: vs.isNormal

    }        })),

  }        alertCount: alerts.length,

        recordedBy: request.recordedBy,

  // Private helper methods        correlationId

  private validateCreateRequest(request: CreateHealthRecordRequest): void {      });

    const errors: ValidationError[] = [];

      logger.info('Vital signs recorded successfully', { 

    if (!request.patientId?.trim()) {        residentId: request.residentId,

      errors.push({        recordCount: savedVitalSigns.length,

        field: 'patientId',        alertCount: alerts.length,

        message: 'Patient ID is required',        correlationId 

        code: 'REQUIRED'      });

      });

    }      return savedVitalSigns;



    if (!request.title?.trim()) {    } catch (error: unknown) {

      errors.push({      logger.error('Failed to record vital signs', { 

        field: 'title',        error: error instanceof Error ? error.message : 'Unknown error',

        message: 'Title is required',        residentId: request.residentId,

        code: 'REQUIRED'        correlationId 

      });      });

    }

      await this.auditService.log({

    if (!request.providerId?.trim()) {        action: 'VITAL_SIGNS_RECORD_FAILED',

      errors.push({        resourceType: 'VitalSigns',

        field: 'providerId',        userId: request.recordedBy,

        message: 'Provider ID is required',        details: {

        code: 'REQUIRED'          error: error instanceof Error ? error.message : 'Unknown error',

      });          residentId: request.residentId,

    }          correlationId

        },

    if (!request.organizationId?.trim()) {        correlationId

      errors.push({      });

        field: 'organizationId',

        message: 'Organization ID is required',      throw error;

        code: 'REQUIRED'    }

      });  }

    }

  /**

    if (!Object.values(RecordType).includes(request.recordType)) {   * Analyze vital signs trends and generate insights

      errors.push({   */

        field: 'recordType',  async analyzeVitalSignsTrends(

        message: 'Invalid record type',    residentId: string,

        code: 'INVALID_VALUE'    timeframe: { from: Date; to: Date }

      });  ): Promise<VitalSignsAnalysis> {

    }    try {

      logger.debug('Analyzing vital signs trends', { 

    if (errors.length > 0) {        residentId,

      throw new HealthRecordValidationError('Validation failed', errors);        timeframe 

    }      });

  }

      // Check cache first

  private validateUpdateRequest(request: UpdateHealthRecordRequest): void {      const cacheKey = `vital-signs-analysis:${residentId}:${timeframe.from.toISOString()}:${timeframe.to.toISOString()}`;

    const errors: ValidationError[] = [];      const cachedResult = await this.cacheManager.get(cacheKey);

      

    if (!request.recordId?.trim()) {      if (cachedResult) {

      errors.push({        logger.debug('Vital signs analysis retrieved from cache', { residentId });

        field: 'recordId',        return cachedResult;

        message: 'Record ID is required',      }

        code: 'REQUIRED'

      });      // Get vital signs in timeframe

    }      const vitalSigns = await this.vitalSignsRepository.findByResidentAndTimeframe(

        residentId,

    if (request.status && !Object.values(RecordStatus).includes(request.status)) {        timeframe.from,

      errors.push({        timeframe.to

        field: 'status',      );

        message: 'Invalid status value',

        code: 'INVALID_VALUE'      // Group by vital sign type

      });      const vitalSignsByType = this.groupVitalSignsByType(vitalSigns);

    }

      // Analyze trends for each type

    if (request.priority && !Object.values(RecordPriority).includes(request.priority)) {      const vitalSignTrends: VitalSignTrend[] = [];

      errors.push({      for (const [type, readings] of vitalSignsByType.entries()) {

        field: 'priority',        const trend = this.analyzeVitalSignTrend(type, readings);

        message: 'Invalid priority value',        vitalSignTrends.push(trend);

        code: 'INVALID_VALUE'      }

      });

    }      // Get alerts in timeframe

      const alerts = await this.healthAlertRepository.findByResidentAndTimeframe(

    if (errors.length > 0) {        residentId,

      throw new HealthRecordValidationError('Validation failed', errors);        timeframe.from,

    }        timeframe.to

  }      );



  private generateRecordId(): string {      // Identify abnormal readings

    return `hr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;      const abnormalReadings = vitalSigns

  }        .filter(vs => !vs.isNormal)

        .map(vs => ({

  private calculateVitalSignsPriority(vitalSigns: VitalSignsData): RecordPriority {          type: vs.type,

    // Example priority calculation based on vital signs          value: vs.value,

    if (vitalSigns.temperature && (vitalSigns.temperature > 39 || vitalSigns.temperature < 35)) {          unit: vs.unit,

      return RecordPriority.HIGH;          isNormal: vs.isNormal,

    }          referenceRange: vs.referenceRangeMin && vs.referenceRangeMax ? {

                min: vs.referenceRangeMin,

    if (vitalSigns.heartRate && (vitalSigns.heartRate > 120 || vitalSigns.heartRate < 50)) {            max: vs.referenceRangeMax

      return RecordPriority.HIGH;          } : undefined

    }        }));



    if (vitalSigns.oxygenSaturation && vitalSigns.oxygenSaturation < 95) {      // Generate recommendations

      return RecordPriority.URGENT;      const recommendations = this.generateVitalSignsRecommendations(vitalSignTrends, abnormalReadings);

    }

      // Identify risk indicators

    return RecordPriority.NORMAL;      const riskIndicators = this.identifyRiskIndicators(vitalSignTrends, alerts);

  }

      const analysis: VitalSignsAnalysis = {

  private mapObservationSeverityToPriority(severity?: ObservationSeverity): RecordPriority {        residentId,

    switch (severity) {        timeframe,

      case ObservationSeverity.CRITICAL:        vitalSignTrends,

        return RecordPriority.CRITICAL;        alerts,

      case ObservationSeverity.SEVERE:        abnormalReadings,

        return RecordPriority.URGENT;        recommendations,

      case ObservationSeverity.MODERATE:        riskIndicators

        return RecordPriority.HIGH;      };

      case ObservationSeverity.MILD:

        return RecordPriority.NORMAL;      // Cache result for 30 minutes

      default:      await this.cacheManager.set(cacheKey, analysis, 1800);

        return RecordPriority.NORMAL;

    }      logger.debug('Vital signs analysis completed', { 

  }        residentId,

        trendCount: vitalSignTrends.length,

  private async checkAndCreateAlerts(record: HealthRecord): Promise<void> {        alertCount: alerts.length,

    // Implementation for alert checking would go here        abnormalCount: abnormalReadings.length

    // This is a placeholder for the alert generation logic      });

  }

      return analysis;

  private getChanges(oldRecord: HealthRecord, newRecord: HealthRecord): any {

    const changes: any = {};    } catch (error: unknown) {

          logger.error('Failed to analyze vital signs trends', { 

    Object.keys(newRecord).forEach(key => {        error: error instanceof Error ? error.message : 'Unknown error',

      if (JSON.stringify(oldRecord[key as keyof HealthRecord]) !== JSON.stringify(newRecord[key as keyof HealthRecord])) {        residentId 

        changes[key] = {      });

          from: oldRecord[key as keyof HealthRecord],      throw error;

          to: newRecord[key as keyof HealthRecord]    }

        };  }  /**

      } 

    });  * Generate comprehensive health trend analysis

   */

    return changes;  async generateHealthTrendAnalysis(

  }    residentId: string,

    analysisType: TrendType,

  private groupRecordsByType(records: HealthRecord[]): Record<string, number> {    timeframe: { from: Date; to: Date }

    return records.reduce((acc, record) => {  ): Promise<HealthTrendAnalysis> {

      acc[record.recordType] = (acc[record.recordType] || 0) + 1;    try {

      return acc;      logger.debug('Generating health trend analysis', { 

    }, {} as Record<string, number>);        residentId,

  }        analysisType,

        timeframe 

  private getRecentVitalSigns(records: HealthRecord[]): any {      });

    const vitalSignsRecords = records.filter(r => r.recordType === RecordType.VITAL_SIGNS);

    return vitalSignsRecords.length > 0 ? vitalSignsRecords[0].data : null;      // Get comprehensive health data

  }      const vitalSigns = await this.vitalSignsRepository.findByResidentAndTimeframe(

        residentId,

  private async getActiveAlerts(patientId: string): Promise<any[]> {        timeframe.from,

    // Implementation for getting active alerts would go here        timeframe.to

    return [];      );

  }

      const clinicalObservations = await this.clinicalObservationRepository.findByResidentAndTimeframe(

  private initializeDefaultAlertRules(): void {        residentId,

    // Initialize default alert rules        timeframe.from,

    this.alertRules.set('high_temperature', {        timeframe.to

      condition: (data: VitalSignsData) => data.temperature && data.temperature > 38.5,      );

      alertType: AlertType.VITAL_SIGNS_ABNORMAL,

      severity: AlertSeverity.WARNING,      const healthRecords = await this.healthRecordsRepository.findByResidentAndTimeframe(

      message: 'High temperature detected'        residentId,

    });        timeframe.from,

        timeframe.to

    this.alertRules.set('low_oxygen', {      );

      condition: (data: VitalSignsData) => data.oxygenSaturation && data.oxygenSaturation < 95,

      alertType: AlertType.VITAL_SIGNS_ABNORMAL,      // Analyze overall health trend

      severity: AlertSeverity.CRITICAL,      const overallHealthTrend = this.calculateOverallHealthTrend(

      message: 'Low oxygen saturation detected'        vitalSigns,

    });        clinicalObservations,

  }        healthRecords

}      );

      // Generate key health indicators
      const keyIndicators = this.generateHealthIndicators(
        vitalSigns,
        clinicalObservations,
        timeframe
      );

      // Generate predictive insights
      const predictiveInsights = await this.generatePredictiveInsights(
        residentId,
        vitalSigns,
        clinicalObservations,
        analysisType
      );

      // Generate recommendations
      const recommendations = this.generateHealthTrendRecommendations(
        overallHealthTrend,
        keyIndicators,
        predictiveInsights
      );

      // Calculate next review date
      const nextReviewDate = this.calculateNextHealthReviewDate(
        overallHealthTrend,
        predictiveInsights
      );

      const analysis: HealthTrendAnalysis = {
        residentId,
        analysisType,
        timeframe,
        overallHealthTrend,
        keyIndicators,
        predictiveInsights,
        recommendations,
        nextReviewDate
      };

      // Save trend analysis
      await this.saveHealthTrendAnalysis(analysis);

      logger.debug('Health trend analysis completed', { 
        residentId,
        overallTrend: overallHealthTrend,
        indicatorCount: keyIndicators.length,
        insightCount: predictiveInsights.length
      });

      return analysis;

    } catch (error: unknown) {
      logger.error('Failed to generate health trend analysis', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        residentId,
        analysisType 
      });
      throw error;
    }
  }

  /**
   * Create clinical observation with automated follow-up
   */
  async createClinicalObservation(request: CreateClinicalObservationRequest): Promise<ClinicalObservation> {
    const correlationId = `clinical-observation-${Date.now()}`;
    
    try {
      logger.info('Creating clinical observation', { 
        residentId: request.residentId,
        observationType: request.observationType,
        severity: request.severity,
        correlationId 
      });

      // Validate resident exists
      const resident = await this.residentRepository.findOne({
        where: { id: request.residentId, deletedAt: null }
      });

      if (!resident) {
        throw new Error(`Resident with ID ${request.residentId} not found`);
      }

      // Create clinical observation entity
      const observation = new ClinicalObservation();
      observation.residentId = request.residentId;
      observation.observationType = request.observationType;
      observation.title = request.title;
      observation.description = request.description;
      observation.severity = request.severity;
      observation.observedBy = request.observedBy;
      observation.observedAt = request.observedAt || new Date();
      observation.followUpRequired = request.followUpRequired;
      observation.followUpDate = request.followUpDate;
      observation.relatedConditions = request.relatedConditions;
      observation.status = 'active';

      // Validate entity
      const validationErrors = await validate(observation);
      if (validationErrors.length > 0) {
        throw new HealthRecordValidationError('Clinical observation validation failed', validationErrors);
      }

      // Encrypt sensitive data
      observation.description = await this.encryptionService.encrypt(observation.description);

      // Save observation
      const savedObservation = await this.clinicalObservationRepository.create(observation);

      // Generate alert if high severity
      if (request.severity === ObservationSeverity.HIGH || request.severity === ObservationSeverity.CRITICAL) {
        await this.generateClinicalAlert(savedObservation);
      }

      // Schedule follow-up if required
      if (request.followUpRequired && request.followUpDate) {
        await this.scheduleFollowUp(savedObservation);
      }

      // Clear observations cache
      await this.cacheManager.invalidatePattern(`clinical-observations:resident:${request.residentId}:*`);

      // Log audit trail
      await this.auditService.log({
        action: 'CLINICAL_OBSERVATION_CREATED',
        resourceType: 'ClinicalObservation',
        resourceId: savedObservation.id,
        userId: request.observedBy,
        details: {
          residentId: request.residentId,
          observationType: request.observationType,
          severity: request.severity,
          followUpRequired: request.followUpRequired,
          correlationId
        },
        correlationId
      });

      // Publish event
      await this.eventPublisher.publish('clinical-observation.created', {
        observationId: savedObservation.id,
        residentId: request.residentId,
        observationType: request.observationType,
        severity: request.severity,
        observedBy: request.observedBy,
        correlationId
      });

      logger.info('Clinical observation created successfully', { 
        observationId: savedObservation.id,
        correlationId 
      });

      return savedObservation;

    } catch (error: unknown) {
      logger.error('Failed to create clinical observation', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        residentId: request.residentId,
        correlationId 
      });

      await this.auditService.log({
        action: 'CLINICAL_OBSERVATION_CREATE_FAILED',
        resourceType: 'ClinicalObservation',
        userId: request.observedBy,
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          residentId: request.residentId,
          correlationId
        },
        correlationId
      });

      throw error;
    }
  }  //
 Private helper methods

  private async encryptSensitiveHealthData(healthRecord: HealthRecord): Promise<void> {
    if (healthRecord.description) {
      healthRecord.description = await this.encryptionService.encrypt(healthRecord.description);
    }
    
    if (healthRecord.clinicalNotes) {
      healthRecord.clinicalNotes = await this.encryptionService.encrypt(healthRecord.clinicalNotes);
    }
  }

  private validateVitalSignReading(reading: VitalSignReading): void {
    // Validate vital sign ranges based on type
    const validationRules = this.getVitalSignValidationRules(reading.type);
    
    if (reading.value < validationRules.absoluteMin || reading.value > validationRules.absoluteMax) {
      throw new VitalSignsValidationError(
        `${reading.type} value ${reading.value} is outside acceptable range (${validationRules.absoluteMin}-${validationRules.absoluteMax})`
      );
    }
  }

  private getVitalSignValidationRules(type: VitalSignType): { absoluteMin: number; absoluteMax: number } {
    const rules = {
      [VitalSignType.BLOOD_PRESSURE_SYSTOLIC]: { absoluteMin: 50, absoluteMax: 300 },
      [VitalSignType.BLOOD_PRESSURE_DIASTOLIC]: { absoluteMin: 30, absoluteMax: 200 },
      [VitalSignType.HEART_RATE]: { absoluteMin: 30, absoluteMax: 200 },
      [VitalSignType.RESPIRATORY_RATE]: { absoluteMin: 5, absoluteMax: 60 },
      [VitalSignType.TEMPERATURE]: { absoluteMin: 30, absoluteMax: 45 },
      [VitalSignType.OXYGEN_SATURATION]: { absoluteMin: 70, absoluteMax: 100 },
      [VitalSignType.BLOOD_GLUCOSE]: { absoluteMin: 1, absoluteMax: 50 },
      [VitalSignType.WEIGHT]: { absoluteMin: 20, absoluteMax: 300 },
      [VitalSignType.HEIGHT]: { absoluteMin: 100, absoluteMax: 250 }
    };

    return rules[type] || { absoluteMin: 0, absoluteMax: 1000 };
  }

  private async checkVitalSignsAlert(vitalSigns: VitalSigns, resident: Resident): Promise<HealthAlert | null> {
    // Check if vital signs are outside normal range
    if (vitalSigns.isNormal) {
      return null;
    }

    // Determine alert severity based on how far outside normal range
    const severity = this.calculateAlertSeverity(vitalSigns);
    
    if (severity === AlertSeverity.LOW) {
      return null; // Don't create alerts for low severity
    }

    // Create health alert
    const alert = new HealthAlert();
    alert.residentId = vitalSigns.residentId;
    alert.alertType = AlertType.VITAL_SIGNS_ABNORMAL;
    alert.severity = severity;
    alert.title = `Abnormal ${vitalSigns.type}`;
    alert.description = `${vitalSigns.type} reading of ${vitalSigns.value} ${vitalSigns.unit} is outside normal range`;
    alert.triggeredBy = vitalSigns.id;
    alert.triggeredAt = new Date();
    alert.status = AlertStatus.ACTIVE;
    alert.requiresImmediateAction = severity === AlertSeverity.CRITICAL;

    return await this.healthAlertRepository.create(alert);
  }

  private calculateAlertSeverity(vitalSigns: VitalSigns): AlertSeverity {
    if (!vitalSigns.referenceRangeMin || !vitalSigns.referenceRangeMax) {
      return AlertSeverity.MEDIUM; // Default if no reference range
    }

    const range = vitalSigns.referenceRangeMax - vitalSigns.referenceRangeMin;
    const deviation = Math.abs(vitalSigns.value - 
      (vitalSigns.referenceRangeMin + vitalSigns.referenceRangeMax) / 2);
    
    const deviationPercentage = (deviation / range) * 100;

    if (deviationPercentage > 100) return AlertSeverity.CRITICAL;
    if (deviationPercentage > 50) return AlertSeverity.HIGH;
    if (deviationPercentage > 25) return AlertSeverity.MEDIUM;
    return AlertSeverity.LOW;
  }

  private async processHealthAlerts(alerts: HealthAlert[]): Promise<void> {
    for (const alert of alerts) {
      // Send notifications for high and critical alerts
      if (alert.severity === AlertSeverity.HIGH || alert.severity === AlertSeverity.CRITICAL) {
        await this.notificationService.sendNotification({
          type: 'health_alert',
          recipientType: alert.severity === AlertSeverity.CRITICAL ? 'emergency_team' : 'clinical_team',
          residentId: alert.residentId,
          title: alert.title,
          message: alert.description,
          data: {
            alertId: alert.id,
            severity: alert.severity,
            requiresImmediateAction: alert.requiresImmediateAction
          }
        });
      }
    }
  }

  private async updateHealthTrends(residentId: string, vitalSigns: VitalSigns[]): Promise<void> {
    // Update health trends based on new vital signs
    for (const vs of vitalSigns) {
      const trend = new HealthTrend();
      trend.residentId = residentId;
      trend.trendType = TrendType.VITAL_SIGNS;
      trend.dataPoint = {
        type: vs.type,
        value: vs.value,
        timestamp: vs.recordedAt,
        isNormal: vs.isNormal
      };
      trend.recordedAt = vs.recordedAt;
      
      await this.healthTrendRepository.save(trend);
    }
  }

  private groupVitalSignsByType(vitalSigns: VitalSigns[]): Map<VitalSignType, VitalSigns[]> {
    const grouped = new Map<VitalSignType, VitalSigns[]>();
    
    for (const vs of vitalSigns) {
      if (!grouped.has(vs.type)) {
        grouped.set(vs.type, []);
      }
      grouped.get(vs.type)!.push(vs);
    }
    
    return grouped;
  }

  private analyzeVitalSignTrend(type: VitalSignType, readings: VitalSigns[]): VitalSignTrend {
    const values = readings.map(r => r.value);
    const dataPoints: VitalSignDataPoint[] = readings.map(r => ({
      timestamp: r.recordedAt,
      value: r.value,
      isNormal: r.isNormal,
      deviceId: r.deviceId
    }));

    // Calculate statistics
    const averageValue = values.reduce((a, b) => a + b, 0) / values.length;
    const minValue = Math.min(...values);
    const maxValue = Math.max(...values);
    const standardDeviation = this.calculateStandardDeviation(values);

    // Determine trend direction
    const trend = this.calculateTrendDirection(values);

    // Check if within normal range
    const isWithinNormalRange = readings.every(r => r.isNormal);

    // Determine concern level
    const concernLevel = this.determineConcernLevel(type, readings, standardDeviation);

    return {
      type,
      readings: dataPoints,
      trend,
      averageValue,
      minValue,
      maxValue,
      standardDeviation,
      isWithinNormalRange,
      concernLevel
    };
  }

  private calculateStandardDeviation(values: number[]): number {
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const squaredDifferences = values.map(value => Math.pow(value - mean, 2));
    const variance = squaredDifferences.reduce((a, b) => a + b, 0) / values.length;
    return Math.sqrt(variance);
  }

  private calculateTrendDirection(values: number[]): TrendDirection {
    if (values.length < 2) return TrendDirection.STABLE;

    const firstHalf = values.slice(0, Math.floor(values.length / 2));
    const secondHalf = values.slice(Math.floor(values.length / 2));

    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

    const difference = secondAvg - firstAvg;
    const threshold = Math.abs(firstAvg) * 0.05; // 5% threshold

    if (Math.abs(difference) < threshold) return TrendDirection.STABLE;
    return difference > 0 ? TrendDirection.INCREASING : TrendDirection.DECREASING;
  }

  private determineConcernLevel(
    type: VitalSignType,
    readings: VitalSigns[],
    standardDeviation: number
  ): 'low' | 'medium' | 'high' | 'critical' {
    const abnormalCount = readings.filter(r => !r.isNormal).length;
    const abnormalPercentage = (abnormalCount / readings.length) * 100;

    // High variability indicates concern
    const highVariability = standardDeviation > this.getVariabilityThreshold(type);

    if (abnormalPercentage > 75 || highVariability) return 'critical';
    if (abnormalPercentage > 50) return 'high';
    if (abnormalPercentage > 25) return 'medium';
    return 'low';
  }

  private getVariabilityThreshold(type: VitalSignType): number {
    const thresholds = {
      [VitalSignType.BLOOD_PRESSURE_SYSTOLIC]: 20,
      [VitalSignType.BLOOD_PRESSURE_DIASTOLIC]: 15,
      [VitalSignType.HEART_RATE]: 15,
      [VitalSignType.RESPIRATORY_RATE]: 5,
      [VitalSignType.TEMPERATURE]: 1,
      [VitalSignType.OXYGEN_SATURATION]: 5,
      [VitalSignType.BLOOD_GLUCOSE]: 3,
      [VitalSignType.WEIGHT]: 2,
      [VitalSignType.HEIGHT]: 1
    };

    return thresholds[type] || 10;
  }

  private generateVitalSignsRecommendations(
    trends: VitalSignTrend[],
    abnormalReadings: VitalSignReading[]
  ): string[] {
    const recommendations: string[] = [];

    // Check for concerning trends
    const concerningTrends = trends.filter(t => t.concernLevel === 'high' || t.concernLevel === 'critical');
    if (concerningTrends.length > 0) {
      recommendations.push('Immediate clinical review required for concerning vital sign trends');
      recommendations.push('Consider increasing monitoring frequency');
    }

    // Check for multiple abnormal readings
    if (abnormalReadings.length > 3) {
      recommendations.push('Multiple abnormal readings detected - comprehensive health assessment recommended');
    }

    // Type-specific recommendations
    const bloodPressureTrends = trends.filter(t => 
      t.type === VitalSignType.BLOOD_PRESSURE_SYSTOLIC || t.type === VitalSignType.BLOOD_PRESSURE_DIASTOLIC
    );
    if (bloodPressureTrends.some(t => t.concernLevel === 'high')) {
      recommendations.push('Blood pressure monitoring and medication review recommended');
    }

    if (recommendations.length === 0) {
      recommendations.push('Continue current monitoring schedule');
    }

    return recommendations;
  }

  private identifyRiskIndicators(trends: VitalSignTrend[], alerts: HealthAlert[]): RiskIndicator[] {
    const riskIndicators: RiskIndicator[] = [];

    // Critical alerts indicate high risk
    const criticalAlerts = alerts.filter(a => a.severity === AlertSeverity.CRITICAL);
    if (criticalAlerts.length > 0) {
      riskIndicators.push({
        type: 'Critical Health Alerts',
        severity: 'critical',
        description: `${criticalAlerts.length} critical health alerts detected`,
        recommendations: ['Immediate medical intervention required', 'Continuous monitoring'],
        requiresImmediateAction: true
      });
    }

    // Multiple concerning trends
    const concerningTrends = trends.filter(t => t.concernLevel === 'high' || t.concernLevel === 'critical');
    if (concerningTrends.length >= 2) {
      riskIndicators.push({
        type: 'Multiple Vital Sign Concerns',
        severity: 'high',
        description: `${concerningTrends.length} vital signs showing concerning patterns`,
        recommendations: ['Comprehensive health assessment', 'Review care plan'],
        requiresImmediateAction: false
      });
    }

    return riskIndicators;
  }

  private calculateOverallHealthTrend(
    vitalSigns: VitalSigns[],
    clinicalObservations: ClinicalObservation[],
    healthRecords: HealthRecord[]
  ): TrendDirection {
    // Simplified calculation - in production would be more sophisticated
    const abnormalVitalSigns = vitalSigns.filter(vs => !vs.isNormal).length;
    const totalVitalSigns = vitalSigns.length;
    const abnormalPercentage = totalVitalSigns > 0 ? (abnormalVitalSigns / totalVitalSigns) * 100 : 0;

    const highSeverityObservations = clinicalObservations.filter(
      co => co.severity === ObservationSeverity.HIGH || co.severity === ObservationSeverity.CRITICAL
    ).length;

    if (abnormalPercentage > 50 || highSeverityObservations > 2) {
      return TrendDirection.DECREASING; // Health declining
    }

    if (abnormalPercentage < 10 && highSeverityObservations === 0) {
      return TrendDirection.INCREASING; // Health improving
    }

    return TrendDirection.STABLE;
  }

  private generateHealthIndicators(
    vitalSigns: VitalSigns[],
    clinicalObservations: ClinicalObservation[],
    timeframe: { from: Date; to: Date }
  ): HealthIndicator[] {
    const indicators: HealthIndicator[] = [];

    // Vital signs stability indicator
    const abnormalVitalSigns = vitalSigns.filter(vs => !vs.isNormal).length;
    const vitalSignsStability = ((vitalSigns.length - abnormalVitalSigns) / vitalSigns.length) * 100;

    indicators.push({
      name: 'Vital Signs Stability',
      currentValue: vitalSignsStability,
      previousValue: 85, // Would calculate from previous period
      changePercentage: ((vitalSignsStability - 85) / 85) * 100,
      trend: vitalSignsStability > 85 ? TrendDirection.INCREASING : TrendDirection.DECREASING,
      isSignificant: Math.abs(vitalSignsStability - 85) > 10,
      normalRange: { min: 80, max: 100 }
    });

    return indicators;
  }

  private async generatePredictiveInsights(
    residentId: string,
    vitalSigns: VitalSigns[],
    clinicalObservations: ClinicalObservation[],
    analysisType: TrendType
  ): Promise<PredictiveInsight[]> {
    const insights: PredictiveInsight[] = [];

    // Simple predictive model - in production would use ML
    const recentAbnormalReadings = vitalSigns
      .filter(vs => !vs.isNormal)
      .filter(vs => vs.recordedAt > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)); // Last 7 days

    if (recentAbnormalReadings.length > 5) {
      insights.push({
        type: 'Health Deterioration Risk',
        prediction: 'Increased risk of health deterioration in next 2 weeks',
        confidence: 0.75,
        timeframe: '2 weeks',
        actionRequired: true,
        recommendations: [
          'Increase monitoring frequency',
          'Schedule comprehensive health assessment',
          'Review medication regimen'
        ]
      });
    }

    return insights;
  }

  private generateHealthTrendRecommendations(
    overallTrend: TrendDirection,
    indicators: HealthIndicator[],
    insights: PredictiveInsight[]
  ): string[] {
    const recommendations: string[] = [];

    switch (overallTrend) {
      case TrendDirection.DECREASING:
        recommendations.push('Health trend shows decline - immediate clinical review recommended');
        recommendations.push('Consider adjusting care plan and interventions');
        break;
      case TrendDirection.INCREASING:
        recommendations.push('Positive health trend observed - continue current care approach');
        break;
      case TrendDirection.STABLE:
        recommendations.push('Health status stable - maintain current monitoring schedule');
        break;
    }

    // Add insight-based recommendations
    const actionRequiredInsights = insights.filter(i => i.actionRequired);
    if (actionRequiredInsights.length > 0) {
      recommendations.push('Predictive analysis indicates need for proactive interventions');
    }

    return recommendations;
  }

  private calculateNextHealthReviewDate(
    overallTrend: TrendDirection,
    insights: PredictiveInsight[]
  ): Date {
    const nextReview = new Date();
    
    // Adjust review frequency based on health trend
    let daysToAdd = 30; // Default monthly

    if (overallTrend === TrendDirection.DECREASING) {
      daysToAdd = 7; // Weekly for declining health
    } else if (insights.some(i => i.actionRequired)) {
      daysToAdd = 14; // Bi-weekly if action required
    }

    nextReview.setDate(nextReview.getDate() + daysToAdd);
    return nextReview;
  }

  private async saveHealthTrendAnalysis(analysis: HealthTrendAnalysis): Promise<void> {
    const trend = new HealthTrend();
    trend.residentId = analysis.residentId;
    trend.trendType = analysis.analysisType;
    trend.dataPoint = {
      overallTrend: analysis.overallHealthTrend,
      indicators: analysis.keyIndicators,
      insights: analysis.predictiveInsights
    };
    trend.recordedAt = new Date();
    
    await this.healthTrendRepository.save(trend);
  }

  private async generateClinicalAlert(observation: ClinicalObservation): Promise<void> {
    const alert = new HealthAlert();
    alert.residentId = observation.residentId;
    alert.alertType = AlertType.CLINICAL_OBSERVATION;
    alert.severity = observation.severity === ObservationSeverity.CRITICAL ? 
      AlertSeverity.CRITICAL : AlertSeverity.HIGH;
    alert.title = `Clinical Observation: ${observation.title}`;
    alert.description = `High severity clinical observation recorded`;
    alert.triggeredBy = observation.id;
    alert.triggeredAt = new Date();
    alert.status = AlertStatus.ACTIVE;
    alert.requiresImmediateAction = observation.severity === ObservationSeverity.CRITICAL;

    await this.healthAlertRepository.create(alert);
  }

  private async scheduleFollowUp(observation: ClinicalObservation): Promise<void> {
    // Schedule follow-up notification
    await this.notificationService.scheduleNotification({
      type: 'clinical_followup',
      recipientType: 'clinical_team',
      residentId: observation.residentId,
      scheduledFor: observation.followUpDate!,
      title: 'Clinical Follow-up Required',
      message: `Follow-up required for clinical observation: ${observation.title}`,
      data: {
        observationId: observation.id,
        originalObservation: observation.title
      }
    });
  }
}