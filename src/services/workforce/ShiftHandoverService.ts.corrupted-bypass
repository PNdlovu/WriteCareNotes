import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Shift Handover and Care Round Service for WriteCareNotes
 * @module ShiftHandoverService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive shift handover management with care rounds, nursing handovers,
 * shift reports, and continuity of care for British Isles care home operations.
 * 
 * @compliance
 * - CQC Regulation 17 - Good governance (shift handover standards)
 * - Care Inspectorate Scotland - Shift communication requirements
 * - CIW Wales - Continuity of care standards
 * - RQIA Northern Ireland - Shift handover protocols
 * - NMC Standards - Nursing handover requirements
 * - RCN Guidelines - Shift communication best practices
 * 
 * @security
 * - Encrypted handover data
 * - Role-based access to shift information
 * - Comprehensive audit trails for all handover activities
 * - Secure communication channels for sensitive information
 */


import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';

import { ResidentStatus } from '../../entities/resident/Resident';
import { InjectRepository } from '@nestjs/typeorm';

import { Repository, EntityManager, Between } from 'typeorm';
import { validate, ValidationError } from 'class-validator';
import { v4 as uuidv4 } from 'uuid';

import { Resident } from '../../entities/resident/Resident';
import { ShiftHandover, ShiftType, HandoverStatus, HandoverPriority } from '../../entities/workforce/ShiftHandover';
import { CareRound, RoundType, RoundStatus } from '../../entities/workforce/CareRound';
import { ShiftReport, ReportType } from '../../entities/workforce/ShiftReport';
import { AuditTrailService } from '../audit/AuditTrailService';
import { NotificationService } from '../notifications/NotificationService';
import { FieldLevelEncryptionService } from '../encryption/FieldLevelEncryptionService';
import { logger } from '../../utils/logger';

export interface CreateShiftHandoverRequest {
  fromShift: ShiftType;
  toShift: ShiftType;
  handoverDate: Date;
  outgoingStaffId: string;
  incomingStaffId: string;
  departmentId: string;
  residentUpdates: ResidentHandoverUpdate[];
  generalUpdates: GeneralHandoverUpdate[];
  criticalAlerts: CriticalAlert[];
  medicationChanges: MedicationHandoverUpdate[];
  incidentReports: IncidentHandoverUpdate[];
  specialInstructions: SpecialInstruction[];
  environmentalConcerns: EnvironmentalConcern[];
  equipmentIssues: EquipmentIssue[];
  organizationId: string;
  tenantId: string;
}

export interface ResidentHandoverUpdate {
  residentId: string;
  residentName: string;
  roomNumber: string;
  careLevel: string;
  updates: {
    physicalCondition: string;
    mentalState: string;
    behavioralChanges: string;
    painLevel: number;
    mobilityStatus: string;
    nutritionIntake: string;
    hydrationStatus: string;
    sleepPattern: string;
    medicationAdherence: string;
    familyContact: string;
    appointmentsScheduled: string[];
    careGoalsProgress: string;
    riskFactorsUpdate: string[];
    specialRequirements: string;
  };
  priority: HandoverPriority;
  actionRequired: boolean;
  actionDetails?: string;
  followUpRequired: boolean;
  followUpBy?: Date;
}

export interface GeneralHandoverUpdate {
  category: 'staffing' | 'operations' | 'maintenance' | 'visitors' | 'supplies' | 'other';
  title: string;
  description: string;
  priority: HandoverPriority;
  actionRequired: boolean;
  assignedTo?: string;
  dueDate?: Date;
  status: 'open' | 'in_progress' | 'completed';
}

export interface CriticalAlert {
  alertId: string;
  alertType: 'medical_emergency' | 'behavioral_incident' | 'safety_concern' | 'family_issue' | 'regulatory_issue';
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timeReported: Date;
  reportedBy: string;
  actionsTaken: string[];
  ongoingMonitoring: boolean;
  escalationRequired: boolean;
  escalatedTo?: string[];
  resolution?: string;
  resolvedAt?: Date;
}

export interface MedicationHandoverUpdate {
  residentId: string;
  medicationName: string;
  changeType: 'new_medication' | 'dose_change' | 'frequency_change' | 'discontinued' | 'withheld' | 'prn_administered';
  details: string;
  prescriberId: string;
  timeOfChange: Date;
  nextAdministrationTime?: Date;
  specialInstructions?: string;
  monitoringRequired?: string;
}

export interface IncidentHandoverUpdate {
  incidentId: string;
  incidentType: string;
  description: string;
  residentInvolved?: string;
  timeOccurred: Date;
  actionsTaken: string[];
  ongoingMonitoring: boolean;
  familyNotified: boolean;
  regulatoryReporting: boolean;
  followUpRequired: boolean;
}

export interface SpecialInstruction {
  category: 'care' | 'medical' | 'dietary' | 'mobility' | 'behavioral' | 'safety';
  instruction: string;
  applicableShifts: ShiftType[];
  validFrom: Date;
  validUntil?: Date;
  priority: HandoverPriority;
  assignedStaff?: string[];
}

export interface EnvironmentalConcern {
  location: string;
  concernType: 'temperature' | 'lighting' | 'noise' | 'cleanliness' | 'safety' | 'accessibility';
  description: string;
  severity: 'minor' | 'moderate' | 'significant' | 'urgent';
  reportedBy: string;
  reportedAt: Date;
  actionRequired: string;
  estimatedResolution?: Date;
}

export interface EquipmentIssue {
  equipmentId: string;
  equipmentName: string;
  location: string;
  issueType: 'malfunction' | 'maintenance_due' | 'replacement_needed' | 'calibration_required';
  description: string;
  impact: 'none' | 'minor' | 'moderate' | 'significant' | 'critical';
  reportedBy: string;
  reportedAt: Date;
  workOrderNumber?: string;
  estimatedRepairTime?: Date;
  alternativeEquipment?: string;
}

export interface CreateCareRoundRequest {
  roundType: RoundType;
  scheduledStartTime: Date;
  assignedNurseId: string;
  departmentId: string;
  residentList: string[];
  checklistItems: CareRoundChecklistItem[];
  specialFocus: string[];
  organizationId: string;
  tenantId: string;
}

export interface CareRoundChecklistItem {
  category: 'vital_signs' | 'medication' | 'mobility' | 'nutrition' | 'hygiene' | 'comfort' | 'safety' | 'behavioral';
  description: string;
  required: boolean;
  timeEstimate: number; // minutes
  skillLevel: 'basic' | 'intermediate' | 'advanced';
}

export interface CareRoundUpdate {
  residentId: string;
  checklistCompleted: {
    [itemId: string]: {
      completed: boolean;
      notes?: string;
      timeCompleted?: Date;
      completedBy: string;
      followUpRequired?: boolean;
    };
  };
  observations: ResidentObservation[];
  interventionsPerformed: CareIntervention[];
  concernsRaised: CareRoundConcern[];
  timeSpent: number; // minutes
}

export interface ResidentObservation {
  category: 'physical' | 'mental' | 'behavioral' | 'social' | 'environmental';
  observation: string;
  severity: 'normal' | 'noteworthy' | 'concerning' | 'urgent';
  actionRequired: boolean;
  actionTaken?: string;
  followUpNeeded: boolean;
  timeObserved: Date;
}

export interface CareIntervention {
  interventionType: string;
  description: string;
  outcome: string;
  timePerformed: Date;
  performedBy: string;
  effectiveness: 'very_effective' | 'effective' | 'somewhat_effective' | 'ineffective';
  sideEffects?: string;
  followUpRequired: boolean;
}

export interface CareRoundConcern {
  concernType: 'medical' | 'behavioral' | 'safety' | 'family' | 'equipment' | 'environmental';
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  immediateAction: string;
  escalationRequired: boolean;
  escalatedTo?: string;
  timeRaised: Date;
}

export interface ShiftHandoverSummary {
  handoverId: string;
  shiftDate: Date;
  fromShift: ShiftType;
  toShift: ShiftType;
  totalResidents: number;
  criticalUpdates: number;
  medicationChanges: number;
  incidentsReported: number;
  actionItemsOutstanding: number;
  handoverCompletionTime: Date;
  handoverDuration: number; // minutes
  completionRate: number; // percentage
  qualityScore: number; // 1-10
}

export interface CareRoundSummary {
  roundId: string;
  roundType: RoundType;
  scheduledTime: Date;
  actualStartTime: Date;
  actualEndTime: Date;
  assignedNurse: string;
  residentsVisited: number;
  checklistCompletionRate: number;
  observationsMade: number;
  interventionsPerformed: number;
  concernsRaised: number;
  averageTimePerResident: number;
  qualityScore: number;
}


export class ShiftHandoverService {
  // Logger removed

  constructor(
    
    private readonly handoverRepository: Repository<ShiftHandover>,
    
    private readonly careRoundRepository: Repository<CareRound>,
    
    private readonly shiftReportRepository: Repository<ShiftReport>,
    
    private readonly residentRepository: Repository<Resident>,
    private readonly auditService: AuditTrailService,
    private readonly notificationService: NotificationService,
    private readonly encryptionService: FieldLevelEncryptionService
  ) {}

  /**
   * Create a comprehensive shift handover
   */
  async createShiftHandover(request: CreateShiftHandoverRequest): Promise<ShiftHandover> {
    try {
      // Validate request
      const validationErrors = await this.validateHandoverRequest(request);
      if (validationErrors.length > 0) {
        throw new Error('Validation failed', { cause: validationErrors });
      }

      // Create handover record
      const handover = this.handoverRepository.create({
        id: uuidv4(),
        fromShift: request.fromShift,
        toShift: request.toShift,
        handoverDate: request.handoverDate,
        outgoingStaffId: request.outgoingStaffId,
        incomingStaffId: request.incomingStaffId,
        departmentId: request.departmentId,
        
        // Encrypt sensitive data
        residentUpdates: await this.encryptionService.encryptField(JSON.stringify(request.residentUpdates)),
        generalUpdates: await this.encryptionService.encryptField(JSON.stringify(request.generalUpdates)),
        criticalAlerts: await this.encryptionService.encryptField(JSON.stringify(request.criticalAlerts)),
        medicationChanges: await this.encryptionService.encryptField(JSON.stringify(request.medicationChanges)),
        incidentReports: await this.encryptionService.encryptField(JSON.stringify(request.incidentReports)),
        specialInstructions: await this.encryptionService.encryptField(JSON.stringify(request.specialInstructions)),
        environmentalConcerns: await this.encryptionService.encryptField(JSON.stringify(request.environmentalConcerns)),
        equipmentIssues: await this.encryptionService.encryptField(JSON.stringify(request.equipmentIssues)),
        
        status: HandoverStatus.PENDING,
        organizationId: request.organizationId,
        tenantId: request.tenantId,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      const savedHandover = await this.handoverRepository.save(handover);

      // Send notifications to incoming staff
      await this.notificationService.sendNotification({
        message: 'Notification: Shift Handover Ready',
        type: 'shift_handover_ready',
        recipients: [request.incomingStaffId],
        data: {
          handoverId: savedHandover.id,
          fromShift: request.fromShift,
          toShift: request.toShift,
          criticalAlertsCount: request.criticalAlerts.length,
          medicationChangesCount: request.medicationChanges.length
        }
      });

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'ShiftHandover',
        entityType: 'ShiftHandover',
        entityId: savedHandover.id,
        action: 'CREATE',
        details: {
          fromShift: request.fromShift,
          toShift: request.toShift,
          residentCount: request.residentUpdates.length,
          criticalAlertsCount: request.criticalAlerts.length
        },
        userId: request.outgoingStaffId
      });

      console.log(`Shift handover created: ${savedHandover.id}`);
      return savedHandover;

    } catch (error: unknown) {
      console.error('Error creating shift handover:', error);
      throw error;
    }
  }

  /**
   * Start a care round
   */
  async startCareRound(request: CreateCareRoundRequest): Promise<CareRound> {
    try {
      // Validate request
      const validationErrors = await this.validateCareRoundRequest(request);
      if (validationErrors.length > 0) {
        throw new Error('Validation failed', { cause: validationErrors });
      }

      // Create care round
      const careRound = this.careRoundRepository.create({
        id: uuidv4(),
        roundType: request.roundType,
        scheduledStartTime: request.scheduledStartTime,
        actualStartTime: new Date(),
        assignedNurseId: request.assignedNurseId,
        departmentId: request.departmentId,
        residentList: request.residentList,
        checklistItems: await this.encryptionService.encryptField(JSON.stringify(request.checklistItems)),
        specialFocus: request.specialFocus,
        status: RoundStatus.IN_PROGRESS,
        organizationId: request.organizationId,
        tenantId: request.tenantId,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      const savedCareRound = await this.careRoundRepository.save(careRound);

      // Send notification to assigned nurse
      await this.notificationService.sendNotification({
        message: 'Notification: Care Round Started',
        type: 'care_round_started',
        recipients: [request.assignedNurseId],
        data: {
          roundId: savedCareRound.id,
          roundType: request.roundType,
          residentCount: request.residentList.length,
          estimatedDuration: this.calculateEstimatedDuration(request.checklistItems)
        }
      });

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'CareRound',
        entityType: 'CareRound',
        entityId: savedCareRound.id,
        action: 'START',
        details: {
          roundType: request.roundType,
          residentCount: request.residentList.length,
          assignedNurse: request.assignedNurseId
        },
        userId: request.assignedNurseId
      });

      console.log(`Care round started: ${savedCareRound.id}`);
      return savedCareRound;

    } catch (error: unknown) {
      console.error('Error starting care round:', error);
      throw error;
    }
  }

  /**
   * Update care round progress
   */
  async updateCareRound(roundId: string, residentId: string, update: CareRoundUpdate): Promise<CareRound> {
    try {
      const careRound = await this.careRoundRepository.findOne({
        where: { id: roundId }
      });

      if (!careRound) {
        throw new Error(`Care round not found: ${roundId}`);
      }

      // Update care round with resident-specific updates
      const currentUpdates = careRound.residentUpdates || {};
      currentUpdates[residentId] = {
        ...update,
        lastUpdated: new Date(),
        updatedBy: update.checklistCompleted ? Object.values(update.checklistCompleted)[0]?.completedBy : 'system'
      };

      careRound.residentUpdates = await this.encryptionService.encryptField(JSON.stringify(currentUpdates));
      careRound.updatedAt = new Date();

      // Calculate completion progress
      const completionRate = this.calculateRoundCompletionRate(careRound);
      careRound.completionRate = completionRate;

      if (completionRate === 100) {
        careRound.status = RoundStatus.COMPLETED;
        careRound.actualEndTime = new Date();
      }

      const savedCareRound = await this.careRoundRepository.save(careRound);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'CareRound',
        entityType: 'CareRound',
        entityId: careRound.id,
        action: 'UPDATE_RESIDENT',
        details: {
          residentId,
          observationsCount: update.observations.length,
          interventionsCount: update.interventionsPerformed.length,
          concernsCount: update.concernsRaised.length
        },
        userId: update.checklistCompleted ? Object.values(update.checklistCompleted)[0]?.completedBy || 'system' : 'system'
      });

      // Send notifications for urgent concerns
      const urgentConcerns = update.concernsRaised.filter(c => c.severity === 'critical');
      if (urgentConcerns.length > 0) {
        await this.notificationService.sendNotification({
          message: 'Notification: Urgent Care Concern',
        type: 'urgent_care_concern',
          recipients: ['charge_nurse', 'duty_manager'],
          data: {
            roundId: careRound.id,
            residentId,
            concerns: urgentConcerns.map(c => c.description)
          }
        });
      }

      return savedCareRound;

    } catch (error: unknown) {
      console.error('Error updating care round:', error);
      throw error;
    }
  }

  /**
   * Complete shift handover
   */
  async completeShiftHandover(handoverId: string, completionData: {
    incomingStaffConfirmation: boolean;
    questionsAsked: string[];
    clarificationsProvided: string[];
    additionalNotes?: string;
    handoverQuality: number; // 1-10
    completedBy: string;
  }): Promise<ShiftHandover> {
    try {
      const handover = await this.handoverRepository.findOne({
        where: { id: handoverId }
      });

      if (!handover) {
        throw new Error(`Shift handover not found: ${handoverId}`);
      }

      // Update handover completion
      handover.status = HandoverStatus.COMPLETED;
      handover.completedAt = new Date();
      handover.incomingStaffConfirmation = completionData.incomingStaffConfirmation;
      handover.questionsAsked = await this.encryptionService.encryptField(JSON.stringify(completionData.questionsAsked));
      handover.clarificationsProvided = await this.encryptionService.encryptField(JSON.stringify(completionData.clarificationsProvided));
      handover.additionalNotes = completionData.additionalNotes ? 
        await this.encryptionService.encryptField(completionData.additionalNotes) : undefined;
      handover.handoverQuality = completionData.handoverQuality;
      handover.updatedAt = new Date();

      const savedHandover = await this.handoverRepository.save(handover);

      // Generate shift handover summary report
      await this.generateShiftHandoverReport(savedHandover);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'ShiftHandover',
        entityType: 'ShiftHandover',
        entityId: handover.id,
        action: 'COMPLETE',
        details: {
          handoverQuality: completionData.handoverQuality,
          incomingStaffConfirmed: completionData.incomingStaffConfirmation,
          questionsCount: completionData.questionsAsked.length
        },
        userId: completionData.completedBy
      });

      console.log(`Shift handover completed: ${handover.id}`);
      return savedHandover;

    } catch (error: unknown) {
      console.error('Error completing shift handover:', error);
      throw error;
    }
  }

  /**
   * Get shift handover dashboard
   */
  async getShiftHandoverDashboard(departmentId: string, date: Date): Promise<{
    currentShift: ShiftType;
    activeHandovers: ShiftHandover[];
    pendingHandovers: ShiftHandover[];
    activeCareRounds: CareRound[];
    criticalAlerts: CriticalAlert[];
    shiftMetrics: ShiftMetrics;
  }> {
    try {
      const currentShift = this.getCurrentShift(date);
      const startOfDay = new Date(date);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(date);
      endOfDay.setHours(23, 59, 59, 999);

      const [activeHandovers, pendingHandovers, activeCareRounds] = await Promise.all([
        this.handoverRepository.find({
          where: {
            departmentId,
            handoverDate: Between(startOfDay, endOfDay),
            status: HandoverStatus.IN_PROGRESS
          },
          order: { createdAt: 'DESC' }
        }),
        this.handoverRepository.find({
          where: {
            departmentId,
            handoverDate: Between(startOfDay, endOfDay),
            status: HandoverStatus.PENDING
          },
          order: { scheduledTime: 'ASC' }
        }),
        this.careRoundRepository.find({
          where: {
            departmentId,
            scheduledStartTime: Between(startOfDay, endOfDay),
            status: RoundStatus.IN_PROGRESS
          },
          order: { scheduledStartTime: 'ASC' }
        })
      ]);

      // Extract critical alerts from active handovers
      const criticalAlerts: CriticalAlert[] = [];
      for (const handover of activeHandovers) {
        const decryptedAlerts = JSON.parse(

          await this.encryptionService.decryptField(handover.criticalAlerts || '' || '' || '' || '' || '')

        );
        criticalAlerts.push(...decryptedAlerts.filter((alert: CriticalAlert) => 
          alert.severity === 'critical' && !alert.resolvedAt
        ));
      }

      // Calculate shift metrics
      const shiftMetrics = await this.calculateShiftMetrics(departmentId, date);

      return {
        currentShift,
        activeHandovers,
        pendingHandovers,
        activeCareRounds,
        criticalAlerts,
        shiftMetrics
      };

    } catch (error: unknown) {
      console.error('Error getting shift handover dashboard:', error);
      throw error;
    }
  }

  /**
   * Generate daily care round schedule
   */
  async generateDailyCareRoundSchedule(departmentId: string, date: Date): Promise<CareRound[]> {
    try {
      const residents = await this.residentRepository.find({
        where: { 
          status: ResidentStatus.ACTIVE,
          organizationId: departmentId // Assuming department maps to organization
        }
      });

      const careRounds: CareRound[] = [];
      const shifts = [ShiftType.DAY, ShiftType.EVENING, ShiftType.NIGHT];

      for (const shift of shifts) {
        const roundTypes = this.getRoundTypesForShift(shift);
        
        for (const roundType of roundTypes) {
          const scheduledTime = this.calculateRoundTime(shift, roundType, date);
          const checklistItems = await this.generateChecklistForRound(roundType, residents);

          const careRound = this.careRoundRepository.create({
            id: uuidv4(),
            roundType,
            scheduledStartTime: scheduledTime,
            departmentId,
            residentList: residents.map(r => r.id),
            checklistItems: await this.encryptionService.encryptField(JSON.stringify(checklistItems)),
            specialFocus: await this.determineSpecialFocus(residents, roundType),
            status: RoundStatus.SCHEDULED,
            organizationId: departmentId,
            tenantId: residents[0]?.tenantId || 'default',
            createdAt: new Date(),
            updatedAt: new Date()
          });

          careRounds.push(careRound);
        }
      }

      const savedRounds = await this.careRoundRepository.save(careRounds);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'CareRound',
        entityType: 'CareRound',
        entityId: 'bulk_create',
        action: 'GENERATE_SCHEDULE',
        details: {
          departmentId,
          date: date.toISOString(),
          roundsCreated: savedRounds.length,
          residentsCount: residents.length
        },
        userId: 'system'
      });

      return savedRounds;

    } catch (error: unknown) {
      console.error('Error generating daily care round schedule:', error);
      throw error;
    }
  }

  /**
   * Get handover history and analytics
   */
  async getHandoverAnalytics(departmentId: string, fromDate: Date, toDate: Date): Promise<{
    totalHandovers: number;
    averageHandoverTime: number;
    averageQualityScore: number;
    criticalAlertsCount: number;
    medicationChangesCount: number;
    incidentsReportedCount: number;
    completionRate: number;
    handoverTrends: HandoverTrend[];
    qualityTrends: QualityTrend[];
  }> {
    try {
      const handovers = await this.handoverRepository.find({
        where: {
          departmentId,
          handoverDate: Between(fromDate, toDate)
        },
        order: { handoverDate: 'DESC' }
      });

      const analytics = {
        totalHandovers: handovers.length,
        averageHandoverTime: this.calculateAverageHandoverTime(handovers),
        averageQualityScore: this.calculateAverageQualityScore(handovers),
        criticalAlertsCount: await this.countCriticalAlerts(handovers),
        medicationChangesCount: await this.countMedicationChanges(handovers),
        incidentsReportedCount: await this.countIncidentReports(handovers),
        completionRate: this.calculateCompletionRate(handovers),
        handoverTrends: await this.calculateHandoverTrends(handovers),
        qualityTrends: await this.calculateQualityTrends(handovers)
      };

      return analytics;

    } catch (error: unknown) {
      console.error('Error getting handover analytics:', error);
      throw error;
    }
  }

  // Private helper methods
  private async validateHandoverRequest(request: CreateShiftHandoverRequest): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    if (!request.outgoingStaffId || !request.incomingStaffId) {
      errors.push({
        property: 'staffIds',
        constraints: { required: 'Both outgoing and incoming staff IDs are required' }
      } as ValidationError);
    }

    if (request.residentUpdates.length === 0) {
      errors.push({
        property: 'residentUpdates',
        constraints: { required: 'At least one resident update is required' }
      } as ValidationError);
    }

    return errors;
  }

  private async validateCareRoundRequest(request: CreateCareRoundRequest): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    if (!request.assignedNurseId) {
      errors.push({
        property: 'assignedNurseId',
        constraints: { required: 'Assigned nurse ID is required' }
      } as ValidationError);
    }

    if (request.residentList.length === 0) {
      errors.push({
        property: 'residentList',
        constraints: { required: 'At least one resident must be included in the round' }
      } as ValidationError);
    }

    return errors;
  }

  private getCurrentShift(date: Date): ShiftType {
    const hour = date.getHours();
    if (hour >= 6 && hour < 14) return ShiftType.DAY;
    if (hour >= 14 && hour < 22) return ShiftType.EVENING;
    return ShiftType.NIGHT;
  }

  private getRoundTypesForShift(shift: ShiftType): RoundType[] {

    const roundTypes: { [key in ShiftType]: RoundType[] } = {
      [ShiftType.DAY]: [RoundType.MORNING_MEDICATION, RoundType.MORNING_CARE, RoundType.LUNCH_MEDICATION, RoundType.AFTERNOON_CARE],
      [ShiftType.EVENING]: [RoundType.EVENING_MEDICATION, RoundType.EVENING_CARE, RoundType.BEDTIME_CARE],
      [ShiftType.NIGHT]: [RoundType.NIGHT_MEDICATION, RoundType.NIGHT_CHECK, RoundType.EARLY_MORNING_CARE],
      [ShiftType.WEEKEND]: [RoundType.MORNING_MEDICATION, RoundType.MORNING_CARE, RoundType.LUNCH_MEDICATION, RoundType.AFTERNOON_CARE, RoundType.EVENING_MEDICATION, RoundType.EVENING_CARE, RoundType.BEDTIME_CARE],
      [ShiftType.BANK_HOLIDAY]: [RoundType.MORNING_MEDICATION, RoundType.MORNING_CARE, RoundType.LUNCH_MEDICATION, RoundType.AFTERNOON_CARE, RoundType.EVENING_MEDICATION, RoundType.EVENING_CARE, RoundType.BEDTIME_CARE]
    };
    return roundTypes[shift];
  }

  private calculateRoundTime(shift: ShiftType, roundType: RoundType, date: Date): Date {
    const baseDate = new Date(date);

    const timeMap: { [key in RoundType]: number } = {
      [RoundType.MORNING_MEDICATION]: 8,
      [RoundType.MORNING_CARE]: 9,
      [RoundType.LUNCH_MEDICATION]: 12,
      [RoundType.AFTERNOON_CARE]: 15,
      [RoundType.EVENING_MEDICATION]: 18,
      [RoundType.EVENING_CARE]: 19,
      [RoundType.BEDTIME_CARE]: 21,
      [RoundType.NIGHT_MEDICATION]: 22,
      [RoundType.NIGHT_CHECK]: 2,
      [RoundType.EARLY_MORNING_CARE]: 6,
      [RoundType.PRN_ROUND]: 0,
      [RoundType.EMERGENCY_ROUND]: 0,
      [RoundType.OBSERVATION_ROUND]: 0,
      [RoundType.WELLNESS_CHECK]: 0
    };

    baseDate.setHours(timeMap[roundType], 0, 0, 0);
    return baseDate;
  }

  private async generateChecklistForRound(roundType: RoundType, residents: Resident[]): Promise<CareRoundChecklistItem[]> {
    const baseChecklist: CareRoundChecklistItem[] = [
      {
        category: 'vital_signs',
        description: 'Check vital signs if required',
        required: roundType === RoundType.MORNING_CARE,
        timeEstimate: 5,
        skillLevel: 'intermediate'
      },
      {
        category: 'medication',
        description: 'Administer scheduled medications',
        required: roundType.includes('MEDICATION'),
        timeEstimate: 10,
        skillLevel: 'advanced'
      },
      {
        category: 'comfort',
        description: 'Ensure resident comfort and positioning',
        required: true,
        timeEstimate: 5,
        skillLevel: 'basic'
      },
      {
        category: 'safety',
        description: 'Check room safety and call bell functionality',
        required: true,
        timeEstimate: 3,
        skillLevel: 'basic'
      },
      {
        category: 'behavioral',
        description: 'Assess mood and behavioral changes',
        required: roundType === RoundType.MORNING_CARE || roundType === RoundType.EVENING_CARE,
        timeEstimate: 5,
        skillLevel: 'intermediate'
      }
    ];

    return baseChecklist;
  }

  private async determineSpecialFocus(residents: Resident[], roundType: RoundType): Promise<string[]> {
    const specialFocus: string[] = [];

    // Add focus based on round type
    if (roundType.includes('MEDICATION')) {
      specialFocus.push('Medication adherence', 'Side effect monitoring');
    }
    if (roundType === RoundType.NIGHT_CHECK) {
      specialFocus.push('Sleep quality', 'Night-time safety');
    }
    if (roundType === RoundType.MORNING_CARE) {
      specialFocus.push('Overnight changes', 'Morning routine assistance');
    }

    return specialFocus;
  }

  private calculateEstimatedDuration(checklistItems: CareRoundChecklistItem[]): number {
    return checklistItems.reduce((total, item) => total + item.timeEstimate, 0);
  }

  private calculateRoundCompletionRate(careRound: CareRound): number {
    if (!careRound.residentUpdates) return 0;
    
    try {
      const updates = JSON.parse(careRound.residentUpdates);
      const totalResidents = careRound.residentList.length;
      const completedResidents = Object.keys(updates).length;
      
      return Math.round((completedResidents / totalResidents) * 100);
    } catch (error: unknown) {
      return 0;
    }
  }

  private async generateShiftHandoverReport(handover: ShiftHandover): Promise<void> {
    try {
      const report = this.shiftReportRepository.create({
        id: uuidv4(),
        handoverId: handover.id,
        reportType: ReportType.SHIFT_HANDOVER,
        reportDate: handover.handoverDate,
        departmentId: handover.departmentId,
        generatedBy: 'system',
        reportData: await this.encryptionService.encryptField(JSON.stringify({
          handoverSummary: await this.createHandoverSummary(handover),
          qualityMetrics: {
            handoverQuality: handover.handoverQuality,
            completionTime: handover.completedAt,
            criticalAlertsHandled: true
          }
        })),
        organizationId: handover.organizationId,
        tenantId: handover.tenantId,
        createdAt: new Date()
      });

      await this.shiftReportRepository.save(report);

    } catch (error: unknown) {
      console.error('Error generating shift handover report:', error);
    }
  }

  private async createHandoverSummary(handover: ShiftHandover): Promise<ShiftHandoverSummary> {
    const duration = handover.completedAt && handover.createdAt ? 
      (handover.completedAt.getTime() - handover.createdAt.getTime()) / (1000 * 60) : 0;

    return {
      handoverId: handover.id,
      shiftDate: handover.handoverDate,
      fromShift: handover.fromShift,
      toShift: handover.toShift,

      totalResidents: JSON.parse(await this.encryptionService.decryptField(handover.residentUpdates || '' || '' || '' || '' || '') || '[]').length,
      criticalUpdates: JSON.parse(await this.encryptionService.decryptField(handover.criticalAlerts || '' || '' || '' || '' || '') || '[]').length,
      medicationChanges: JSON.parse(await this.encryptionService.decryptField(handover.medicationChanges || '' || '' || '' || '' || '') || '[]').length,
      incidentsReported: JSON.parse(await this.encryptionService.decryptField(handover.incidentReports || '' || '' || '' || '' || '') || '[]').length,

      actionItemsOutstanding: 0, // Would calculate from follow-ups
      handoverCompletionTime: handover.completedAt || new Date(),
      handoverDuration: duration,
      completionRate: 100, // Would calculate based on completed items
      qualityScore: handover.handoverQuality || 0
    };
  }

  private calculateAverageHandoverTime(handovers: ShiftHandover[]): number {
    const completedHandovers = handovers.filter(h => h.completedAt && h.createdAt);
    if (completedHandovers.length === 0) return 0;

    const totalTime = completedHandovers.reduce((sum, h) => {
      const duration = (h.completedAt!.getTime() - h.createdAt.getTime()) / (1000 * 60);
      return sum + duration;
    }, 0);

    return Math.round(totalTime / completedHandovers.length);
  }

  private calculateAverageQualityScore(handovers: ShiftHandover[]): number {
    const handoversWithQuality = handovers.filter(h => h.handoverQuality);
    if (handoversWithQuality.length === 0) return 0;

    const totalQuality = handoversWithQuality.reduce((sum, h) => sum + h.handoverQuality!, 0);
    return Math.round((totalQuality / handoversWithQuality.length) * 10) / 10;
  }

  private async countCriticalAlerts(handovers: ShiftHandover[]): Promise<number> {
    let count = 0;
    for (const handover of handovers) {
      try {

        const alerts = JSON.parse(await this.encryptionService.decryptField(handover.criticalAlerts || '' || '' || '' || '' || '') || '[]');

        count += alerts.filter((alert: CriticalAlert) => alert.severity === 'critical').length;
      } catch (error: unknown) {
        // Skip if decryption fails
      }
    }
    return count;
  }

  private async countMedicationChanges(handovers: ShiftHandover[]): Promise<number> {
    let count = 0;
    for (const handover of handovers) {
      try {

        const changes = JSON.parse(await this.encryptionService.decryptField(handover.medicationChanges || '' || '' || '' || '' || '') || '[]');

        count += changes.length;
      } catch (error: unknown) {
        // Skip if decryption fails
      }
    }
    return count;
  }

  private async countIncidentReports(handovers: ShiftHandover[]): Promise<number> {
    let count = 0;
    for (const handover of handovers) {
      try {

        const incidents = JSON.parse(await this.encryptionService.decryptField(handover.incidentReports || '' || '' || '' || '' || '') || '[]');

        count += incidents.length;
      } catch (error: unknown) {
        // Skip if decryption fails
      }
    }
    return count;
  }

  private calculateCompletionRate(handovers: ShiftHandover[]): number {
    if (handovers.length === 0) return 0;
    const completedHandovers = handovers.filter(h => h.status === HandoverStatus.COMPLETED).length;
    return Math.round((completedHandovers / handovers.length) * 100);
  }

  private async calculateHandoverTrends(handovers: ShiftHandover[]): Promise<HandoverTrend[]> {
    // Implementation for trend analysis
    return [];
  }

  private async calculateQualityTrends(handovers: ShiftHandover[]): Promise<QualityTrend[]> {
    // Implementation for quality trend analysis
    return [];
  }

  private async calculateShiftMetrics(departmentId: string, date: Date): Promise<ShiftMetrics> {
    return {
      totalStaffOnDuty: 0,
      handoversCompleted: 0,
      handoversPending: 0,
      careRoundsCompleted: 0,
      careRoundsPending: 0,
      criticalAlertsActive: 0,
      averageResponseTime: 0
    };
  }
}

// Supporting interfaces
interface HandoverTrend {
  date: Date;
  averageTime: number;
  qualityScore: number;
  criticalAlerts: number;
}

interface QualityTrend {
  shift: ShiftType;
  averageQuality: number;
  improvementRate: number;
}

interface ShiftMetrics {
  totalStaffOnDuty: number;
  handoversCompleted: number;
  handoversPending: number;
  careRoundsCompleted: number;
  careRoundsPending: number;
  criticalAlertsActive: number;
  averageResponseTime: number;
}