import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';
import AppDataSource from '../../config/database';
import { TimeEntry, TimeEntryType, TimeEntryStatus, LocationData, DeviceInfo } from '../../entities/workforce/TimeEntry';
import { Employee } from '../../entities/hr/Employee';
import { Shift } from '../../entities/workforce/Shift';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export interface ClockInData {
  employeeId: string;
  location?: LocationData;
  deviceInfo: DeviceInfo;
  shiftId?: string;
  notes?: string;
  photoUrl?: string;
}

export interface ClockOutData {
  employeeId: string;
  location?: LocationData;
  deviceInfo: DeviceInfo;
  notes?: string;
  photoUrl?: string;
}

export interface ManualTimeEntry {
  employeeId: string;
  type: TimeEntryType;
  timestamp: Date;
  reason: string;
  approvedBy: string;
  shiftId?: string;
  notes?: string;
}

export interface TimeTrackingMetrics {
  totalEmployees: number;
  currentlyClockedIn: number;
  averageHoursPerDay: number;
  overtimeHours: number;
  lateArrivals: number;
  earlyDepartures: number;
  missedClockOuts: number;
}

export interface AttendanceReport {
  employeeId: string;
  employeeName: string;
  totalHours: number;
  regularHours: number;
  overtimeHours: number;
  daysWorked: number;
  lateArrivals: number;
  earlyDepartures: number;
  attendanceRate: number;
}

export class TimeTrackingService {
  private timeEntryRepository: Repository<TimeEntry>;
  private employeeRepository: Repository<Employee>;
  private shiftRepository: Repository<Shift>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;

  constructor() {
    this.timeEntryRepository = AppDataSource.getRepository(TimeEntry);
    this.employeeRepository = AppDataSource.getRepository(Employee);
    this.shiftRepository = AppDataSource.getRepository(Shift);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  // Clock In/Out Operations
  async clockIn(data: ClockInData): Promise<TimeEntry> {
    // Check if employee is already clocked in
    const existingEntry = await this.getCurrentTimeEntry(data.employeeId);
    if (existingEntry && existingEntry.isClockIn()) {
      throw new Error('Employee is already clocked in');
    }

    // Validate location if shift has location requirements
    if (data.shiftId) {
      await this.validateShiftLocation(data.shiftId, data.location);
    }

    const timeEntry = this.timeEntryRepository.create({
      employeeId: data.employeeId,
      type: TimeEntryType.CLOCK_IN,
      timestamp: new Date(),
      location: data.location,
      deviceInfo: data.deviceInfo,
      shiftId: data.shiftId,
      notes: data.notes,
      photoUrl: data.photoUrl,
      status: TimeEntryStatus.ACTIVE
    });

    const savedEntry = await this.timeEntryRepository.save(timeEntry);

    // Update shift status if applicable
    if (data.shiftId) {
      await this.updateShiftStatus(data.shiftId, 'IN_PROGRESS');
    }

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TimeEntry',
        entityType: 'TimeEntry',
      entityId: savedEntry.id,
      action: 'CLOCK_IN',
      details: { 
        employeeId: data.employeeId,
        timestamp: savedEntry.timestamp,
        location: data.location?.address 
      },
      userId: data.employeeId
    });

    // Send notifications
    await this.notificationService.sendNotification({
      type: 'clock_in',
      recipients: ['supervisors', 'hr_team'],
      message: `Employee ${data.employeeId} clocked in at ${savedEntry.timestamp.toISOString()}`,
      data: { 
        employeeId: data.employeeId,
        timestamp: savedEntry.timestamp.toISOString()
      }
    });

    return savedEntry;
  }

  async clockOut(data: ClockOutData): Promise<TimeEntry> {
    // Find the corresponding clock-in entry
    const clockInEntry = await this.getCurrentTimeEntry(data.employeeId);
    if (!clockInEntry || !clockInEntry.isClockIn()) {
      throw new Error('No active clock-in entry found');
    }

    const timeEntry = this.timeEntryRepository.create({
      employeeId: data.employeeId,
      type: TimeEntryType.CLOCK_OUT,
      timestamp: new Date(),
      location: data.location,
      deviceInfo: data.deviceInfo,
      shiftId: clockInEntry.shiftId,
      notes: data.notes,
      photoUrl: data.photoUrl,
      status: TimeEntryStatus.COMPLETED
    });

    // Calculate hours worked
    const hoursWorked = timeEntry.calculateHoursFromPrevious(clockInEntry);
    timeEntry.hoursWorked = hoursWorked;

    // Determine if overtime
    if (hoursWorked > 8) {
      timeEntry.overtimeHours = hoursWorked - 8;
    }

    const savedEntry = await this.timeEntryRepository.save(timeEntry);

    // Update the clock-in entry status
    clockInEntry.status = TimeEntryStatus.COMPLETED;
    await this.timeEntryRepository.save(clockInEntry);

    // Update shift status if applicable
    if (clockInEntry.shiftId) {
      await this.updateShiftStatus(clockInEntry.shiftId, 'COMPLETED');
    }

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'TimeEntry',
      entityType: 'TimeEntry',
      entityId: savedEntry.id,
      action: 'CLOCK_OUT',
      details: { 
        employeeId: data.employeeId,
        timestamp: savedEntry.timestamp,
        hoursWorked: hoursWorked
      },
      userId: data.employeeId
    });

    // Send notifications for overtime
    if (timeEntry.overtimeHours && timeEntry.overtimeHours > 0) {
      await this.notificationService.sendNotification({
        type: 'overtime_worked',
        recipients: ['supervisors', 'hr_team'],
        message: `Employee ${data.employeeId} worked ${timeEntry.overtimeHours} overtime hours`,
        data: { 
          employeeId: data.employeeId,
          overtimeHours: timeEntry.overtimeHours
        }
      });
    }

    return savedEntry;
  }

  async startBreak(employeeId: string, deviceInfo: DeviceInfo): Promise<TimeEntry> {
    const currentEntry = await this.getCurrentTimeEntry(employeeId);
    if (!currentEntry || !currentEntry.isClockIn()) {
      throw new Error('Employee must be clocked in to start break');
    }

    const breakEntry = this.timeEntryRepository.create({
      employeeId,
      type: TimeEntryType.BREAK_START,
      timestamp: new Date(),
      deviceInfo,
      shiftId: currentEntry.shiftId,
      status: TimeEntryStatus.ACTIVE
    });

    return await this.timeEntryRepository.save(breakEntry);
  }

  async endBreak(employeeId: string, deviceInfo: DeviceInfo): Promise<TimeEntry> {
    const breakStartEntry = await this.timeEntryRepository.findOne({
      where: {
        employeeId,
        type: TimeEntryType.BREAK_START,
        status: TimeEntryStatus.ACTIVE
      },
      order: { timestamp: 'DESC' }
    });

    if (!breakStartEntry) {
      throw new Error('No active break found');
    }

    const breakEndEntry = this.timeEntryRepository.create({
      employeeId,
      type: TimeEntryType.BREAK_END,
      timestamp: new Date(),
      deviceInfo,
      shiftId: breakStartEntry.shiftId,
      status: TimeEntryStatus.COMPLETED
    });

    const breakDuration = breakEndEntry.calculateHoursFromPrevious(breakStartEntry) * 60; // Convert to minutes
    breakEndEntry.breakDuration = breakDuration;

    // Update break start entry
    breakStartEntry.status = TimeEntryStatus.COMPLETED;
    await this.timeEntryRepository.save(breakStartEntry);

    return await this.timeEntryRepository.save(breakEndEntry);
  }

  // Manual Time Entry (for corrections)
  async createManualEntry(data: ManualTimeEntry): Promise<TimeEntry> {
    const timeEntry = this.timeEntryRepository.create({
      employeeId: data.employeeId,
      type: data.type,
      timestamp: data.timestamp,
      shiftId: data.shiftId,
      notes: data.notes,
      isManualEntry: true,
      manualEntryReason: data.reason,
      approvedBy: data.approvedBy,
      approvedAt: new Date(),
      status: TimeEntryStatus.APPROVED,
      deviceInfo: {
        deviceId: 'manual-entry',
        deviceType: 'web',
        platform: 'web',
        appVersion: '1.0.0'
      }
    });

    const savedEntry = await this.timeEntryRepository.save(timeEntry);

    // Log audit trail for manual entry
    await this.auditService.logEvent({
      resource: 'TimeEntry',
      entityType: 'TimeEntry',
      entityId: savedEntry.id,
      action: 'MANUAL_ENTRY',
      details: { 
        employeeId: data.employeeId,
        timestamp: data.timestamp,
        reason: data.reason,
        approvedBy: data.approvedBy
      },
      userId: data.approvedBy
    });

    return savedEntry;
  }

  // Query Operations
  async getCurrentTimeEntry(employeeId: string): Promise<TimeEntry | null> {
    return await this.timeEntryRepository.findOne({
      where: {
        employeeId,
        status: TimeEntryStatus.ACTIVE
      },
      order: { timestamp: 'DESC' }
    });
  }

  async getEmployeeTimeEntries(
    employeeId: string, 
    startDate: Date, 
    endDate: Date
  ): Promise<TimeEntry[]> {
    return await this.timeEntryRepository.find({
      where: {
        employeeId,
        timestamp: {
          $gte: startDate,
          $lte: endDate
        } as any
      },
      order: { timestamp: 'ASC' },
      relations: ['employee']
    });
  }

  async getCurrentlyClockedInEmployees(): Promise<TimeEntry[]> {
    return await this.timeEntryRepository.find({
      where: {
        type: TimeEntryType.CLOCK_IN,
        status: TimeEntryStatus.ACTIVE
      },
      relations: ['employee'],
      order: { timestamp: 'DESC' }
    });
  }

  async getPendingApprovals(): Promise<TimeEntry[]> {
    return await this.timeEntryRepository.find({
      where: {
        status: TimeEntryStatus.DISPUTED
      },
      relations: ['employee'],
      order: { timestamp: 'DESC' }
    });
  }

  // Analytics and Reporting
  async getTimeTrackingMetrics(startDate: Date, endDate: Date): Promise<TimeTrackingMetrics> {
    const timeEntries = await this.timeEntryRepository.find({
      where: {
        timestamp: {
          $gte: startDate,
          $lte: endDate
        } as any
      },
      relations: ['employee']
    });

    const uniqueEmployees = new Set(timeEntries.map(entry => entry.employeeId));
    const currentlyClockedIn = await this.getCurrentlyClockedInEmployees();
    
    const totalHours = timeEntries
      .filter(entry => entry.hoursWorked)
      .reduce((sum, entry) => sum + entry.hoursWorked!, 0);
    
    const overtimeHours = timeEntries
      .filter(entry => entry.overtimeHours)
      .reduce((sum, entry) => sum + entry.overtimeHours!, 0);

    const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));

    return {
      totalEmployees: uniqueEmployees.size,
      currentlyClockedIn: currentlyClockedIn.length,
      averageHoursPerDay: totalHours / days,
      overtimeHours,
      lateArrivals: await this.countLateArrivals(startDate, endDate),
      earlyDepartures: await this.countEarlyDepartures(startDate, endDate),
      missedClockOuts: await this.countMissedClockOuts(startDate, endDate)
    };
  }

  async generateAttendanceReport(
    employeeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<AttendanceReport> {
    const timeEntries = await this.getEmployeeTimeEntries(employeeId, startDate, endDate);
    const employee = await this.employeeRepository.findOne({ where: { id: employeeId } });
    
    if (!employee) {
      throw new Error('Employee not found');
    }

    const clockOutEntries = timeEntries.filter(entry => entry.isClockOut());
    
    const totalHours = clockOutEntries.reduce((sum, entry) => sum + (entry.hoursWorked || 0), 0);
    const overtimeHours = clockOutEntries.reduce((sum, entry) => sum + (entry.overtimeHours || 0), 0);
    const regularHours = totalHours - overtimeHours;
    
    const daysWorked = new Set(clockOutEntries.map(entry => 
      entry.timestamp.toDateString()
    )).size;

    const expectedDays = this.calculateExpectedWorkingDays(startDate, endDate);
    const attendanceRate = (daysWorked / expectedDays) * 100;

    return {
      employeeId,
      employeeName: employee.getFullName(),
      totalHours,
      regularHours,
      overtimeHours,
      daysWorked,
      lateArrivals: await this.countEmployeeLateArrivals(employeeId, startDate, endDate),
      earlyDepartures: await this.countEmployeeEarlyDepartures(employeeId, startDate, endDate),
      attendanceRate
    };
  }

  // Validation and Helper Methods
  private async validateShiftLocation(shiftId: string, location?: LocationData): Promise<void> {
    if (!location) return;

    const shift = await this.shiftRepository.findOne({ where: { id: shiftId } });
    if (!shift?.location.coordinates) return;

    const expectedLocation = {
      latitude: shift.location.coordinates.latitude,
      longitude: shift.location.coordinates.longitude,
      timestamp: new Date()
    };

    const timeEntry = new TimeEntry();
    timeEntry.location = location;

    if (!timeEntry.isWithinLocationThreshold({...expectedLocation, timestamp: new Date()}, 100)) {
      throw new Error('Clock in location is outside the allowed area');
    }
  }

  private async updateShiftStatus(shiftId: string, status: string): Promise<void> {
    await this.shiftRepository.update(shiftId, { status: status as any });
  }

  private async countLateArrivals(startDate: Date, endDate: Date): Promise<number> {
    // Implementation would compare actual clock-in times with scheduled shift times
    return 0; // Production implementation
  }

  private async countEarlyDepartures(startDate: Date, endDate: Date): Promise<number> {
    // Implementation would compare actual clock-out times with scheduled shift times
    return 0; // Production implementation
  }

  private async countMissedClockOuts(startDate: Date, endDate: Date): Promise<number> {
    const missedClockOuts = await this.timeEntryRepository.count({
      where: {
        type: TimeEntryType.CLOCK_IN,
        status: TimeEntryStatus.ACTIVE,
        timestamp: {
          $lt: new Date(Date.now() - 24 * 60 * 60 * 1000) // More than 24 hours ago
        } as any
      }
    });

    return missedClockOuts;
  }

  private async countEmployeeLateArrivals(employeeId: string, startDate: Date, endDate: Date): Promise<number> {
    // Implementation would compare employee's clock-in times with scheduled shift times
    return 0; // Production implementation
  }

  private async countEmployeeEarlyDepartures(employeeId: string, startDate: Date, endDate: Date): Promise<number> {
    // Implementation would compare employee's clock-out times with scheduled shift times
    return 0; // Production implementation
  }

  private calculateExpectedWorkingDays(startDate: Date, endDate: Date): number {
    let count = 0;
    const currentDate = new Date(startDate);
    
    while (currentDate <= endDate) {
      const dayOfWeek = currentDate.getDay();
      if (dayOfWeek !== 0 && dayOfWeek !== 6) { // Not Sunday (0) or Saturday (6)
        count++;
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    return count;
  }
}