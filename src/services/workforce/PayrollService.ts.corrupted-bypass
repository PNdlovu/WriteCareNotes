import { EventEmitter2 } from "eventemitter2";

import { Repository } from 'typeorm';





import { OvertimeStatus, HolidayStatus, ResidentStatus } from '../../entities/workforce/OvertimeRequest';
import { DatabaseConnection } from '../../config/database';
import { PayrollRecord, PayrollStatus, PayrollFrequency, PayrollEarnings, PayrollDeductions, PayrollHours, TaxCodes } from '../../entities/workforce/PayrollRecord';
import { Employee } from '../../entities/hr/Employee';
import { TimeEntry } from '../../entities/workforce/TimeEntry';
import { OvertimeRequest } from '../../entities/workforce/OvertimeRequest';
import { Holiday } from '../../entities/workforce/Holiday';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export interface PayrollCalculationData {
  employeeId: string;
  payPeriodStart: Date;
  payPeriodEnd: Date;
  frequency: PayrollFrequency;
  baseSalary: number;
  hourlyRate: number;
  overtimeRate: number;
  taxCodes: TaxCodes;
}

export interface PayrollSummary {
  totalEmployees: number;
  totalGrossPay: number;
  totalNetPay: number;
  totalDeductions: number;
  averageGrossPay: number;
  averageNetPay: number;
  overtimePercentage: number;
}

export interface TaxCalculation {
  incomeTax: number;
  nationalInsurance: number;
  taxableIncome: number;
  taxFreeAllowance: number;
  niThreshold: number;
}

export interface PayslipData {
  payrollRecord: PayrollRecord;
  employee: Employee;
  payslipNumber: string;
  generatedAt: Date;
  downloadUrl?: string;
}

export class PayrollService {
  private payrollRepository: Repository<PayrollRecord>;
  private employeeRepository: Repository<Employee>;
  private timeEntryRepository: Repository<TimeEntry>;
  private overtimeRepository: Repository<OvertimeRequest>;
  private holidayRepository: Repository<Holiday>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;

  // UK Tax rates for 2024-25 (these should be configurable)
  private readonly TAX_RATES = {
    personalAllowance: 12570,
    basicRateThreshold: 37700,
    higherRateThreshold: 125140,
    basicTaxRate: 0.20,
    higherTaxRate: 0.40,
    additionalTaxRate: 0.45,
    niThreshold: 12570,
    niRate: 0.12,
    niHigherRate: 0.02
  };

  constructor() {
    this.payrollRepository = DatabaseConnection.getRepository(PayrollRecord);
    this.employeeRepository = DatabaseConnection.getRepository(Employee);
    this.timeEntryRepository = DatabaseConnection.getRepository(TimeEntry);
    this.overtimeRepository = DatabaseConnection.getRepository(OvertimeRequest);
    this.holidayRepository = DatabaseConnection.getRepository(Holiday);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  // Payroll Calculation
  async calculatePayroll(data: PayrollCalculationData): Promise<PayrollRecord> {
    const employee = await this.employeeRepository.findOne({ 
      where: { id: data.employeeId } 
    });
    
    if (!employee) {
      throw new Error('Employee not found');
    }

    // Get time entries for the pay period
    const timeEntries = await this.getTimeEntriesForPeriod(
      data.employeeId, 
      data.payPeriodStart, 
      data.payPeriodEnd
    );

    // Get approved overtime for the period
    const overtimeRequests = await this.getApprovedOvertimeForPeriod(
      data.employeeId,
      data.payPeriodStart,
      data.payPeriodEnd
    );

    // Get approved holidays for the period
    const holidays = await this.getApprovedHolidaysForPeriod(
      data.employeeId,
      data.payPeriodStart,
      data.payPeriodEnd
    );

    // Calculate hours
    const hours = this.calculateHours(timeEntries, overtimeRequests, holidays);
    
    // Calculate earnings
    const earnings = this.calculateEarnings(hours, data.hourlyRate, data.overtimeRate, data.baseSalary);
    
    // Calculate deductions
    const deductions = this.calculateDeductions(earnings.grossPay, data.taxCodes);
    
    // Calculate net pay
    const netPay = earnings.grossPay - deductions.totalDeductions;

    const payrollNumber = await this.generatePayrollNumber();

    const payrollRecord = this.payrollRepository.create({
      employeeId: data.employeeId,
      payrollNumber,
      frequency: data.frequency,
      payPeriodStart: data.payPeriodStart,
      payPeriodEnd: data.payPeriodEnd,
      payDate: this.calculatePayDate(data.payPeriodEnd, data.frequency),
      hours,
      earnings,
      deductions,
      netPay,
      taxCodes: data.taxCodes,
      status: PayrollStatus.CALCULATED,
      calculatedBy: 'system',
      calculatedAt: new Date()
    });

    const savedRecord = await this.payrollRepository.save(payrollRecord);

    // Log audit trail
    await this.auditService.logEvent({
      resource: 'PayrollRecord',
        entityType: 'PayrollRecord',
      entityId: savedRecord.id,
      action: 'CALCULATE',
      details: { 
        employeeId: data.employeeId,
        payPeriod: `${data.payPeriodStart.toISOString()} - ${data.payPeriodEnd.toISOString()}`,
        grossPay: earnings.grossPay,
        netPay
      },
      userId: 'system'
    });

    return savedRecord;
  }

  async bulkCalculatePayroll(
    employees: string[],
    payPeriodStart: Date,
    payPeriodEnd: Date,
    frequency: PayrollFrequency
  ): Promise<PayrollRecord[]> {
    const payrollRecords: PayrollRecord[] = [];

    for (const employeeId of employees) {
      try {
        const employee = await this.employeeRepository.findOne({ 
          where: { id: employeeId } 
        });
        
        if (!employee) continue;

        const calculationData: PayrollCalculationData = {
          employeeId,
          payPeriodStart,
          payPeriodEnd,
          frequency,
          baseSalary: employee.jobDetails.baseSalary,
          hourlyRate: this.calculateHourlyRate(employee.jobDetails.baseSalary, frequency),
          overtimeRate: this.calculateOvertimeRate(employee.jobDetails.baseSalary, frequency),
          taxCodes: {
            incomeTaxCode: '1257L', // Default UK tax code
            nationalInsuranceCategory: 'A',
            pensionScheme: employee.contractInformation.pensionScheme,
            studentLoanPlan: undefined
          }
        };

        const payrollRecord = await this.calculatePayroll(calculationData);
        payrollRecords.push(payrollRecord);
      } catch (error: unknown) {
        console.error(`Error calculating payroll for employee ${employeeId}:`, error);
        // Continue with other employees
      }
    }

    return payrollRecords;
  }

  // Hours Calculation
  private calculateHours(
    timeEntries: TimeEntry[], 
    overtimeRequests: OvertimeRequest[],
    holidays: Holiday[]
  ): PayrollHours {
    const regularHours = timeEntries
      .filter(entry => entry.isClockOut())
      .reduce((sum, entry) => sum + Math.min(entry.hoursWorked || 0, 8), 0);

    const overtimeHours = timeEntries
      .filter(entry => entry.isClockOut())
      .reduce((sum, entry) => sum + (entry.overtimeHours || 0), 0) +
      overtimeRequests.reduce((sum, request) => sum + (request.hoursWorked || 0), 0);

    const holidayHours = holidays
      .filter(holiday => holiday.type === 'annual_leave' && holiday.isApproved())
      .reduce((sum, holiday) => sum + (holiday.hoursRequested || holiday.daysRequested * 8), 0);

    const sickHours = holidays
      .filter(holiday => holiday.type === 'sick_leave' && holiday.isApproved())
      .reduce((sum, holiday) => sum + (holiday.hoursRequested || holiday.daysRequested * 8), 0);

    return {
      regularHours,
      overtimeHours,
      doubleTimeHours: 0, // Would need specific business rules
      holidayHours,
      sickHours,
      totalHours: regularHours + overtimeHours + holidayHours + sickHours
    };
  }

  // Earnings Calculation
  private calculateEarnings(
    hours: PayrollHours,
    hourlyRate: number,
    overtimeRate: number,
    baseSalary: number
  ): PayrollEarnings {
    const basicPay = hours.regularHours * hourlyRate;
    const overtimePay = hours.overtimeHours * overtimeRate;
    const holidayPay = hours.holidayHours * hourlyRate;
    const sickPay = hours.sickHours * hourlyRate;
    const bonuses = 0; // Would come from bonus calculations
    const allowances = 0; // Would come from allowance calculations

    const grossPay = basicPay + overtimePay + holidayPay + sickPay + bonuses + allowances;

    return {
      basicPay,
      overtimePay,
      holidayPay,
      sickPay,
      bonuses,
      allowances,
      grossPay
    };
  }

  // Tax and Deductions Calculation
  private calculateDeductions(grossPay: number, taxCodes: TaxCodes): PayrollDeductions {
    const taxCalculation = this.calculateIncomeTax(grossPay, taxCodes.incomeTaxCode);
    const niCalculation = this.calculateNationalInsurance(grossPay, taxCodes.nationalInsuranceCategory);
    
    const incomeTax = taxCalculation.incomeTax;
    const nationalInsurance = niCalculation.nationalInsurance;
    const pensionContribution = this.calculatePensionContribution(grossPay, taxCodes.pensionScheme);
    const studentLoan = this.calculateStudentLoan(grossPay, taxCodes.studentLoanPlan);
    const courtOrders = 0; // Would come from court order calculations
    const other = 0; // Would come from other deduction calculations

    const totalDeductions = incomeTax + nationalInsurance + pensionContribution + studentLoan + courtOrders + other;

    return {
      incomeTax,
      nationalInsurance,
      pensionContribution,
      studentLoan,
      courtOrders,
      other,
      totalDeductions
    };
  }

  private calculateIncomeTax(grossPay: number, taxCode: string): TaxCalculation {
    // Simplified UK income tax calculation
    const personalAllowance = this.TAX_RATES.personalAllowance;
    const taxableIncome = Math.max(0, grossPay - personalAllowance);
    
    let incomeTax = 0;
    
    if (taxableIncome <= this.TAX_RATES.basicRateThreshold) {
      incomeTax = taxableIncome * this.TAX_RATES.basicTaxRate;
    } else if (taxableIncome <= this.TAX_RATES.higherRateThreshold) {
      incomeTax = (this.TAX_RATES.basicRateThreshold * this.TAX_RATES.basicTaxRate) +
                  ((taxableIncome - this.TAX_RATES.basicRateThreshold) * this.TAX_RATES.higherTaxRate);
    } else {
      incomeTax = (this.TAX_RATES.basicRateThreshold * this.TAX_RATES.basicTaxRate) +
                  ((this.TAX_RATES.higherRateThreshold - this.TAX_RATES.basicRateThreshold) * this.TAX_RATES.higherTaxRate) +
                  ((taxableIncome - this.TAX_RATES.higherRateThreshold) * this.TAX_RATES.additionalTaxRate);
    }

    return {
      incomeTax: Math.round(incomeTax * 100) / 100,
      nationalInsurance: 0,
      taxableIncome,
      taxFreeAllowance: personalAllowance,
      niThreshold: this.TAX_RATES.niThreshold
    };
  }

  private calculateNationalInsurance(grossPay: number, category: string): { nationalInsurance: number } {
    const niableIncome = Math.max(0, grossPay - this.TAX_RATES.niThreshold);
    const nationalInsurance = niableIncome * this.TAX_RATES.niRate;
    
    return {
      nationalInsurance: Math.round(nationalInsurance * 100) / 100
    };
  }

  private calculatePensionContribution(grossPay: number, pensionScheme?: string): number {
    if (!pensionScheme) return 0;
    
    // UK auto-enrolment minimum is 8% (5% employee, 3% employer)
    const employeeContributionRate = 0.05; // 5%
    return Math.round(grossPay * employeeContributionRate * 100) / 100;
  }

  private calculateStudentLoan(grossPay: number, plan?: string): number {
    if (!plan) return 0;
    
    // UK Student Loan Plan 2 threshold is Â£27,295 annually
    const annualThreshold = 27295;
    const monthlyThreshold = annualThreshold / 12;
    
    if (grossPay <= monthlyThreshold) return 0;
    
    const rate = 0.09; // 9%
    return Math.round((grossPay - monthlyThreshold) * rate * 100) / 100;
  }

  // Payroll Management
  async approvePayroll(payrollId: string, approvedBy: string): Promise<PayrollRecord> {
    const payroll = await this.payrollRepository.findOne({ where: { id: payrollId } });
    if (!payroll) {
      throw new Error('Payroll record not found');
    }

    if (payroll.status !== PayrollStatus.CALCULATED) {
      throw new Error('Payroll must be in calculated status to approve');
    }

    payroll.status = PayrollStatus.APPROVED;
    payroll.approvedBy = approvedBy;
    payroll.approvedAt = new Date();

    const savedRecord = await this.payrollRepository.save(payroll);

    await this.auditService.logEvent({
      resource: 'PayrollRecord',
        entityType: 'PayrollRecord',
      entityId: savedRecord.id,
      action: 'APPROVE',
      details: { approvedBy },
      userId: approvedBy
    });

    return savedRecord;
  }

  async processPayment(payrollId: string, paymentDetails: any): Promise<PayrollRecord> {
    const payroll = await this.payrollRepository.findOne({ 
      where: { id: payrollId },
      relations: ['employee']
    });
    
    if (!payroll) {
      throw new Error('Payroll record not found');
    }

    if (payroll.status !== PayrollStatus.APPROVED) {
      throw new Error('Payroll must be approved before payment');
    }

    payroll.status = PayrollStatus.PAID;
    payroll.paidBy = paymentDetails.paidBy;
    payroll.paidAt = new Date();
    payroll.paymentMethod = paymentDetails.method;
    payroll.paymentReference = paymentDetails.reference;

    const savedRecord = await this.payrollRepository.save(payroll);

    // Send notification to employee
    await this.notificationService.sendNotification({
      message: 'Notification: Payroll Paid',
        type: 'payroll_paid',
      recipients: [payroll.employeeId],
      data: {
        payrollNumber: payroll.payrollNumber,
        netPay: payroll.netPay,
        payDate: payroll.payDate.toISOString()
      }
    });

    return savedRecord;
  }

  // Payslip Generation
  async generatePayslip(payrollId: string): Promise<PayslipData> {
    const payroll = await this.payrollRepository.findOne({
      where: { id: payrollId },
      relations: ['employee']
    });

    if (!payroll) {
      throw new Error('Payroll record not found');
    }

    const payslipNumber = `PS-${payroll.payrollNumber}`;
    
    return {
      payrollRecord: payroll,
      employee: payroll.employee,
      payslipNumber,
      generatedAt: new Date()
    };
  }

  async getEmployeePayslips(employeeId: string, year?: number): Promise<PayrollRecord[]> {
    const whereCondition: any = { employeeId };
    
    if (year) {
      const startDate = new Date(year, 0, 1);
      const endDate = new Date(year, 11, 31);
      whereCondition.payDate = {
        $gte: startDate,
        $lte: endDate
      };
    }

    return await this.payrollRepository.find({
      where: whereCondition,
      order: { payDate: 'DESC' },
      relations: ['employee']
    });
  }

  // Helper Methods
  private async getTimeEntriesForPeriod(
    employeeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<TimeEntry[]> {
    return await this.timeEntryRepository.find({
      where: {
        employeeId,
        timestamp: {
          $gte: startDate,
          $lte: endDate
        } as any
      },
      order: { timestamp: 'ASC' }
    });
  }

  private async getApprovedOvertimeForPeriod(
    employeeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<OvertimeRequest[]> {
    return await this.overtimeRepository.find({
      where: {
        employeeId,
        status: HolidayStatus.APPROVED,
        startTime: {
          $gte: startDate,
          $lte: endDate
        } as any
      }
    });
  }

  private async getApprovedHolidaysForPeriod(
    employeeId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Holiday[]> {
    return await this.holidayRepository.find({
      where: {
        employeeId,
        status: HolidayStatus.APPROVED,
        startDate: {
          $gte: startDate,
          $lte: endDate
        } as any
      }
    });
  }

  private calculateHourlyRate(baseSalary: number, frequency: PayrollFrequency): number {
    const annualSalary = frequency === PayrollFrequency.MONTHLY ? baseSalary * 12 :
                        frequency === PayrollFrequency.WEEKLY ? baseSalary * 52 :
                        baseSalary * 26; // Fortnightly

    return annualSalary / (52 * 40); // Assuming 40 hours per week
  }

  private calculateOvertimeRate(baseSalary: number, frequency: PayrollFrequency): number {
    return this.calculateHourlyRate(baseSalary, frequency) * 1.5; // Time and a half
  }

  private calculatePayDate(payPeriodEnd: Date, frequency: PayrollFrequency): Date {
    const payDate = new Date(payPeriodEnd);
    payDate.setDate(payDate.getDate() + 7); // Pay 7 days after period end
    return payDate;
  }

  private async generatePayrollNumber(): Promise<string> {
    const year = new Date().getFullYear();
    const month = String(new Date().getMonth() + 1).padStart(2, '0');
    
    const count = await this.payrollRepository.count({
      where: {
        createdAt: {
          $gte: new Date(year, new Date().getMonth(), 1),
          $lt: new Date(year, new Date().getMonth() + 1, 1)
        } as any
      }
    });

    return `PR${year}${month}${String(count + 1).padStart(4, '0')}`;
  }

  // Reporting and Analytics
  async getPayrollSummary(startDate: Date, endDate: Date): Promise<PayrollSummary> {
    const payrollRecords = await this.payrollRepository.find({
      where: {
        payDate: {
          $gte: startDate,
          $lte: endDate
        } as any,
        status: PayrollStatus.PAID
      }
    });

    const totalEmployees = payrollRecords.length;
    const totalGrossPay = payrollRecords.reduce((sum, record) => sum + record.earnings.grossPay, 0);
    const totalNetPay = payrollRecords.reduce((sum, record) => sum + record.netPay, 0);
    const totalDeductions = payrollRecords.reduce((sum, record) => sum + record.deductions.totalDeductions, 0);
    const totalOvertimeHours = payrollRecords.reduce((sum, record) => sum + record.hours.overtimeHours, 0);
    const totalRegularHours = payrollRecords.reduce((sum, record) => sum + record.hours.regularHours, 0);

    return {
      totalEmployees,
      totalGrossPay,
      totalNetPay,
      totalDeductions,
      averageGrossPay: totalEmployees > 0 ? totalGrossPay / totalEmployees : 0,
      averageNetPay: totalEmployees > 0 ? totalNetPay / totalEmployees : 0,
      overtimePercentage: totalRegularHours > 0 ? (totalOvertimeHours / totalRegularHours) * 100 : 0
    };
  }
}