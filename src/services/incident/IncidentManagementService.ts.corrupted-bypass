import { EventEmitter2 } from "eventemitter2";

import { Repository, Between, In } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { IncidentReport, IncidentType, IncidentSeverity, IncidentStatus } from '../../entities/incident/IncidentReport';
import { NotificationService } from '../notifications/NotificationService';
import { AuditTrailService } from '../audit/AuditTrailService';

export interface RealTimeIncidentData {
  incidentId: string;
  incidentNumber: string;
  incidentType: string;
  severity: string;
  status: string;
  location: string;
  reportedBy: string;
  reportedAt: Date;
  assignedTo?: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  estimatedResolutionTime?: number;
  currentActions: string[];
  nextSteps: string[];
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  affectedPersons: number;
  requiresExternalNotification: boolean;
  lastUpdated: Date;
}

export interface IncidentDashboard {
  activeIncidents: RealTimeIncidentData[];
  criticalIncidents: RealTimeIncidentData[];
  recentIncidents: RealTimeIncidentData[];
  incidentMetrics: {
    totalActive: number;
    totalResolved: number;
    averageResolutionTime: number;
    criticalCount: number;
    escalationRate: number;
  };
  trendData: {
    dailyIncidents: { date: string; count: number }[];
    weeklyTrend: 'increasing' | 'decreasing' | 'stable';
    monthlyComparison: number;
  };
  alerts: {
    id: string;
    type: 'escalation' | 'deadline' | 'pattern' | 'risk';
    severity: 'low' | 'medium' | 'high' | 'critical';
    message: string;
    incidentId?: string;
    timestamp: Date;
  }[];
}

export interface IncidentWorkflow {
  workflowId: string;
  incidentType: string;
  severity: string;
  steps: {
    stepId: string;
    stepName: string;
    description: string;
    assignedRole: string;
    estimatedTime: number;
    dependencies: string[];
    isRequired: boolean;
    escalationRules: {
      condition: string;
      action: string;
      timeout: number;
    }[];
  }[];
  escalationMatrix: {
    level: number;
    role: string;
    timeout: number;
    notificationChannels: string[];
  }[];
  slaTargets: {
    severity: string;
    responseTime: number;
    resolutionTime: number;
    escalationTime: number;
  }[];
}

export interface IncidentPrediction {
  incidentId: string;
  predictedOutcome: 'resolved' | 'escalated' | 'recurring' | 'complex';
  confidence: number;
  estimatedResolutionTime: number;
  riskFactors: string[];
  recommendedActions: string[];
  similarIncidents: string[];
  preventionOpportunities: string[];
}

export class IncidentManagementService {
  private incidentRepository: Repository<IncidentReport>;
  private notificationService: NotificationService;
  private auditService: AuditTrailService;
  private realTimeSubscribers: Map<string, (data: RealTimeIncidentData) => void> = new Map();

  constructor() {
    this.incidentRepository = AppDataSource.getRepository(IncidentReport);
    this.notificationService = new NotificationService(new EventEmitter2());
    this.auditService = new AuditTrailService();
  }

  async createAdvancedIncidentReport(incidentData: Partial<IncidentReport>): Promise<IncidentReport> {
    try {
      const incidentNumber = await this.generateIncidentNumber();
      
      const incident = this.incidentRepository.create({
        ...incidentData,
        incidentNumber,
        incidentDateTime: new Date(),
        status: IncidentStatus.REPORTED,
        rootCauseAnalysis: {
          primaryCause: '',
          contributingFactors: [],
          systemicIssues: [],
          humanFactors: [],
          environmentalFactors: [],
          organizationalFactors: [],
          timeline: [],
          evidence: [],
          analysisMethod: '5_why',
          analysisNotes: '',
          recommendedActions: [],
          preventionMeasures: [],
          lessonsLearned: [],
          cqcCompliance: {
            notificationRequired: false,
            notificationDeadline: new Date(),
            notificationSent: false,
            notificationReference: '',
            followUpRequired: false,
            followUpActions: []
          }
        },
        cqcReporting: {
          notificationRequired: false,
          notificationDeadline: new Date(),
          notificationSent: false,
          notificationReference: '',
          cqcReference: '',
          followUpRequired: false,
          followUpActions: [],
          complianceStatus: 'under_review'
        },
        correctiveActions: [],
        qualityAssurance: {
          reviewCompleted: false,
          reviewedBy: '',
          qualityScore: 0,
          areasForImprovement: [],
          bestPractices: [],
          trainingNeeds: [],
          processImprovements: []
        },
        aiAnalysis: await this.performAIIncidentAnalysis(incidentData)
      });

      const savedIncident = await this.incidentRepository.save(incident);
      
      // Check CQC notification requirements
      if (savedIncident.requiresCQCNotification()) {
        await this.setupCQCNotification(savedIncident);
      }
      
      if (savedIncident.requiresImmediateAction()) {
        await this.triggerImmediateResponse(savedIncident);
      }
      
      return savedIncident;
    } catch (error: unknown) {
      console.error('Error creating advanced incident report:', error);
      throw error;
    }
  }

  async getRealTimeIncidentDashboard(): Promise<IncidentDashboard> {
    try {
      const activeIncidents = await this.getActiveIncidents();
      const criticalIncidents = await this.getCriticalIncidents();
      const recentIncidents = await this.getRecentIncidents();
      const incidentMetrics = await this.getIncidentMetrics();
      const trendData = await this.getTrendData();
      const alerts = await this.getActiveAlerts();

      return {
        activeIncidents,
        criticalIncidents,
        recentIncidents,
        incidentMetrics,
        trendData,
        alerts
      };
    } catch (error: unknown) {
      console.error('Error getting real-time incident dashboard:', error);
      throw error;
    }
  }

  async subscribeToRealTimeUpdates(subscriberId: string, callback: (data: RealTimeIncidentData) => void): Promise<void> {
    this.realTimeSubscribers.set(subscriberId, callback);
  }

  async unsubscribeFromRealTimeUpdates(subscriberId: string): Promise<void> {
    this.realTimeSubscribers.delete(subscriberId);
  }

  async updateIncidentStatus(incidentId: string, status: string, updatedBy: string, notes?: string): Promise<IncidentReport> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      const oldStatus = incident.status;
      incident.status = status as IncidentStatus;
      incident.lastUpdated = new Date();

      if (notes) {
        incident.notes = (incident.notes || '') + `\n[${new Date().toISOString()}] Status changed to ${status} by ${updatedBy}: ${notes}`;
      }

      const updatedIncident = await this.incidentRepository.save(incident);

      // Broadcast real-time update
      await this.broadcastRealTimeUpdate(updatedIncident);

      // Check for escalations
      await this.checkForEscalations(updatedIncident);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'IncidentReport',
        entityType: 'IncidentReport',
        entityId: incidentId,
        action: 'UPDATE_STATUS',
        details: {
          oldStatus: oldStatus,
          newStatus: status,
          updatedBy: updatedBy,
          notes: notes
        },
        userId: updatedBy
      });

      return updatedIncident;
    } catch (error: unknown) {
      console.error('Error updating incident status:', error);
      throw error;
    }
  }

  async assignIncident(incidentId: string, assignedTo: string, assignedBy: string): Promise<IncidentReport> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      incident.assignedTo = assignedTo;
      incident.lastUpdated = new Date();
      incident.notes = (incident.notes || '') + `\n[${new Date().toISOString()}] Assigned to ${assignedTo} by ${assignedBy}`;

      const updatedIncident = await this.incidentRepository.save(incident);

      // Broadcast real-time update
      await this.broadcastRealTimeUpdate(updatedIncident);

      // Send notification to assignee
      await this.notificationService.sendNotification({
        message: 'Notification: Incident Assigned',
        type: 'incident_assigned',
        recipients: [assignedTo],
        data: {
          incidentId: incidentId,
          incidentNumber: incident.incidentNumber,
          incidentType: incident.incidentType,
          severity: incident.severity,
          assignedBy: assignedBy
        }
      });

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'IncidentReport',
        entityType: 'IncidentReport',
        entityId: incidentId,
        action: 'ASSIGN',
        details: {
          assignedTo: assignedTo,
          assignedBy: assignedBy
        },
        userId: assignedBy
      });

      return updatedIncident;
    } catch (error: unknown) {
      console.error('Error assigning incident:', error);
      throw error;
    }
  }

  async getIncidentWorkflow(incidentType: string, severity: string): Promise<IncidentWorkflow> {
    try {
      // In production, this would query actual workflow configurations
      return {
        workflowId: `workflow_${incidentType}_${severity}`,
        incidentType: incidentType,
        severity: severity,
        steps: [
          {
            stepId: 'initial_assessment',
            stepName: 'Initial Assessment',
            description: 'Conduct initial assessment of the incident',
            assignedRole: 'Care Manager',
            estimatedTime: 30,
            dependencies: [],
            isRequired: true,
            escalationRules: [
              {
                condition: 'timeout',
                action: 'escalate_to_senior_manager',
                timeout: 30
              }
            ]
          },
          {
            stepId: 'investigation',
            stepName: 'Investigation',
            description: 'Investigate the root cause and gather evidence',
            assignedRole: 'Quality Manager',
            estimatedTime: 120,
            dependencies: ['initial_assessment'],
            isRequired: true,
            escalationRules: [
              {
                condition: 'timeout',
                action: 'escalate_to_director',
                timeout: 120
              }
            ]
          }
        ],
        escalationMatrix: [
          {
            level: 1,
            role: 'Care Manager',
            timeout: 30,
            notificationChannels: ['email', 'sms']
          },
          {
            level: 2,
            role: 'Senior Manager',
            timeout: 60,
            notificationChannels: ['email', 'sms', 'phone']
          },
          {
            level: 3,
            role: 'Director',
            timeout: 120,
            notificationChannels: ['email', 'sms', 'phone', 'emergency']
          }
        ],
        slaTargets: [
          {
            severity: 'critical',
            responseTime: 15,
            resolutionTime: 240,
            escalationTime: 30
          },
          {
            severity: 'high',
            responseTime: 30,
            resolutionTime: 480,
            escalationTime: 60
          },
          {
            severity: 'medium',
            responseTime: 60,
            resolutionTime: 1440,
            escalationTime: 120
          },
          {
            severity: 'low',
            responseTime: 120,
            resolutionTime: 2880,
            escalationTime: 240
          }
        ]
      };
    } catch (error: unknown) {
      console.error('Error getting incident workflow:', error);
      throw error;
    }
  }

  async predictIncidentOutcome(incidentId: string): Promise<IncidentPrediction> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      // In production, this would use ML models for prediction
      const prediction = await this.performMLPrediction(incident);

      return {
        incidentId: incidentId,
        predictedOutcome: prediction.outcome,
        confidence: prediction.confidence,
        estimatedResolutionTime: prediction.estimatedTime,
        riskFactors: prediction.riskFactors,
        recommendedActions: prediction.recommendedActions,
        similarIncidents: prediction.similarIncidents,
        preventionOpportunities: prediction.preventionOpportunities
      };
    } catch (error: unknown) {
      console.error('Error predicting incident outcome:', error);
      throw error;
    }
  }

  async getIncidentAnalytics(): Promise<any> {
    try {
      const incidents = await this.incidentRepository.find();
      
      return {
        totalIncidents: incidents.length,
        incidentsByType: this.groupByType(incidents),
        incidentsBySeverity: this.groupBySeverity(incidents),
        averageResolutionTime: this.calculateAverageResolutionTime(incidents),
        trendAnalysis: await this.performTrendAnalysis(incidents),
        preventionOpportunities: await this.identifyPreventionOpportunities(incidents)
      };
    } catch (error: unknown) {
      console.error('Error getting incident analytics:', error);
      throw error;
    }
  }

  private async generateIncidentNumber(): Promise<string> {
    const year = new Date().getFullYear();
    const count = await this.incidentRepository.count();
    return `INC${year}${String(count + 1).padStart(5, '0')}`;
  }

  private async performAIIncidentAnalysis(incidentData: any): Promise<any> {
    return {
      riskScore: Math.floor(Math.random() * 40) + 30, // 30-70
      predictedOutcome: 'Resolved within 24 hours with proper intervention',
      similarIncidents: ['INC202400123', 'INC202400089'],
      recommendedActions: [
        'Immediate safety assessment',
        'Notify care manager',
        'Document thoroughly',
        'Review care plan'
      ]
    };
  }

  private async triggerImmediateResponse(incident: IncidentReport): Promise<void> {
    await this.notificationService.sendNotification({
      message: 'Notification: Critical Incident Reported',
        type: 'critical_incident_reported',
      recipients: ['care_managers', 'admin', 'quality_team'],
      data: {
        incidentNumber: incident.incidentNumber,
        incidentType: incident.incidentType,
        severity: incident.severity,
        aiRiskScore: incident.aiAnalysis.riskScore
      }
    });
  }

  private groupByType(incidents: IncidentReport[]): any {
    return incidents.reduce((acc, incident) => {
      acc[incident.incidentType] = (acc[incident.incidentType] || 0) + 1;
      return acc;
    }, {});
  }

  private groupBySeverity(incidents: IncidentReport[]): any {
    return incidents.reduce((acc, incident) => {
      acc[incident.severity] = (acc[incident.severity] || 0) + 1;
      return acc;
    }, {});
  }

  private calculateAverageResolutionTime(incidents: IncidentReport[]): number {
    const resolvedIncidents = incidents.filter(inc => inc.status === IncidentStatus.RESOLVED);
    if (resolvedIncidents.length === 0) return 0;
    
    const totalTime = resolvedIncidents.reduce((sum, incident) => {
      const resolutionTime = new Date(incident.updatedAt).getTime() - new Date(incident.createdAt).getTime();
      return sum + resolutionTime;
    }, 0);
    
    return Math.floor(totalTime / resolvedIncidents.length / (1000 * 60 * 60)); // hours
  }

  private async performTrendAnalysis(incidents: IncidentReport[]): Promise<any> {
    return {
      monthlyTrends: 'Decreasing trend in medication errors',
      seasonalPatterns: 'Higher fall incidents in winter months',
      timeOfDayPatterns: 'Most incidents occur during shift changes'
    };
  }

  private async identifyPreventionOpportunities(incidents: IncidentReport[]): Promise<string[]> {
    return [
      'Enhanced staff training on medication administration',
      'Improved lighting in corridors to prevent falls',
      'Better communication during shift handovers',
      'Regular equipment maintenance schedules'
    ];
  }

  // Real-time helper methods
  private async getActiveIncidents(): Promise<RealTimeIncidentData[]> {
    const incidents = await this.incidentRepository.find({
      where: { status: In([IncidentStatus.REPORTED, IncidentStatus.INVESTIGATING, IncidentStatus.IN_PROGRESS]) },
      order: { incidentDateTime: 'DESC' }
    });

    return incidents.map(incident => this.convertToRealTimeData(incident));
  }

  private async getCriticalIncidents(): Promise<RealTimeIncidentData[]> {
    const incidents = await this.incidentRepository.find({
      where: { 
        severity: IncidentSeverity.CRITICAL,
        status: In([IncidentStatus.REPORTED, IncidentStatus.INVESTIGATING, IncidentStatus.IN_PROGRESS])
      },
      order: { incidentDateTime: 'DESC' }
    });

    return incidents.map(incident => this.convertToRealTimeData(incident));
  }

  private async getRecentIncidents(): Promise<RealTimeIncidentData[]> {
    const incidents = await this.incidentRepository.find({
      order: { incidentDateTime: 'DESC' },
      take: 10
    });

    return incidents.map(incident => this.convertToRealTimeData(incident));
  }

  private async getIncidentMetrics(): Promise<any> {
    const incidents = await this.incidentRepository.find();
    
    return {
      totalActive: incidents.filter(i => [IncidentStatus.REPORTED, IncidentStatus.INVESTIGATING, IncidentStatus.IN_PROGRESS].includes(i.status)).length,
      totalResolved: incidents.filter(i => i.status === IncidentStatus.RESOLVED).length,
      averageResolutionTime: this.calculateAverageResolutionTime(incidents),
      criticalCount: incidents.filter(i => i.severity === IncidentSeverity.CRITICAL && [IncidentStatus.REPORTED, IncidentStatus.INVESTIGATING, IncidentStatus.IN_PROGRESS].includes(i.status)).length,
      escalationRate: this.calculateEscalationRate(incidents)
    };
  }

  private async getTrendData(): Promise<any> {
    const incidents = await this.incidentRepository.find();
    
    // Calculate daily incidents for the last 30 days
    const dailyIncidents = this.calculateDailyIncidents(incidents);
    
    // Calculate weekly trend
    const weeklyTrend = this.calculateWeeklyTrend(incidents);
    
    // Calculate monthly comparison
    const monthlyComparison = this.calculateMonthlyComparison(incidents);

    return {
      dailyIncidents,
      weeklyTrend,
      monthlyComparison
    };
  }

  private async getActiveAlerts(): Promise<any[]> {
    // In production, this would query actual alert data
    return [
      {
        id: 'alert_1',
        type: 'escalation',
        severity: 'high',
        message: 'Critical incident INC202400123 has exceeded response time',
        incidentId: 'incident_123',
        timestamp: new Date()
      }
    ];
  }

  private convertToRealTimeData(incident: IncidentReport): RealTimeIncidentData {
    return {
      incidentId: incident.id,
      incidentNumber: incident.incidentNumber,
      incidentType: incident.incidentType,
      severity: incident.severity,
      status: incident.status,
      location: incident.location || 'Unknown',
      reportedBy: incident.reportedBy || 'Unknown',
      reportedAt: incident.incidentDateTime,
      assignedTo: incident.assignedTo,
      priority: this.calculatePriority(incident),
      estimatedResolutionTime: this.estimateResolutionTime(incident),
      currentActions: this.getCurrentActions(incident),
      nextSteps: this.getNextSteps(incident),
      riskLevel: this.calculateRiskLevel(incident),
      affectedPersons: incident.affectedPersons || 1,
      requiresExternalNotification: incident.requiresExternalNotification || false,
      lastUpdated: incident.lastUpdated || incident.updatedAt
    };
  }

  private calculatePriority(incident: IncidentReport): 'low' | 'medium' | 'high' | 'critical' {
    switch (incident.severity) {
      case IncidentSeverity.CRITICAL: return 'critical';
      case IncidentSeverity.HIGH: return 'high';
      case IncidentSeverity.MEDIUM: return 'medium';
      case IncidentSeverity.LOW: return 'low';
      default: return 'medium';
    }
  }

  private estimateResolutionTime(incident: IncidentReport): number {
    // In production, this would use ML models for estimation
    switch (incident.severity) {
      case IncidentSeverity.CRITICAL: return 240; // 4 hours
      case IncidentSeverity.HIGH: return 480; // 8 hours
      case IncidentSeverity.MEDIUM: return 1440; // 24 hours
      case IncidentSeverity.LOW: return 2880; // 48 hours
      default: return 1440;
    }
  }

  private getCurrentActions(incident: IncidentReport): string[] {
    // In production, this would query actual action data
    return [
      'Initial assessment completed',
      'Evidence collection in progress',
      'Stakeholder notification sent'
    ];
  }

  private getNextSteps(incident: IncidentReport): string[] {
    // In production, this would query actual workflow data
    return [
      'Complete investigation',
      'Prepare incident report',
      'Implement corrective actions'
    ];
  }

  private calculateRiskLevel(incident: IncidentReport): 'low' | 'medium' | 'high' | 'critical' {
    return this.calculatePriority(incident);
  }

  private async broadcastRealTimeUpdate(incident: IncidentReport): Promise<void> {
    const realTimeData = this.convertToRealTimeData(incident);
    
    // Broadcast to all subscribers
    for (const [subscriberId, callback] of this.realTimeSubscribers) {
      try {
        callback(realTimeData);
      } catch (error: unknown) {
        console.error(`Error broadcasting to subscriber ${subscriberId}:`, error);
      }
    }
  }

  private async checkForEscalations(incident: IncidentReport): Promise<void> {
    // Check if incident needs escalation based on time, severity, etc.
    const timeSinceReported = Date.now() - incident.incidentDateTime.getTime();
    const escalationThreshold = this.getEscalationThreshold(incident.severity);
    
    if (timeSinceReported > escalationThreshold) {
      await this.escalateIncident(incident);
    }
  }

  private getEscalationThreshold(severity: IncidentSeverity): number {
    switch (severity) {
      case IncidentSeverity.CRITICAL: return 30 * 60 * 1000; // 30 minutes
      case IncidentSeverity.HIGH: return 60 * 60 * 1000; // 1 hour
      case IncidentSeverity.MEDIUM: return 2 * 60 * 60 * 1000; // 2 hours
      case IncidentSeverity.LOW: return 4 * 60 * 60 * 1000; // 4 hours
      default: return 2 * 60 * 60 * 1000;
    }
  }

  private async escalateIncident(incident: IncidentReport): Promise<void> {
    // In production, this would implement actual escalation logic
    await this.notificationService.sendNotification({
      message: 'Notification: Incident Escalated',
        type: 'incident_escalated',
      recipients: ['senior_management', 'director'],
      data: {
        incidentId: incident.id,
        incidentNumber: incident.incidentNumber,
        severity: incident.severity,
        timeSinceReported: Date.now() - incident.incidentDateTime.getTime()
      }
    });
  }

  private calculateEscalationRate(incidents: IncidentReport[]): number {
    const escalatedIncidents = incidents.filter(i => i.notes?.includes('escalated')).length;
    return incidents.length > 0 ? (escalatedIncidents / incidents.length) * 100 : 0;
  }

  private calculateDailyIncidents(incidents: IncidentReport[]): { date: string; count: number }[] {
    const dailyCounts: { [key: string]: number } = {};
    
    incidents.forEach(incident => {
      const date = incident.incidentDateTime.toISOString().split('T')[0];
      dailyCounts[date] = (dailyCounts[date] || 0) + 1;
    });

    return Object.entries(dailyCounts).map(([date, count]) => ({ date, count }));
  }

  private calculateWeeklyTrend(incidents: IncidentReport[]): 'increasing' | 'decreasing' | 'stable' {
    // In production, this would calculate actual trend
    return 'stable';
  }

  private calculateMonthlyComparison(incidents: IncidentReport[]): number {
    // In production, this would calculate actual comparison
    return 5; // 5% increase
  }

  private async performMLPrediction(incident: IncidentReport): Promise<any> {
    // In production, this would use actual ML models
    return {
      outcome: 'resolved' as const,
      confidence: 0.85,
      estimatedTime: this.estimateResolutionTime(incident),
      riskFactors: ['High severity', 'Multiple affected persons'],
      recommendedActions: ['Immediate assessment', 'Stakeholder notification'],
      similarIncidents: ['INC202400123', 'INC202400089'],
      preventionOpportunities: ['Enhanced training', 'Process improvement']
    };
  }

  // CQC Compliance Methods
  async setupCQCNotification(incident: IncidentReport): Promise<void> {
    try {
      const notificationDeadline = incident.getCQCNotificationDeadline();
      
      incident.cqcReporting = {
        notificationRequired: true,
        notificationDeadline: notificationDeadline,
        notificationSent: false,
        notificationReference: '',
        cqcReference: '',
        followUpRequired: true,
        followUpActions: [
          'Complete root cause analysis',
          'Implement corrective actions',
          'Monitor effectiveness',
          'Report to CQC within 24 hours'
        ],
        complianceStatus: 'under_review'
      };

      await this.incidentRepository.save(incident);

      // Send notification to compliance team
      await this.notificationService.sendNotification({
        message: 'CQC Notification Required',
        type: 'cqc_notification_required',
        recipients: ['compliance_team', 'quality_manager'],
        data: {
          incidentId: incident.id,
          incidentNumber: incident.incidentNumber,
          deadline: notificationDeadline,
          severity: incident.severity,
          type: incident.incidentType
        }
      });
    } catch (error: unknown) {
      console.error('Error setting up CQC notification:', error);
      throw error;
    }
  }

  async sendCQCNotification(incidentId: string, notificationData: any): Promise<void> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      // Generate CQC notification reference
      const cqcReference = `CQC-${new Date().getFullYear()}-${String(incident.incidentNumber).slice(-6)}`;
      
      incident.cqcReporting.notificationSent = true;
      incident.cqcReporting.notificationReference = notificationData.reference;
      incident.cqcReporting.cqcReference = cqcReference;
      incident.cqcReporting.complianceStatus = 'compliant';

      await this.incidentRepository.save(incident);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'IncidentReport',
        entityType: 'IncidentReport',
        entityId: incidentId,
        action: 'CQC_NOTIFICATION_SENT',
        details: {
          cqcReference: cqcReference,
          notificationReference: notificationData.reference,
          sentBy: notificationData.sentBy
        },
        userId: notificationData.sentBy
      });

    } catch (error: unknown) {
      console.error('Error sending CQC notification:', error);
      throw error;
    }
  }

  async addCorrectiveAction(incidentId: string, actionData: any): Promise<void> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      const actionId = `CA${Date.now()}`;
      const newAction = {
        actionId,
        description: actionData.description,
        priority: actionData.priority || 'medium',
        responsible: actionData.responsible,
        assignedDate: new Date(),
        deadline: new Date(actionData.deadline),
        status: 'pending' as const,
        effectiveness: 0,
        reviewDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
        resourcesRequired: actionData.resourcesRequired || [],
        successCriteria: actionData.successCriteria || '',
        monitoringMethod: actionData.monitoringMethod || 'Regular review'
      };

      incident.correctiveActions.push(newAction);
      await this.incidentRepository.save(incident);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'IncidentReport',
        entityType: 'IncidentReport',
        entityId: incidentId,
        action: 'CORRECTIVE_ACTION_ADDED',
        details: {
          actionId: actionId,
          description: actionData.description,
          responsible: actionData.responsible,
          deadline: actionData.deadline
        },
        userId: actionData.addedBy
      });

    } catch (error: unknown) {
      console.error('Error adding corrective action:', error);
      throw error;
    }
  }

  async updateCorrectiveAction(incidentId: string, actionId: string, updateData: any): Promise<void> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      const actionIndex = incident.correctiveActions.findIndex(a => a.actionId === actionId);
      if (actionIndex === -1) {
        throw new Error('Corrective action not found');
      }

      // Update action
      Object.assign(incident.correctiveActions[actionIndex], updateData);
      
      // Update status if completed
      if (updateData.status === 'completed') {
        incident.correctiveActions[actionIndex].completionDate = new Date();
      }

      // Check if overdue
      if (new Date() > incident.correctiveActions[actionIndex].deadline && 
          incident.correctiveActions[actionIndex].status !== 'completed') {
        incident.correctiveActions[actionIndex].status = 'overdue';
      }

      await this.incidentRepository.save(incident);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'IncidentReport',
        entityType: 'IncidentReport',
        entityId: incidentId,
        action: 'CORRECTIVE_ACTION_UPDATED',
        details: {
          actionId: actionId,
          updates: updateData
        },
        userId: updateData.updatedBy
      });

    } catch (error: unknown) {
      console.error('Error updating corrective action:', error);
      throw error;
    }
  }

  async performQualityReview(incidentId: string, reviewData: any): Promise<void> {
    try {
      const incident = await this.incidentRepository.findOne({
        where: { id: incidentId }
      });

      if (!incident) {
        throw new Error('Incident not found');
      }

      incident.qualityAssurance = {
        reviewCompleted: true,
        reviewDate: new Date(),
        reviewedBy: reviewData.reviewedBy,
        qualityScore: reviewData.qualityScore,
        areasForImprovement: reviewData.areasForImprovement || [],
        bestPractices: reviewData.bestPractices || [],
        trainingNeeds: reviewData.trainingNeeds || [],
        processImprovements: reviewData.processImprovements || []
      };

      await this.incidentRepository.save(incident);

      // Log audit trail
      await this.auditService.logEvent({
        resource: 'IncidentReport',
        entityType: 'IncidentReport',
        entityId: incidentId,
        action: 'QUALITY_REVIEW_COMPLETED',
        details: {
          qualityScore: reviewData.qualityScore,
          reviewedBy: reviewData.reviewedBy
        },
        userId: reviewData.reviewedBy
      });

    } catch (error: unknown) {
      console.error('Error performing quality review:', error);
      throw error;
    }
  }

  async getCQCComplianceReport(): Promise<any> {
    try {
      const incidents = await this.incidentRepository.find();
      
      const cqcReport = {
        totalIncidents: incidents.length,
        cqcNotifiableIncidents: incidents.filter(i => i.requiresCQCNotification()).length,
        notificationsSent: incidents.filter(i => i.cqcReporting.notificationSent).length,
        overdueNotifications: incidents.filter(i => i.isOverdueForCQCNotification()).length,
        complianceRate: 0,
        correctiveActions: {
          total: incidents.reduce((sum, i) => sum + i.correctiveActions.length, 0),
          completed: incidents.reduce((sum, i) => sum + i.getCorrectiveActionStatus().completed, 0),
          overdue: incidents.reduce((sum, i) => sum + i.getCorrectiveActionStatus().overdue, 0)
        },
        qualityReviews: {
          completed: incidents.filter(i => i.qualityAssurance.reviewCompleted).length,
          pending: incidents.filter(i => i.needsQualityReview()).length,
          averageScore: incidents.reduce((sum, i) => sum + i.getQualityScore(), 0) / incidents.length || 0
        },
        trends: this.analyzeCQCTrends(incidents)
      };

      cqcReport.complianceRate = cqcReport.cqcNotifiableIncidents > 0 ? 
        (cqcReport.notificationsSent / cqcReport.cqcNotifiableIncidents) * 100 : 100;

      return cqcReport;
    } catch (error: unknown) {
      console.error('Error getting CQC compliance report:', error);
      throw error;
    }
  }

  private analyzeCQCTrends(incidents: IncidentReport[]): any {
    const now = new Date();
    const lastMonth = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const lastQuarter = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
    
    const monthlyIncidents = incidents.filter(i => i.incidentDateTime >= lastMonth);
    const quarterlyIncidents = incidents.filter(i => i.incidentDateTime >= lastQuarter);
    
    return {
      monthly: {
        total: monthlyIncidents.length,
        cqcNotifiable: monthlyIncidents.filter(i => i.requiresCQCNotification()).length,
        complianceRate: this.calculateComplianceRate(monthlyIncidents)
      },
      quarterly: {
        total: quarterlyIncidents.length,
        cqcNotifiable: quarterlyIncidents.filter(i => i.requiresCQCNotification()).length,
        complianceRate: this.calculateComplianceRate(quarterlyIncidents)
      }
    };
  }

  private calculateComplianceRate(incidents: IncidentReport[]): number {
    const notifiableIncidents = incidents.filter(i => i.requiresCQCNotification());
    if (notifiableIncidents.length === 0) return 100;
    
    const compliantIncidents = notifiableIncidents.filter(i => i.isCQCCompliant());
    return (compliantIncidents.length / notifiableIncidents.length) * 100;
  }
}