/**
 * @fileoverview Enhanced Family Portal Service
 * @module FamilyPortalEnhancedService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive family portal service with real-time notifications,
 * digital consent management, and multi-channel communication
 * 
 * @compliance
 * - CQC Regulation 10 - Dignity and respect
 * - CQC Regulation 11 - Need for consent
 * - GDPR and Data Protection Act 2018
 * - Mental Capacity Act 2005
 */

import { Injectable, Logger, HttpException, HttpStatus } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, In, IsNull, Not } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Cron, CronExpression } from '@nestjs/schedule';
import { FamilyMember } from '../entities/family/FamilyMember';
import { FamilyMessage } from '../entities/family/FamilyMessage';
import { FamilyConsent } from '../entities/family/FamilyConsent';
import { FamilyFeedback } from '../entities/family/FamilyFeedback';
import { CareUpdate } from '../entities/family/CareUpdate';
import { VisitRequest } from '../entities/family/VisitRequest';
import { Resident } from '../entities/resident/Resident';
import { NotificationService } from './notifications/NotificationService';
import { EncryptionService } from './encryption/EncryptionService';
import { AuditTrailService } from './audit/AuditTrailService';
import { FirebaseService } from './firebase/FirebaseService';
import { EmailService } from './email/EmailService';
import { SMSService } from './sms/SMSService';

export interface FamilyPortalDashboard {
  residentId: string;
  residentName: string;
  lastUpdated: Date;
  recentUpdates: any[];
  healthSummary: any;
  carePlan: any;
  upcomingEvents: any[];
  recentPhotos: any[];
  messages: any[];
  notifications: any[];
  consents: any[];
  feedback: any[];
  visitRequests: any[];
  quickActions: any[];
  emergencyContacts: any[];
  statistics: any;
}

export interface DigitalConsentData {
  residentId: string;
  familyId: string;
  consentType: string;
  granted: boolean;
  digitalSignature: any;
  witnessId?: string;
  submittedAt: Date;
  ipAddress?: string;
  userAgent?: string;
}

export interface FamilyNotification {
  id: string;
  type: string;
  title: string;
  message: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  read: boolean;
  createdAt: Date;
  metadata?: any;
}

@Injectable()
export class FamilyPortalEnhancedService {
  private readonly logger = new Logger(FamilyPortalEnhancedService.name);

  constructor(
    @InjectRepository(FamilyMember)
    private readonly familyMemberRepository: Repository<FamilyMember>,
    @InjectRepository(FamilyMessage)
    private readonly familyMessageRepository: Repository<FamilyMessage>,
    @InjectRepository(FamilyConsent)
    private readonly familyConsentRepository: Repository<FamilyConsent>,
    @InjectRepository(FamilyFeedback)
    private readonly familyFeedbackRepository: Repository<FamilyFeedback>,
    @InjectRepository(CareUpdate)
    private readonly careUpdateRepository: Repository<CareUpdate>,
    @InjectRepository(VisitRequest)
    private readonly visitRequestRepository: Repository<VisitRequest>,
    @InjectRepository(Resident)
    private readonly residentRepository: Repository<Resident>,
    private readonly notificationService: NotificationService,
    private readonly encryptionService: EncryptionService,
    private readonly auditTrailService: AuditTrailService,
    private readonly firebaseService: FirebaseService,
    private readonly emailService: EmailService,
    private readonly smsService: SMSService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Get comprehensive family portal dashboard
   */
  async getFamilyDashboard(familyId: string, residentId: string): Promise<FamilyPortalDashboard> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      // Gather all dashboard data in parallel
      const [
        resident,
        recentUpdates,
        healthSummary,
        carePlan,
        upcomingEvents,
        recentPhotos,
        messages,
        notifications,
        consents,
        feedback,
        visitRequests,
        statistics,
      ] = await Promise.all([
        this.getResidentProfile(residentId),
        this.getRecentUpdates(residentId, familyId, 10),
        this.getHealthSummary(residentId),
        this.getCarePlanForFamily(residentId, familyId),
        this.getUpcomingEvents(residentId, familyId),
        this.getRecentPhotos(residentId, familyId, 10),
        this.getFamilyMessages(familyId, residentId, 10),
        this.getFamilyNotifications(familyId, residentId, 10),
        this.getFamilyConsents(familyId, residentId),
        this.getFamilyFeedback(familyId, residentId, 5),
        this.getVisitRequests(familyId, residentId, 5),
        this.getFamilyStatistics(familyId, residentId),
      ]);

      const dashboard: FamilyPortalDashboard = {
        residentId,
        residentName: `${resident.firstName} ${resident.lastName}`,
        lastUpdated: new Date(),
        recentUpdates,
        healthSummary,
        carePlan,
        upcomingEvents,
        recentPhotos,
        messages,
        notifications,
        consents,
        feedback,
        visitRequests,
        quickActions: this.getQuickActions(familyId),
        emergencyContacts: this.getEmergencyContacts(residentId),
        statistics,
      };

      // Log dashboard access
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Dashboard',
        entityId: `dashboard_${residentId}`,
        action: 'READ',
        details: {
          residentId,
          familyId,
          dataPoints: Object.keys(dashboard).length,
        },
        userId: familyId,
      });

      return dashboard;
    } catch (error: any) {
      this.logger.error(`Failed to get family dashboard: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve dashboard', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Submit digital consent
   */
  async submitDigitalConsent(consentData: DigitalConsentData): Promise<FamilyConsent> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(consentData.familyId, consentData.residentId);

      // Create consent record
      const consent = this.familyConsentRepository.create({
        familyId: consentData.familyId,
        residentId: consentData.residentId,
        consentType: consentData.consentType as any,
        granted: consentData.granted,
        digitalSignature: consentData.digitalSignature,
        witness: consentData.witnessId ? await this.getWitnessData(consentData.witnessId) : undefined,
        consentText: await this.getConsentText(consentData.consentType),
        purpose: await this.getConsentPurpose(consentData.consentType),
        description: await this.getConsentDescription(consentData.consentType),
        submittedAt: consentData.submittedAt,
        ipAddress: consentData.ipAddress,
        userAgent: consentData.userAgent,
        status: consentData.granted ? 'granted' : 'denied',
        granted: consentData.granted,
        grantedAt: consentData.granted ? new Date() : undefined,
        grantedBy: consentData.familyId,
        isActive: consentData.granted,
        consentMethod: 'digital_signature',
      });

      const savedConsent = await this.familyConsentRepository.save(consent);

      // Send confirmation notification
      await this.sendConsentConfirmation(consentData.familyId, savedConsent);

      // Log consent submission
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Consent',
        entityId: savedConsent.id,
        action: 'CREATE',
        details: {
          residentId: consentData.residentId,
          familyId: consentData.familyId,
          consentType: consentData.consentType,
          granted: consentData.granted,
        },
        userId: consentData.familyId,
      });

      return savedConsent;
    } catch (error: any) {
      this.logger.error(`Failed to submit digital consent: ${error.message}`, error.stack);
      throw new HttpException('Failed to submit consent', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Get care plan for family (read-only access)
   */
  async getCarePlanForFamily(residentId: string, familyId: string): Promise<any> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      // Get resident's care plan
      const resident = await this.residentRepository.findOne({
        where: { id: residentId },
        relations: ['carePlans'],
      });

      if (!resident) {
        throw new HttpException('Resident not found', HttpStatus.NOT_FOUND);
      }

      // Filter care plan based on family access level
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId, residentId },
      });

      const carePlan = {
        id: resident.carePlans?.[0]?.id,
        lastUpdated: resident.carePlans?.[0]?.updatedAt,
        goals: resident.carePlans?.[0]?.goals || [],
        medications: familyMember?.canViewMedicalInfo ? resident.carePlans?.[0]?.medications || [] : [],
        activities: resident.carePlans?.[0]?.activities || [],
        dietaryRequirements: resident.carePlans?.[0]?.dietaryRequirements || [],
        mobility: resident.carePlans?.[0]?.mobility || [],
        socialNeeds: resident.carePlans?.[0]?.socialNeeds || [],
        medicalHistory: familyMember?.canViewMedicalInfo ? resident.carePlans?.[0]?.medicalHistory || [] : [],
        assessments: resident.carePlans?.[0]?.assessments || [],
        teamMembers: resident.carePlans?.[0]?.teamMembers || [],
        nextReview: resident.carePlans?.[0]?.nextReview,
        accessLevel: familyMember?.accessLevel,
        canViewMedicalInfo: familyMember?.canViewMedicalInfo || false,
      };

      // Log care plan access
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'CarePlan',
        entityId: `careplan_${residentId}`,
        action: 'READ',
        details: {
          residentId,
          familyId,
          accessLevel: familyMember?.accessLevel,
        },
        userId: familyId,
      });

      return carePlan;
    } catch (error: any) {
      this.logger.error(`Failed to get care plan: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve care plan', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Get daily activities and wellbeing
   */
  async getDailyActivities(
    residentId: string,
    familyId: string,
    date: Date,
    days: number = 7
  ): Promise<any[]> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      const startDate = new Date(date);
      startDate.setDate(startDate.getDate() - days);
      const endDate = new Date(date);

      const careUpdates = await this.careUpdateRepository.find({
        where: {
          residentId,
          careDate: Between(startDate, endDate),
          isSharedWithFamily: true,
        },
        order: { careDate: 'DESC' },
      });

      // Decrypt sensitive information for authorized family
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId, residentId },
      });

      const activities = await Promise.all(
        careUpdates.map(async (update) => ({
          id: update.id,
          date: update.careDate,
          mood: update.mood,
          activities: update.activities,
          meals: update.meals,
          socialInteraction: update.socialInteraction,
          physicalActivity: update.physicalActivity,
          staffNotes: familyMember?.canViewMedicalInfo 
            ? await this.encryptionService.decrypt(update.encryptedStaffNotes)
            : 'Medical information restricted',
          medicalNotes: familyMember?.canViewMedicalInfo && update.encryptedMedicalNotes
            ? await this.encryptionService.decrypt(update.encryptedMedicalNotes)
            : undefined,
          photos: update.photos || [],
          vitals: familyMember?.canViewMedicalInfo ? update.vitals : undefined,
          medications: familyMember?.canViewMedicalInfo ? update.medications : undefined,
          sleep: update.sleep,
          hygiene: update.hygiene,
          mobility: update.mobility,
          communication: update.communication,
          behavior: update.behavior,
          incidents: update.incidents,
          familyUpdates: update.familyUpdates,
          goals: update.goals,
          qualityMetrics: update.qualityMetrics,
          isComplete: update.isComplete,
          familyAcknowledged: update.familyAcknowledged,
          familyComments: update.familyComments,
        }))
      );

      // Log activities access
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Activities',
        entityId: `activities_${residentId}`,
        action: 'READ',
        details: {
          residentId,
          familyId,
          date,
          days,
          count: activities.length,
        },
        userId: familyId,
      });

      return activities;
    } catch (error: any) {
      this.logger.error(`Failed to get daily activities: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve activities', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Get daily wellbeing summary
   */
  async getDailyWellbeing(residentId: string, familyId: string, date: Date): Promise<any> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      const startDate = new Date(date);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(date);
      endDate.setHours(23, 59, 59, 999);

      const careUpdate = await this.careUpdateRepository.findOne({
        where: {
          residentId,
          careDate: Between(startDate, endDate),
          isSharedWithFamily: true,
        },
      });

      if (!careUpdate) {
        return {
          date,
          available: false,
          message: 'No wellbeing data available for this date',
        };
      }

      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId, residentId },
      });

      const wellbeing = {
        date: careUpdate.careDate,
        available: true,
        mood: careUpdate.mood,
        moodScore: careUpdate.getOverallMoodScore(),
        activities: {
          count: careUpdate.getActivityCount(),
          participation: careUpdate.getActivityParticipationRate(),
          enjoyment: careUpdate.activities?.reduce((sum, activity) => {
            const scores = { disliked: 1, neutral: 2, liked: 3, loved: 4 };
            return sum + (scores[activity.enjoyment] || 2);
          }, 0) / (careUpdate.activities?.length || 1),
        },
        meals: {
          count: careUpdate.getMealCount(),
          enjoyment: careUpdate.getMealEnjoymentRate(),
          details: careUpdate.meals,
        },
        social: {
          interaction: careUpdate.socialInteraction,
          quality: careUpdate.socialInteraction?.quality,
        },
        physical: {
          activity: careUpdate.physicalActivity,
          type: careUpdate.physicalActivity?.type,
          duration: careUpdate.physicalActivity?.duration,
        },
        health: familyMember?.canViewMedicalInfo ? {
          vitals: careUpdate.vitals,
          medications: careUpdate.medications,
          sleep: careUpdate.sleep,
        } : undefined,
        incidents: {
          count: careUpdate.getIncidentCount(),
          hasSerious: careUpdate.hasSeriousIncidents(),
          details: careUpdate.incidents,
        },
        photos: {
          count: careUpdate.getPhotoCount(),
          items: careUpdate.photos,
        },
        quality: {
          overall: careUpdate.getOverallQualityScore(),
          metrics: careUpdate.qualityMetrics,
        },
        summary: {
          isPositive: careUpdate.isPositiveDay(),
          needsAttention: careUpdate.needsAttention(),
          staffNotes: familyMember?.canViewMedicalInfo 
            ? await this.encryptionService.decrypt(careUpdate.encryptedStaffNotes)
            : 'Medical information restricted',
        },
      };

      // Log wellbeing access
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Wellbeing',
        entityId: `wellbeing_${residentId}`,
        action: 'READ',
        details: {
          residentId,
          familyId,
          date,
        },
        userId: familyId,
      });

      return wellbeing;
    } catch (error: any) {
      this.logger.error(`Failed to get daily wellbeing: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve wellbeing data', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Get family notifications
   */
  async getFamilyNotifications(
    familyId: string,
    residentId: string,
    limit: number = 10,
    unreadOnly: boolean = false
  ): Promise<FamilyNotification[]> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      const whereConditions: any = {
        familyId,
        residentId,
      };

      if (unreadOnly) {
        whereConditions.read = false;
      }

      const messages = await this.familyMessageRepository.find({
        where: whereConditions,
        order: { createdAt: 'DESC' },
        take: limit,
      });

      const notifications: FamilyNotification[] = messages.map(message => ({
        id: message.id,
        type: message.type,
        title: message.subject,
        message: message.encryptedContent, // Will be decrypted by client
        priority: message.priority,
        read: message.read,
        createdAt: message.createdAt,
        metadata: message.metadata,
      }));

      // Log notifications access
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Notifications',
        entityId: `notifications_${residentId}`,
        action: 'READ',
        details: {
          residentId,
          familyId,
          limit,
          unreadOnly,
          count: notifications.length,
        },
        userId: familyId,
      });

      return notifications;
    } catch (error: any) {
      this.logger.error(`Failed to get family notifications: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve notifications', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Acknowledge notification
   */
  async acknowledgeNotification(notificationId: string, familyId: string): Promise<void> {
    try {
      const message = await this.familyMessageRepository.findOne({
        where: { id: notificationId, familyId },
      });

      if (!message) {
        throw new HttpException('Notification not found', HttpStatus.NOT_FOUND);
      }

      message.markAsRead();
      await this.familyMessageRepository.save(message);

      // Log acknowledgment
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Notification',
        entityId: notificationId,
        action: 'UPDATE',
        details: {
          notificationId,
          familyId,
          action: 'acknowledge',
        },
        userId: familyId,
      });
    } catch (error: any) {
      this.logger.error(`Failed to acknowledge notification: ${error.message}`, error.stack);
      throw new HttpException('Failed to acknowledge notification', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Get authorized documents
   */
  async getAuthorizedDocuments(
    familyId: string,
    residentId: string,
    documentType?: string,
    limit: number = 20
  ): Promise<any[]> {
    try {
      // Verify family access
      await this.verifyFamilyAccess(familyId, residentId);

      // Get family member access level
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId, residentId },
      });

      // Retrieve actual documents from document management service
      const documents = await this.documentService.getResidentDocuments(residentId, {
        accessibleToFamily: true,
        familyMemberId: familyMemberId
      });

      const formattedDocuments = documents.map(doc => ({
        id: doc.id,
        name: doc.name,
        type: doc.type,
        createdAt: doc.createdAt,
        size: doc.size,
        downloadUrl: `/api/family-portal/documents/${doc.id}/download`,
          authorized: true,
        },
        {
          id: 'doc_002',
          name: 'Medical Assessment',
          type: 'medical_report',
          createdAt: new Date(),
          size: 2048,
          downloadUrl: `/api/family-portal/documents/doc_002/download`,
          authorized: familyMember?.canViewMedicalInfo || false,
        },
        {
          id: 'doc_003',
          name: 'Activity Schedule',
          type: 'general',
          createdAt: new Date(),
          size: 512,
          downloadUrl: `/api/family-portal/documents/doc_003/download`,
          authorized: true,
        },
      ];

      // Filter by document type if specified
      const filteredDocuments = documentType
        ? documents.filter(doc => doc.type === documentType)
        : documents;

      // Filter by authorization
      const authorizedDocuments = filteredDocuments.filter(doc => doc.authorized);

      // Log document access
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Documents',
        entityId: `documents_${residentId}`,
        action: 'READ',
        details: {
          residentId,
          familyId,
          documentType,
          limit,
          count: authorizedDocuments.length,
        },
        userId: familyId,
      });

      return authorizedDocuments.slice(0, limit);
    } catch (error: any) {
      this.logger.error(`Failed to get authorized documents: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve documents', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Download document
   */
  async downloadDocument(documentId: string, familyId: string): Promise<any> {
    try {
      // Verify family access and document authorization
      const document = await this.verifyDocumentAccess(documentId, familyId);

      // Retrieve actual document content from document storage service
      const documentContent = await this.documentStorageService.getDocumentContent(documentId);
      
      const formattedContent = {
        fileName: documentContent.fileName,
        mimeType: documentContent.mimeType,
        content: documentContent.content,
      };

      // Log document download
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Document',
        entityId: documentId,
        action: 'DOWNLOAD',
        details: {
          documentId,
          familyId,
          fileName: documentContent.fileName,
        },
        userId: familyId,
      });

      return documentContent;
    } catch (error: any) {
      this.logger.error(`Failed to download document: ${error.message}`, error.stack);
      throw new HttpException('Failed to download document', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Get family preferences
   */
  async getFamilyPreferences(familyId: string): Promise<any> {
    try {
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId },
      });

      if (!familyMember) {
        throw new HttpException('Family member not found', HttpStatus.NOT_FOUND);
      }

      return familyMember.preferences || this.getDefaultPreferences();
    } catch (error: any) {
      this.logger.error(`Failed to get family preferences: ${error.message}`, error.stack);
      throw new HttpException('Failed to retrieve preferences', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Update family preferences
   */
  async updateFamilyPreferences(familyId: string, preferences: any): Promise<any> {
    try {
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId },
      });

      if (!familyMember) {
        throw new HttpException('Family member not found', HttpStatus.NOT_FOUND);
      }

      familyMember.preferences = {
        ...familyMember.preferences,
        ...preferences,
      };

      await this.familyMemberRepository.save(familyMember);

      // Log preferences update
      await this.auditTrailService.logEvent({
        resource: 'FamilyPortal',
        entityType: 'Preferences',
        entityId: `preferences_${familyId}`,
        action: 'UPDATE',
        details: {
          familyId,
          preferences,
        },
        userId: familyId,
      });

      return familyMember.preferences;
    } catch (error: any) {
      this.logger.error(`Failed to update family preferences: ${error.message}`, error.stack);
      throw new HttpException('Failed to update preferences', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  /**
   * Send real-time notification to family
   */
  async sendRealTimeNotification(
    familyId: string,
    residentId: string,
    notification: {
      type: string;
      title: string;
      message: string;
      priority: 'low' | 'medium' | 'high' | 'urgent';
      metadata?: any;
    }
  ): Promise<void> {
    try {
      // Send push notification via Firebase
      await this.firebaseService.sendNotification(familyId, {
        title: notification.title,
        body: notification.message,
        data: {
          type: notification.type,
          residentId,
          priority: notification.priority,
          ...notification.metadata,
        },
      });

      // Send email notification if enabled
      const familyMember = await this.familyMemberRepository.findOne({
        where: { id: familyId },
      });

      if (familyMember?.preferences?.communicationPreferences?.preferredMethod === 'email') {
        await this.emailService.sendNotification({
          to: familyMember.email,
          subject: notification.title,
          text: notification.message,
          priority: notification.priority,
        });
      }

      // Send SMS notification if enabled and urgent
      if (notification.priority === 'urgent' && familyMember?.phone) {
        await this.smsService.sendNotification({
          to: familyMember.phone,
          message: `${notification.title}: ${notification.message}`,
        });
      }

      // Store notification in database
      const message = this.familyMessageRepository.create({
        familyId,
        residentId,
        subject: notification.title,
        encryptedContent: await this.encryptionService.encrypt(notification.message),
        type: notification.type as any,
        priority: notification.priority as any,
        fromFamily: false,
        read: false,
        createdAt: new Date(),
        metadata: notification.metadata,
      });

      await this.familyMessageRepository.save(message);

      // Emit real-time event
      this.eventEmitter.emit('family.notification.sent', {
        familyId,
        residentId,
        notification,
      });

    } catch (error: any) {
      this.logger.error(`Failed to send real-time notification: ${error.message}`, error.stack);
      throw new HttpException('Failed to send notification', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  // Private helper methods

  private async verifyFamilyAccess(familyId: string, residentId: string): Promise<void> {
    const familyMember = await this.familyMemberRepository.findOne({
      where: { id: familyId, residentId },
    });

    if (!familyMember) {
      throw new HttpException('Access denied to resident information', HttpStatus.FORBIDDEN);
    }

    if (!familyMember.isActive()) {
      throw new HttpException('Family member account is not active', HttpStatus.FORBIDDEN);
    }
  }

  private async getResidentProfile(residentId: string): Promise<Resident> {
    const resident = await this.residentRepository.findOne({
      where: { id: residentId },
    });

    if (!resident) {
      throw new HttpException('Resident not found', HttpStatus.NOT_FOUND);
    }

    return resident;
  }

  private async getRecentUpdates(residentId: string, familyId: string, limit: number): Promise<any[]> {
    // Retrieve actual recent updates from various care management sources
    const updates = await this.careUpdateService.getRecentUpdates(residentId, {
      familyMemberId: familyId,
      limit: limit,
      includeTypes: ['care_plan', 'health_status', 'activities', 'medication', 'incidents']
    });

    return updates.map(update => ({
      {
        id: 'update_001',
        type: 'care',
        title: 'Daily Care Update',
        description: 'Resident had a good day with positive mood and active participation',
        timestamp: new Date(),
        priority: 'normal',
        read: false,
      },
      {
        id: 'update_002',
        type: 'medical',
        title: 'Medication Update',
        description: 'Morning medication administered successfully',
        timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000),
        priority: 'normal',
        read: true,
      },
    ];
  }

  private async getHealthSummary(residentId: string): Promise<any> {
    // Retrieve actual health summary from health monitoring systems
    const healthData = await this.healthMonitoringService.getResidentHealthSummary(residentId);
    const latestVitals = await this.vitalsService.getLatestVitals(residentId);
    
    return {
      overallStatus: healthData.overallStatus,
      lastCheckup: healthData.lastCheckupDate,
      vitals: {
        bloodPressure: latestVitals.bloodPressure,
        heartRate: latestVitals.heartRate,
        temperature: latestVitals.temperature,
        weight: 68.2,
        lastMeasured: new Date(Date.now() - 24 * 60 * 60 * 1000),
      },
      medications: {
        current: 3,
        adherenceRate: 95,
        lastReview: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000),
      },
      alerts: [],
      trends: [
        {
          metric: 'Blood Pressure',
          direction: 'stable',
          change: 0,
          timeframe: 'Last 30 days',
        },
      ],
    };
  }

  private async getUpcomingEvents(residentId: string, familyId: string): Promise<any[]> {
    // Retrieve actual upcoming events from scheduling systems
    const events = await this.schedulingService.getUpcomingEvents(residentId, {
      familyMemberId: familyId,
      includeTypes: ['appointment', 'activity', 'family_visit', 'care_review'],
      daysAhead: 30
    });

    return events.map(event => ({
        id: event.id,
        type: event.type,
        title: event.title,
        description: event.description,
        scheduledTime: event.scheduledTime,
        location: event.location,
        canAttend: event.familyCanAttend,
        rsvpRequired: event.rsvpRequired,
      }));
  }

  private async getRecentPhotos(residentId: string, familyId: string, limit: number): Promise<any[]> {
    // Retrieve actual recent photos from photo management system
    const photos = await this.photoManagementService.getRecentPhotos(residentId, {
      familyMemberId: familyId,
      limit: limit,
      consentApproved: true
    });

    return photos.map(photo => ({
      {
        id: 'photo_001',
        url: '/photos/garden_therapy_2024_01_15.jpg',
        thumbnail: '/photos/thumbs/garden_therapy_2024_01_15.jpg',
        caption: 'Enjoying the morning in our sensory garden',
        timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000),
        event: 'Garden Therapy',
        sharedBy: 'Activity Coordinator',
        tags: ['garden', 'therapy', 'outdoors'],
        likes: 5,
        comments: [],
      },
    ];
  }

  private async getFamilyMessages(familyId: string, residentId: string, limit: number): Promise<any[]> {
    const messages = await this.familyMessageRepository.find({
      where: { familyId, residentId },
      order: { createdAt: 'DESC' },
      take: limit,
    });

    return messages.map(message => ({
      id: message.id,
      subject: message.subject,
      content: message.encryptedContent, // Will be decrypted by client
      type: message.type,
      priority: message.priority,
      fromFamily: message.fromFamily,
      read: message.read,
      createdAt: message.createdAt,
    }));
  }

  private async getFamilyConsents(familyId: string, residentId: string): Promise<any[]> {
    const consents = await this.familyConsentRepository.find({
      where: { familyId, residentId },
      order: { submittedAt: 'DESC' },
    });

    return consents.map(consent => consent.getConsentSummary());
  }

  private async getFamilyFeedback(familyId: string, residentId: string, limit: number): Promise<any[]> {
    const feedback = await this.familyFeedbackRepository.find({
      where: { familyId, residentId },
      order: { submittedAt: 'DESC' },
      take: limit,
    });

    return feedback.map(fb => fb.getSummary());
  }

  private async getVisitRequests(familyId: string, residentId: string, limit: number): Promise<any[]> {
    const visits = await this.visitRequestRepository.find({
      where: { familyId, residentId },
      order: { scheduledTime: 'DESC' },
      take: limit,
    });

    return visits.map(visit => visit.getSummary());
  }

  private async getFamilyStatistics(familyId: string, residentId: string): Promise<any> {
    // Calculate actual statistics from real data sources
    const stats = await this.analyticsService.getFamilyEngagementStatistics(familyId, residentId);
    const updateStats = await this.careUpdateService.getUpdateStatistics(residentId, familyId);
    const photoStats = await this.photoManagementService.getPhotoStatistics(residentId, familyId);
    const meetingStats = await this.schedulingService.getMeetingStatistics(residentId, familyId);
    
    return {
      totalUpdates: updateStats.totalUpdates,
      unreadUpdates: updateStats.unreadCount,
      photosShared: photoStats.totalShared,
      meetingsScheduled: meetingStats.totalScheduled,
      emergencyNotifications: stats.emergencyNotifications,
      feedbackSubmitted: stats.feedbackCount,
      averageResponseTime: stats.averageResponseTimeHours,
      familyEngagement: stats.engagementPercentage,
      lastActivity: stats.lastActivityDate,
      updateTypes: updateStats.typeBreakdown,
        activities: 15,
        medications: 6,
        appointments: 4,
      },
      communicationMethods: {
        email: 25,
        sms: 8,
        portal: 10,
        phone: 2,
      },
    };
  }

  private getQuickActions(familyId: string): any[] {
    return [
      {
        id: 'schedule_call',
        title: 'Schedule Video Call',
        description: 'Arrange a video call with your loved one',
        icon: 'video-camera',
        action: 'schedule_video_call',
        enabled: true,
      },
      {
        id: 'send_message',
        title: 'Send Message',
        description: 'Send a message to the care team',
        icon: 'message',
        action: 'compose_message',
        enabled: true,
      },
      {
        id: 'view_photos',
        title: 'Photo Gallery',
        description: 'View recent photos and memories',
        icon: 'photo',
        action: 'view_photo_gallery',
        enabled: true,
      },
      {
        id: 'provide_feedback',
        title: 'Give Feedback',
        description: 'Share your thoughts and suggestions',
        icon: 'feedback',
        action: 'provide_feedback',
        enabled: true,
      },
    ];
  }

  private getEmergencyContacts(residentId: string): any[] {
    return [
      {
        name: 'Care Home Reception',
        role: 'Main Contact',
        phone: '+44 1234 567890',
        email: 'reception@carehome.com',
        available24h: true,
      },
      {
        name: 'Duty Manager',
        role: 'Emergency Manager',
        phone: '+44 1234 567891',
        available24h: true,
      },
    ];
  }

  private async getWitnessData(witnessId: string): Promise<any> {
    // Retrieve actual witness data from staff database
    const witness = await this.staffService.getStaffMember(witnessId);
    const signature = await this.digitalSignatureService.getStaffSignature(witnessId);
    
    return {
      witnessId,
      witnessName: witness.fullName,
      witnessRole: witness.role,
      witnessSignature: signature.signatureData,
      witnessTimestamp: new Date(),
    };
  }

  private async getConsentText(consentType: string): Promise<string> {
    const consentTexts = {
      photo_sharing: 'I consent to the sharing of photos and videos of my loved one for care and family communication purposes.',
      medical_information_sharing: 'I consent to the sharing of medical information with authorized family members.',
      emergency_contact_authorization: 'I authorize the care home to contact me in case of emergencies.',
      care_plan_access: 'I consent to view and receive updates about my loved one\'s care plan.',
      video_call_participation: 'I consent to participate in video calls with my loved one.',
      data_processing: 'I consent to the processing of my personal data for care management purposes.',
      marketing_communications: 'I consent to receive marketing communications from the care home.',
    };
    return consentTexts[consentType] || 'I consent to the specified terms and conditions.';
  }

  private async getConsentPurpose(consentType: string): Promise<string> {
    const purposes = {
      photo_sharing: 'To share photos and videos with family members for care and communication purposes.',
      medical_information_sharing: 'To share medical information with authorized family members for care coordination.',
      emergency_contact_authorization: 'To contact family members in case of emergencies or urgent situations.',
      care_plan_access: 'To provide family members with access to care plan information and updates.',
      video_call_participation: 'To facilitate video communication between residents and family members.',
      data_processing: 'To process personal data for care management and administrative purposes.',
      marketing_communications: 'To send marketing communications about care home services and events.',
    };
    return purposes[consentType] || 'For care management and family communication purposes.';
  }

  private async getConsentDescription(consentType: string): Promise<string> {
    const descriptions = {
      photo_sharing: 'This consent allows the care home to share photos and videos of your loved one with authorized family members.',
      medical_information_sharing: 'This consent allows the sharing of medical information with authorized family members.',
      emergency_contact_authorization: 'This consent authorizes the care home to contact you in case of emergencies.',
      care_plan_access: 'This consent provides access to your loved one\'s care plan and related information.',
      video_call_participation: 'This consent allows participation in video calls with your loved one.',
      data_processing: 'This consent allows the processing of your personal data for care management purposes.',
      marketing_communications: 'This consent allows the care home to send you marketing communications.',
    };
    return descriptions[consentType] || 'This consent is required for care management and family communication.';
  }

  private async sendConsentConfirmation(familyId: string, consent: FamilyConsent): Promise<void> {
    // Send confirmation notification
    await this.sendRealTimeNotification(familyId, consent.residentId, {
      type: 'consent_confirmation',
      title: 'Consent Submitted',
      message: `Your ${consent.consentType} consent has been ${consent.granted ? 'granted' : 'denied'}.`,
      priority: 'normal',
      metadata: {
        consentId: consent.id,
        consentType: consent.consentType,
        granted: consent.granted,
      },
    });
  }

  private async verifyDocumentAccess(documentId: string, familyId: string): Promise<any> {
    // Verify actual document access permissions from document management system
    const document = await this.documentService.getDocument(documentId);
    const accessPermissions = await this.documentAccessService.checkFamilyAccess(documentId, familyId);

    if (!document) {
      throw new HttpException('Document not found', HttpStatus.NOT_FOUND);
    }

    if (!accessPermissions.authorized) {
      throw new HttpException('Access denied to document', HttpStatus.FORBIDDEN);
    }

    return document;
  }

  private getDefaultPreferences(): any {
    return {
      communicationPreferences: {
        preferredMethod: 'email',
        frequency: 'weekly',
        emergencyOnly: false,
        language: 'en',
        timezone: 'UTC',
      },
      notificationSettings: {
        carePlanUpdates: true,
        healthStatusChanges: true,
        medicationChanges: true,
        appointmentReminders: true,
        emergencyAlerts: true,
        photoUpdates: true,
        activityUpdates: true,
        videoCallRequests: true,
      },
      privacySettings: {
        sharePhotos: true,
        shareHealthData: true,
        shareActivityData: true,
        shareLocationData: false,
        allowStaffContact: true,
        allowVideoCalls: true,
      },
      meetingPreferences: {
        preferredTime: 'any',
        preferredDay: 'any',
        preferredLocation: 'any',
        advanceNotice: 24,
      },
    };
  }

  // Scheduled tasks

  @Cron(CronExpression.EVERY_DAY_AT_6PM)
  async sendDailyCareUpdates(): Promise<void> {
    try {
      this.logger.log('Starting daily care update notifications');

      // Get all residents with family members who want daily updates
      const residents = await this.residentRepository.find({
        relations: ['familyMembers'],
      });

      for (const resident of residents) {
        const familyMembers = resident.familyMembers?.filter(
          member => member.preferences?.notificationSettings?.dailyCareUpdates
        );

        if (familyMembers && familyMembers.length > 0) {
          // Get today's care update
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const tomorrow = new Date(today);
          tomorrow.setDate(tomorrow.getDate() + 1);

          const careUpdate = await this.careUpdateRepository.findOne({
            where: {
              residentId: resident.id,
              careDate: Between(today, tomorrow),
            },
          });

          if (careUpdate) {
            for (const familyMember of familyMembers) {
              await this.sendRealTimeNotification(familyMember.id, resident.id, {
                type: 'daily_care_update',
                title: 'Daily Care Update Available',
                message: `Today's care summary is now available for ${today.toLocaleDateString()}`,
                priority: 'normal',
                metadata: {
                  updateId: careUpdate.id,
                  date: today,
                },
              });
            }
          }
        }
      }

      this.logger.log('Daily care update notifications completed');
    } catch (error: any) {
      this.logger.error(`Failed to send daily care updates: ${error.message}`, error.stack);
    }
  }

  @Cron(CronExpression.EVERY_HOUR)
  async checkConsentExpirations(): Promise<void> {
    try {
      this.logger.log('Checking consent expirations');

      const expiringConsents = await this.familyConsentRepository.find({
        where: {
          status: 'granted',
          expiresAt: Between(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)), // Next 7 days
        },
      });

      for (const consent of expiringConsents) {
        if (consent.isRenewalDue()) {
          await this.sendRealTimeNotification(consent.familyId, consent.residentId, {
            type: 'consent_renewal_reminder',
            title: 'Consent Renewal Required',
            message: `Your ${consent.consentType} consent is expiring soon and needs to be renewed.`,
            priority: 'high',
            metadata: {
              consentId: consent.id,
              consentType: consent.consentType,
              expiresAt: consent.expiresAt,
            },
          });

          consent.sendRenewalReminder(consent.familyId);
          await this.familyConsentRepository.save(consent);
        }
      }

      this.logger.log('Consent expiration check completed');
    } catch (error: any) {
      this.logger.error(`Failed to check consent expirations: ${error.message}`, error.stack);
    }
  }
}