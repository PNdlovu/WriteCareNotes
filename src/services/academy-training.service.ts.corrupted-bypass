import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { AuditTrailService } from './audit/AuditTrailService';
import { TrainingCourse } from '../entities/training/TrainingCourse';
import { TrainingEnrollment } from '../entities/training/TrainingEnrollment';
import { TrainingSession } from '../entities/training/TrainingSession';
import { TrainingCertificate } from '../entities/training/TrainingCertificate';
import { TrainingProgress } from '../entities/training/TrainingProgress';
import { TrainingAnalytics } from '../entities/training/TrainingAnalytics';


@Injectable()
export class AcademyTrainingService {
  constructor(
    @InjectRepository(TrainingCourse)
    private courseRepository: Repository<TrainingCourse>,
    @InjectRepository(TrainingEnrollment)
    private enrollmentRepository: Repository<TrainingEnrollment>,
    @InjectRepository(TrainingSession)
    private sessionRepository: Repository<TrainingSession>,
    @InjectRepository(TrainingCertificate)
    private certificateRepository: Repository<TrainingCertificate>,
    @InjectRepository(TrainingProgress)
    private progressRepository: Repository<TrainingProgress>,
    @InjectRepository(TrainingAnalytics)
    private analyticsRepository: Repository<TrainingAnalytics>,
    private eventEmitter: EventEmitter2,
    private auditService: AuditTrailService,
  ) {}

  /**
   * Create a new training course
   */
  async createCourse(courseData: Omit<TrainingCourse, 'id' | 'createdAt' | 'updatedAt'>): Promise<TrainingCourse> {
    try {
      const course: TrainingCourse = {
        id: `course_${Date.now()}`,
        ...courseData,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.courseRepository.save(course);

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Course',
        entityId: course.id,
        action: 'CREATE',
        details: {
          courseTitle: course.title,
          category: course.category,
          level: course.level,
          duration: course.duration,
          credits: course.credits,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('academy.course.created', {
        courseId: course.id,
        courseTitle: course.title,
        category: course.category,
        level: course.level,
        timestamp: new Date(),
      });

      return course;
    } catch (error) {
      console.error('Error creating course:', error);
      throw new Error('Failed to create course');
    }
  }

  /**
   * Enroll a user in a course
   */
  async enrollUser(courseId: string, userId: string): Promise<TrainingEnrollment> {
    try {
      // Check if user is already enrolled
      const existingEnrollment = await this.enrollmentRepository.findOne({
        where: { courseId, userId },
      });

      if (existingEnrollment) {
        throw new Error('User is already enrolled in this course');
      }

      const enrollment: TrainingEnrollment = {
        id: `enrollment_${Date.now()}`,
        courseId,
        userId,
        enrolledAt: new Date(),
        status: 'enrolled',
        progress: 0,
        timeSpent: 0,
        attempts: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.enrollmentRepository.save(enrollment);

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Enrollment',
        entityId: enrollment.id,
        action: 'CREATE',
        details: {
          courseId,
          userId,
          enrolledAt: enrollment.enrolledAt,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('academy.enrollment.created', {
        enrollmentId: enrollment.id,
        courseId,
        userId,
        timestamp: new Date(),
      });

      return enrollment;
    } catch (error) {
      console.error('Error enrolling user:', error);
      throw new Error('Failed to enroll user');
    }
  }

  /**
   * Start a training session
   */
  async startTrainingSession(sessionData: Omit<TrainingSession, 'id' | 'createdAt' | 'updatedAt'>): Promise<TrainingSession> {
    try {
      const session: TrainingSession = {
        id: `session_${Date.now()}`,
        ...sessionData,
        status: 'scheduled',
        participants: [],
        attendance: [],
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.sessionRepository.save(session);

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Session',
        entityId: session.id,
        action: 'CREATE',
        details: {
          courseId: session.courseId,
          instructorId: session.instructorId,
          title: session.title,
          scheduledDate: session.scheduledDate,
          sessionType: session.sessionType,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('academy.session.created', {
        sessionId: session.id,
        courseId: session.courseId,
        instructorId: session.instructorId,
        scheduledDate: session.scheduledDate,
        timestamp: new Date(),
      });

      return session;
    } catch (error) {
      console.error('Error starting training session:', error);
      throw new Error('Failed to start training session');
    }
  }

  /**
   * Update course progress
   */
  async updateProgress(
    enrollmentId: string,
    contentId: string,
    progress: number,
    timeSpent: number,
  ): Promise<boolean> {
    try {
      const enrollment = await this.enrollmentRepository.findOne({ where: { id: enrollmentId } });
      if (!enrollment) {
        throw new Error('Enrollment not found');
      }

      const updateData: Partial<TrainingEnrollment> = {
        progress,
        timeSpent: enrollment.timeSpent + timeSpent,
        currentContentId: contentId,
        lastAccessedAt: new Date(),
        updatedAt: new Date(),
      };

      if (progress >= 100) {
        updateData.status = 'completed';
        updateData.completedAt = new Date();
      } else if (enrollment.status === 'enrolled') {
        updateData.status = 'in_progress';
        updateData.startedAt = new Date();
      }

      await this.enrollmentRepository.update(enrollmentId, updateData);

      // Update progress record
      await this.updateProgressRecord(enrollment.userId, enrollment.courseId, contentId, progress, timeSpent);

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Progress',
        entityId: enrollmentId,
        action: 'UPDATE',
        details: {
          contentId,
          progress,
          timeSpent,
          status: updateData.status,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('academy.progress.updated', {
        enrollmentId,
        contentId,
        progress,
        timeSpent,
        status: updateData.status,
        timestamp: new Date(),
      });

      return true;
    } catch (error) {
      console.error('Error updating progress:', error);
      return false;
    }
  }

  /**
   * Submit assessment
   */
  async submitAssessment(
    enrollmentId: string,
    assessmentId: string,
    answers: Record<string, any>,
    timeSpent: number,
  ): Promise<{ score: number; passed: boolean; feedback: string }> {
    try {
      const enrollment = await this.enrollmentRepository.findOne({ where: { id: enrollmentId } });
      if (!enrollment) {
        throw new Error('Enrollment not found');
      }

      const course = await this.courseRepository.findOne({ where: { id: enrollment.courseId } });
      if (!course) {
        throw new Error('Course not found');
      }

      const assessment = course.assessments.find(a => a.id === assessmentId);
      if (!assessment) {
        throw new Error('Assessment not found');
      }

      // Calculate score
      const score = this.calculateAssessmentScore(assessment, answers);
      const passed = score >= assessment.passingScore;

      // Update enrollment
      const updateData: Partial<TrainingEnrollment> = {
        score: Math.max(enrollment.score || 0, score),
        attempts: enrollment.attempts + 1,
        updatedAt: new Date(),
      };

      if (passed) {
        updateData.status = 'completed';
        updateData.completedAt = new Date();
      }

      await this.enrollmentRepository.update(enrollmentId, updateData);

      // Update progress record
      await this.updateAssessmentScore(enrollment.userId, enrollment.courseId, assessmentId, score, passed);

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Assessment',
        entityId: assessmentId,
        action: 'CREATE',
        details: {
          enrollmentId,
          score,
          passed,
          attempts: updateData.attempts,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('academy.assessment.submitted', {
        enrollmentId,
        assessmentId,
        score,
        passed,
        timestamp: new Date(),
      });

      return {
        score,
        passed,
        feedback: passed ? 'Congratulations! You passed the assessment.' : 'Please review the material and try again.',
      };
    } catch (error) {
      console.error('Error submitting assessment:', error);
      throw new Error('Failed to submit assessment');
    }
  }

  /**
   * Generate training certificate
   */
  async generateCertificate(enrollmentId: string): Promise<TrainingCertificate> {
    try {
      const enrollment = await this.enrollmentRepository.findOne({ where: { id: enrollmentId } });
      if (!enrollment) {
        throw new Error('Enrollment not found');
      }

      if (enrollment.status !== 'completed') {
        throw new Error('Course must be completed to generate certificate');
      }

      const course = await this.courseRepository.findOne({ where: { id: enrollment.courseId } });
      if (!course) {
        throw new Error('Course not found');
      }

      const certificate: TrainingCertificate = {
        id: `cert_${Date.now()}`,
        courseId: enrollment.courseId,
        userId: enrollment.userId,
        certificateNumber: `CERT-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`,
        issuedAt: new Date(),
        expiresAt: course.credits > 0 ? new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) : undefined, // 1 year for credit courses
        isActive: true,
        verificationCode: Math.random().toString(36).substr(2, 12).toUpperCase(),
        pdfPath: `/certificates/${enrollmentId}.pdf`,
        metadata: {
          courseTitle: course.title,
          completionDate: enrollment.completedAt,
          score: enrollment.score,
          credits: course.credits,
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.certificateRepository.save(certificate);

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Certificate',
        entityId: certificate.id,
        action: 'CREATE',
        details: {
          courseId: enrollment.courseId,
          userId: enrollment.userId,
          certificateNumber: certificate.certificateNumber,
          issuedAt: certificate.issuedAt,
        },
        userId: 'system',
      });

      this.eventEmitter.emit('academy.certificate.generated', {
        certificateId: certificate.id,
        courseId: enrollment.courseId,
        userId: enrollment.userId,
        certificateNumber: certificate.certificateNumber,
        timestamp: new Date(),
      });

      return certificate;
    } catch (error) {
      console.error('Error generating certificate:', error);
      throw new Error('Failed to generate certificate');
    }
  }

  /**
   * Get user's training progress
   */
  async getTrainingProgress(userId: string, courseId?: string): Promise<TrainingProgress[]> {
    try {
      const whereCondition = courseId ? { userId, courseId } : { userId };
      const enrollments = await this.enrollmentRepository.find({
        where: whereCondition,
        order: { createdAt: 'DESC' },
      });

      const progressRecords: TrainingProgress[] = [];

      for (const enrollment of enrollments) {
        const course = await this.courseRepository.findOne({ where: { id: enrollment.courseId } });
        if (!course) continue;

        const contentProgress = course.content.map(content => ({
          contentId: content.id,
          isCompleted: enrollment.progress >= 100,
          progress: enrollment.progress,
          timeSpent: enrollment.timeSpent,
          lastAccessedAt: enrollment.lastAccessedAt || enrollment.enrolledAt,
          completedAt: enrollment.completedAt,
        }));

        const assessmentScores = course.assessments.map(assessment => ({
          assessmentId: assessment.id,
          score: enrollment.score || 0,
          attempts: enrollment.attempts,
          bestScore: enrollment.score || 0,
          lastAttemptAt: enrollment.updatedAt,
          passed: enrollment.status === 'completed',
        }));

        const certificates = await this.certificateRepository.find({
          where: { userId: enrollment.userId, courseId: enrollment.courseId },
        });

        progressRecords.push({
          userId: enrollment.userId,
          courseId: enrollment.courseId,
          overallProgress: enrollment.progress,
          contentProgress,
          assessmentScores,
          timeSpent: enrollment.timeSpent,
          lastAccessedAt: enrollment.lastAccessedAt || enrollment.enrolledAt,
          completionDate: enrollment.completedAt,
          certificates: certificates.map(c => c.id),
        });
      }

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Progress',
        entityId: `progress_${userId}`,
        action: 'READ',
        details: {
          userId,
          courseId,
          recordCount: progressRecords.length,
        },
        userId: 'system',
      });

      return progressRecords;
    } catch (error) {
      console.error('Error getting training progress:', error);
      throw new Error('Failed to get training progress');
    }
  }

  /**
   * Get course analytics
   */
  async getCourseAnalytics(courseId: string): Promise<TrainingAnalytics> {
    try {
      const enrollments = await this.enrollmentRepository.find({ where: { courseId } });
      const course = await this.courseRepository.findOne({ where: { id: courseId } });
      if (!course) {
        throw new Error('Course not found');
      }

      const totalEnrollments = enrollments.length;
      const completions = enrollments.filter(e => e.status === 'completed').length;
      const averageScore = enrollments
        .filter(e => e.score !== undefined)
        .reduce((sum, e) => sum + (e.score || 0), 0) / enrollments.filter(e => e.score !== undefined).length || 0;
      const averageTimeToComplete = enrollments
        .filter(e => e.status === 'completed')
        .reduce((sum, e) => sum + e.timeSpent, 0) / completions || 0;
      const completionRate = totalEnrollments > 0 ? (completions / totalEnrollments) * 100 : 0;

      // Calculate drop-off points
      const dropOffPoints = course.content.map(content => {
        const contentEnrollments = enrollments.filter(e => e.currentContentId === content.id);
        const dropOffRate = contentEnrollments.length > 0 ? 
          (contentEnrollments.filter(e => e.status !== 'completed').length / contentEnrollments.length) * 100 : 0;
        
        return {
          contentId: content.id,
          contentTitle: content.title,
          dropOffRate,
          commonReasons: ['Content too difficult', 'Time constraints', 'Technical issues'],
        };
      });

      const analytics: TrainingAnalytics = {
        courseId,
        totalEnrollments,
        completions,
        averageScore,
        averageTimeToComplete,
        completionRate,
        dropOffPoints,
        feedback: [], // This would be populated from feedback data
        lastUpdated: new Date(),
      };

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Analytics',
        entityId: courseId,
        action: 'READ',
        details: {
          totalEnrollments,
          completions,
          averageScore,
          completionRate,
        },
        userId: 'system',
      });

      return analytics;
    } catch (error) {
      console.error('Error getting course analytics:', error);
      throw new Error('Failed to get course analytics');
    }
  }

  /**
   * Get all courses
   */
  async getAllCourses(): Promise<TrainingCourse[]> {
    try {
      const courses = await this.courseRepository.find({
        order: { createdAt: 'DESC' },
      });

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Courses',
        entityId: 'courses_list',
        action: 'READ',
        details: {
          count: courses.length,
        },
        userId: 'system',
      });

      return courses;
    } catch (error) {
      console.error('Error getting all courses:', error);
      throw new Error('Failed to get courses');
    }
  }

  /**
   * Get course by ID
   */
  async getCourseById(courseId: string): Promise<TrainingCourse | null> {
    try {
      const course = await this.courseRepository.findOne({ where: { id: courseId } });

      if (course) {
        await this.auditService.logEvent({
          resource: 'AcademyTraining',
          entityType: 'Course',
          entityId: courseId,
          action: 'READ',
          details: {
            courseTitle: course.title,
            category: course.category,
            level: course.level,
          },
          userId: 'system',
        });
      }

      return course;
    } catch (error) {
      console.error('Error getting course by ID:', error);
      throw new Error('Failed to get course');
    }
  }

  /**
   * Get academy training statistics
   */
  async getAcademyTrainingStatistics(): Promise<any> {
    try {
      const totalCourses = await this.courseRepository.count();
      const activeCourses = await this.courseRepository.count({ where: { isActive: true } });
      const totalEnrollments = await this.enrollmentRepository.count();
      const completedEnrollments = await this.enrollmentRepository.count({ where: { status: 'completed' } });
      const totalSessions = await this.sessionRepository.count();
      const totalCertificates = await this.certificateRepository.count();

      const statistics = {
        courses: {
          total: totalCourses,
          active: activeCourses,
          inactive: totalCourses - activeCourses,
        },
        enrollments: {
          total: totalEnrollments,
          completed: completedEnrollments,
          inProgress: await this.enrollmentRepository.count({ where: { status: 'in_progress' } }),
          failed: await this.enrollmentRepository.count({ where: { status: 'failed' } }),
          completionRate: totalEnrollments > 0 ? (completedEnrollments / totalEnrollments) * 100 : 0,
        },
        sessions: {
          total: totalSessions,
          scheduled: await this.sessionRepository.count({ where: { status: 'scheduled' } }),
          completed: await this.sessionRepository.count({ where: { status: 'completed' } }),
        },
        certificates: {
          total: totalCertificates,
          active: await this.certificateRepository.count({ where: { isActive: true } }),
          expired: await this.certificateRepository.count({ where: { isActive: false } }),
        },
        lastUpdated: new Date(),
      };

      await this.auditService.logEvent({
        resource: 'AcademyTraining',
        entityType: 'Statistics',
        entityId: 'academy_stats',
        action: 'READ',
        details: {
          totalCourses,
          activeCourses,
          totalEnrollments,
          completedEnrollments,
          totalSessions,
          totalCertificates,
        },
        userId: 'system',
      });

      return statistics;
    } catch (error) {
      console.error('Error getting academy training statistics:', error);
      throw new Error('Failed to get academy training statistics');
    }
  }

  /**
   * Helper method to calculate assessment score
   */
  private calculateAssessmentScore(assessment: TrainingAssessment, answers: Record<string, any>): number {
    let totalPoints = 0;
    let earnedPoints = 0;

    for (const question of assessment.questions) {
      totalPoints += question.points;
      
      const userAnswer = answers[question.id];
      if (userAnswer === question.correctAnswer) {
        earnedPoints += question.points;
      }
    }

    return totalPoints > 0 ? (earnedPoints / totalPoints) * 100 : 0;
  }

  /**
   * Helper method to update progress record
   */
  private async updateProgressRecord(
    userId: string,
    courseId: string,
    contentId: string,
    progress: number,
    timeSpent: number,
  ): Promise<void> {
    // This would update or create a progress record
    // Implementation depends on the specific progress tracking requirements
  }

  /**
   * Helper method to update assessment score
   */
  private async updateAssessmentScore(
    userId: string,
    courseId: string,
    assessmentId: string,
    score: number,
    passed: boolean,
  ): Promise<void> {
    // This would update or create an assessment score record
    // Implementation depends on the specific assessment tracking requirements
  }
}