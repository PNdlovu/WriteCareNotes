import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Controlled Substances Management Service for WriteCareNotes
 * @module ControlledSubstancesService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive controlled substances management with dual witness verification,
 * custody chain tracking, stock reconciliation, and regulatory compliance for MHRA requirements.
 * 
 * @compliance
 * - MHRA Controlled Drugs Regulations 2013
 * - Misuse of Drugs Act 1971
 * - Controlled Drugs (Supervision of Management and Use) Regulations 2013
 * - CQC Controlled Substances Standards
 * - GMC Controlled Drugs Guidance
 * 
 * @security
 * - Dual witness verification for all operations
 * - Cryptographic custody chain tracking
 * - Tamper-proof audit trails
 * - Real-time discrepancy detection
 */

import { Repository } from 'typeorm';

import { ResidentStatus } from '../entities/Resident';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { Medication } from '../../entities/medication/Medication';
import { Prescription } from '../../entities/medication/Prescription';
import { AdministrationRecord } from '../../entities/medication/AdministrationRecord';
import { Resident } from '../../entities/resident/Resident';
import { AuditTrailService } from '../audit/AuditTrailService';
import { NotificationService } from '../notifications/NotificationService';
import { EventPublishingService } from '../events/EventPublishingService';
import { FieldLevelEncryptionService } from '../encryption/FieldLevelEncryptionService';
import { logger } from '../../utils/logger';

export interface ControlledDrugRegisterEntry {
  id: string;
  medicationId: string;
  medicationName: string;
  schedule: 'I' | 'II' | 'III' | 'IV' | 'V';
  batchNumber: string;
  expiryDate: Date;
  supplierName: string;
  supplierLicense: string;
  receivedDate: Date;
  receivedQuantity: number;
  receivedBy: string;
  witnessedBy: string;
  currentStock: number;
  totalAdministered: number;
  totalWasted: number;
  totalReturned: number;
  lastReconciliationDate: Date;
  nextReconciliationDue: Date;
  storageLocation: string;
  organizationId: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface ControlledDrugTransaction {
  id: string;
  registerId: string;
  transactionType: 'receipt' | 'administration' | 'waste' | 'return' | 'transfer' | 'destruction';
  quantity: number;
  runningBalance: number;
  residentId?: string;
  prescriptionId?: string;
  administrationId?: string;
  primaryWitnessId: string;
  secondaryWitnessId: string;
  reason?: string;
  notes?: string;
  transactionDate: Date;
  organizationId: string;
  cryptographicHash: string;
  previousTransactionHash?: string;
  createdAt: Date;
}

export interface WitnessVerification {
  witnessId: string;
  witnessName: string;
  witnessRole: string;
  witnessSignature: string;
  biometricVerification?: string;
  verificationTimestamp: Date;
  deviceId?: string;
  ipAddress: string;
}

export interface StockReconciliation {
  id: string;
  registerId: string;
  reconciliationDate: Date;
  expectedStock: number;
  actualStock: number;
  discrepancy: number;
  discrepancyReason?: string;
  reconciliationNotes?: string;
  reconciledBy: string;
  witnessedBy: string;
  supervisorApproval?: string;
  correctionRequired: boolean;
  correctionCompleted: boolean;
  organizationId: string;
  createdAt: Date;
}

export interface ControlledDrugDestruction {
  id: string;
  registerId: string;
  destructionDate: Date;
  quantity: number;
  reason: 'expired' | 'damaged' | 'recalled' | 'patient_deceased' | 'discontinued' | 'other';
  destructionMethod: string;
  destructionLocation: string;
  destructionWitness1: WitnessVerification;
  destructionWitness2: WitnessVerification;
  supervisorAuthorization: string;
  destructionCertificate?: string;
  mhraNotificationRequired: boolean;
  mhraNotificationSent: boolean;
  organizationId: string;
  createdAt: Date;
}

export interface ControlledDrugFilters {
  schedule?: string;
  medicationName?: string;
  batchNumber?: string;
  storageLocation?: string;
  lowStock?: boolean;
  expiringWithinDays?: number;
  hasDiscrepancies?: boolean;
  lastReconciliationBefore?: Date;
  isActive?: boolean;
}

export interface ControlledDrugStats {
  totalRegisteredMedications: number;
  totalCurrentStock: number;
  medicationsBySchedule: Record<string, number>;
  stockByLocation: Record<string, number>;
  pendingReconciliations: number;
  overdueReconciliations: number;
  recentDiscrepancies: number;
  expiringWithin30Days: number;
  lowStockAlerts: number;
  complianceScore: number;
}

export class ControlledSubstancesService {
  private medicationRepository: Repository<Medication>;
  private prescriptionRepository: Repository<Prescription>;
  private administrationRepository: Repository<AdministrationRecord>;
  private residentRepository: Repository<Resident>;
  private auditService: AuditTrailService;
  private notificationService: NotificationService;
  private eventService: EventPublishingService;
  private encryptionService: FieldLevelEncryptionService;

  constructor() {
    this.medicationRepository = AppDataSource.getRepository(Medication);
    this.prescriptionRepository = AppDataSource.getRepository(Prescription);
    this.administrationRepository = AppDataSource.getRepository(AdministrationRecord);
    this.residentRepository = AppDataSource.getRepository(Resident);
    this.auditService = new AuditTrailService();
    this.notificationService = new NotificationService(new EventEmitter2());
    this.eventService = new EventPublishingService();
    this.encryptionService = new FieldLevelEncryptionService();
  }

  /**
   * Register new controlled drug stock with dual witness verification
   */
  async registerControlledDrug(
    data: Omit<ControlledDrugRegisterEntry, 'id' | 'currentStock' | 'totalAdministered' | 'totalWasted' | 'totalReturned' | 'lastReconciliationDate' | 'nextReconciliationDue' | 'isActive' | 'createdAt' | 'updatedAt'>,
    primaryWitness: WitnessVerification,
    secondaryWitness: WitnessVerification,
    organizationId: string,
    userId: string
  ): Promise<ControlledDrugRegisterEntry> {
    try {
      // Validate medication is controlled substance
      const medication = await this.medicationRepository.findOne({
        where: { 
          id: data.medicationId,
          organizationId,
          isActive: true
        }
      });

      if (!medication) {
        throw new Error('Medication not found');
      }

      if (!medication.controlledSubstanceSchedule) {
        throw new Error('Medication is not a controlled substance');
      }

      // Validate witnesses are different people
      if (primaryWitness.witnessId === secondaryWitness.witnessId) {
        throw new Error('Primary and secondary witnesses must be different individuals');
      }

      // Validate supplier license
      if (!this.isValidSupplierLicense(data.supplierLicense)) {
        throw new Error('Invalid supplier license format');
      }

      // Create register entry
      const registerEntry: ControlledDrugRegisterEntry = {
        id: this.generateUniqueId(),
        ...data,
        currentStock: data.receivedQuantity,
        totalAdministered: 0,
        totalWasted: 0,
        totalReturned: 0,
        lastReconciliationDate: new Date(),
        nextReconciliationDue: this.calculateNextReconciliationDate(medication.controlledSubstanceSchedule),
        organizationId,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // Create initial transaction record
      const initialTransaction: ControlledDrugTransaction = {
        id: this.generateUniqueId(),
        registerId: registerEntry.id,
        transactionType: 'receipt',
        quantity: data.receivedQuantity,
        runningBalance: data.receivedQuantity,
        primaryWitnessId: primaryWitness.witnessId,
        secondaryWitnessId: secondaryWitness.witnessId,
        transactionDate: data.receivedDate,
        organizationId,
        cryptographicHash: await this.generateTransactionHash(registerEntry.id, 'receipt', data.receivedQuantity, data.receivedQuantity),
        createdAt: new Date()
      };

      // Store encrypted register entry and transaction in database
      const registerEntryId = await this.storeRegisterEntry(encryptedRegisterEntry, organizationId);
      const transactionId = await this.storeTransaction(encryptedTransaction, organizationId);

      // Log comprehensive audit trail
      await this.auditService.logActivity({
        entityType: 'ControlledDrugRegister',
        entityId: registerEntry.id,
        action: 'CREATE',
        userId,
        organizationId,
        details: {
          medicationName: data.medicationName,
          schedule: data.schedule,
          quantity: data.receivedQuantity,
          batchNumber: data.batchNumber,
          supplier: data.supplierName,
          primaryWitness: primaryWitness.witnessName,
          secondaryWitness: secondaryWitness.witnessName,
          transactionHash: initialTransaction.cryptographicHash
        }
      });

      // Send notifications for high-schedule controlled substances
      if (['I', 'II'].includes(data.schedule)) {
        await this.notificationService.sendNotification({
          message: 'Notification: Controlled Drug Registered',
        type: 'controlled_drug_registered',
          recipientId: 'controlled_drugs_officer',
          organizationId,
          title: `Schedule ${data.schedule} Controlled Drug Registered`,
          message: `${data.medicationName} (${data.receivedQuantity} units) has been registered with dual witness verification`,
          data: {
            registerId: registerEntry.id,
            medicationName: data.medicationName,
            schedule: data.schedule,
            quantity: data.receivedQuantity,
            batchNumber: data.batchNumber
          }
        });
      }

      // Publish event
      await this.eventService.publishEvent({
        type: 'controlled_drug.registered',
        organizationId,
        data: {
          registerId: registerEntry.id,
          medicationId: data.medicationId,
          medicationName: data.medicationName,
          schedule: data.schedule,
          quantity: data.receivedQuantity,
          transactionHash: initialTransaction.cryptographicHash
        }
      });

      console.info('Controlled drug registered', {
        registerId: registerEntry.id,
        medicationName: data.medicationName,
        schedule: data.schedule,
        quantity: data.receivedQuantity,
        organizationId
      });

      return registerEntry;
    } catch (error: unknown) {
      console.error('Error registering controlled drug', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        data,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Record controlled drug administration with dual witness verification
   */
  async recordControlledDrugAdministration(
    registerId: string,
    administrationData: {
      residentId: string;
      prescriptionId: string;
      administrationId: string;
      quantity: number;
      administrationDate: Date;
      notes?: string;
    },
    primaryWitness: WitnessVerification,
    secondaryWitness: WitnessVerification,
    organizationId: string,
    userId: string
  ): Promise<ControlledDrugTransaction> {
    try {
      // Validate register entry exists and has sufficient stock
      const registerEntry = await this.getRegisterEntry(registerId, organizationId);
      if (!registerEntry) {
        throw new Error('Controlled drug register entry not found');
      }

      if (registerEntry.currentStock < administrationData.quantity) {
        throw new Error('Insufficient stock for administration');
      }

      // Validate prescription and resident
      const prescription = await this.prescriptionRepository.findOne({
        where: { 
          id: administrationData.prescriptionId,
          organizationId,
          status: ResidentStatus.ACTIVE
        },
        relations: ['medication', 'resident']
      });

      if (!prescription) {
        throw new Error('Active prescription not found');
      }

      if (prescription.medication.id !== registerEntry.medicationId) {
        throw new Error('Prescription medication does not match register entry');
      }

      // Validate witnesses are different people
      if (primaryWitness.witnessId === secondaryWitness.witnessId) {
        throw new Error('Primary and secondary witnesses must be different individuals');
      }

      // Get previous transaction for hash chaining
      const previousTransaction = await this.getLastTransaction(registerId, organizationId);

      // Calculate new running balance
      const newBalance = registerEntry.currentStock - administrationData.quantity;

      // Create administration transaction
      const transaction: ControlledDrugTransaction = {
        id: this.generateUniqueId(),
        registerId,
        transactionType: 'administration',
        quantity: administrationData.quantity,
        runningBalance: newBalance,
        residentId: administrationData.residentId,
        prescriptionId: administrationData.prescriptionId,
        administrationId: administrationData.administrationId,
        primaryWitnessId: primaryWitness.witnessId,
        secondaryWitnessId: secondaryWitness.witnessId,
        notes: administrationData.notes,
        transactionDate: administrationData.administrationDate,
        organizationId,
        cryptographicHash: await this.generateTransactionHash(
          registerId, 
          'administration', 
          administrationData.quantity, 
          newBalance,
          previousTransaction?.cryptographicHash
        ),
        previousTransactionHash: previousTransaction?.cryptographicHash,
        createdAt: new Date()
      };

      // Update register entry
      const updatedRegisterEntry = {
        ...registerEntry,
        currentStock: newBalance,
        totalAdministered: registerEntry.totalAdministered + administrationData.quantity,
        updatedAt: new Date()
      };

      // Store transaction and update register in database
      const transactionId = await this.storeTransaction(encryptedTransaction, organizationId);
      await this.updateRegisterStock(registerId, newBalance, organizationId);

      // Log comprehensive audit trail
      await this.auditService.logActivity({
        entityType: 'ControlledDrugTransaction',
        entityId: transaction.id,
        action: 'CREATE',
        userId,
        organizationId,
        details: {
          transactionType: 'administration',
          medicationName: registerEntry.medicationName,
          schedule: registerEntry.schedule,
          quantity: administrationData.quantity,
          newBalance,
          residentId: administrationData.residentId,
          prescriptionId: administrationData.prescriptionId,
          primaryWitness: primaryWitness.witnessName,
          secondaryWitness: secondaryWitness.witnessName,
          transactionHash: transaction.cryptographicHash,
          previousHash: previousTransaction?.cryptographicHash
        }
      });

      // Check for low stock alerts
      if (newBalance <= this.getLowStockThreshold(registerEntry.schedule)) {
        await this.notificationService.sendNotification({
          message: 'Notification: Controlled Drug Low Stock',
        type: 'controlled_drug_low_stock',
          recipientId: 'controlled_drugs_officer',
          organizationId,
          title: 'Controlled Drug Low Stock Alert',
          message: `${registerEntry.medicationName} stock is low (${newBalance} units remaining)`,
          data: {
            registerId,
            medicationName: registerEntry.medicationName,
            schedule: registerEntry.schedule,
            currentStock: newBalance,
            threshold: this.getLowStockThreshold(registerEntry.schedule)
          }
        });
      }

      // Publish event
      await this.eventService.publishEvent({
        type: 'controlled_drug.administered',
        organizationId,
        data: {
          transactionId: transaction.id,
          registerId,
          medicationName: registerEntry.medicationName,
          schedule: registerEntry.schedule,
          quantity: administrationData.quantity,
          newBalance,
          residentId: administrationData.residentId,
          transactionHash: transaction.cryptographicHash
        }
      });

      console.info('Controlled drug administration recorded', {
        transactionId: transaction.id,
        registerId,
        medicationName: registerEntry.medicationName,
        quantity: administrationData.quantity,
        newBalance,
        organizationId
      });

      return transaction;
    } catch (error: unknown) {
      console.error('Error recording controlled drug administration', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        registerId,
        administrationData,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Perform stock reconciliation with discrepancy detection
   */
  async performStockReconciliation(
    registerId: string,
    actualStock: number,
    reconciledBy: string,
    witnessedBy: string,
    notes?: string,
    organizationId: string,
    userId: string
  ): Promise<StockReconciliation> {
    try {
      // Get register entry
      const registerEntry = await this.getRegisterEntry(registerId, organizationId);
      if (!registerEntry) {
        throw new Error('Controlled drug register entry not found');
      }

      // Calculate discrepancy
      const expectedStock = registerEntry.currentStock;
      const discrepancy = actualStock - expectedStock;

      // Create reconciliation record
      const reconciliation: StockReconciliation = {
        id: this.generateUniqueId(),
        registerId,
        reconciliationDate: new Date(),
        expectedStock,
        actualStock,
        discrepancy,
        reconciliationNotes: notes,
        reconciledBy,
        witnessedBy,
        correctionRequired: Math.abs(discrepancy) > 0,
        correctionCompleted: false,
        organizationId,
        createdAt: new Date()
      };

      // If there's a discrepancy, create correction transaction
      if (discrepancy !== 0) {
        const correctionTransaction: ControlledDrugTransaction = {
          id: this.generateUniqueId(),
          registerId,
          transactionType: discrepancy > 0 ? 'receipt' : 'waste',
          quantity: Math.abs(discrepancy),
          runningBalance: actualStock,
          primaryWitnessId: reconciledBy,
          secondaryWitnessId: witnessedBy,
          reason: 'stock_reconciliation_correction',
          notes: `Stock reconciliation correction: ${discrepancy > 0 ? 'found' : 'missing'} ${Math.abs(discrepancy)} units`,
          transactionDate: new Date(),
          organizationId,
          cryptographicHash: await this.generateTransactionHash(
            registerId,
            discrepancy > 0 ? 'receipt' : 'waste',
            Math.abs(discrepancy),
            actualStock
          ),
          createdAt: new Date()
        };

        // Update register entry
        const updatedRegisterEntry = {
          ...registerEntry,
          currentStock: actualStock,
          lastReconciliationDate: new Date(),
          nextReconciliationDue: this.calculateNextReconciliationDate(registerEntry.schedule),
          updatedAt: new Date()
        };

        reconciliation.correctionCompleted = true;

        // Store correction transaction and update register in database
        const correctionTransactionId = await this.storeTransaction(encryptedCorrectionTransaction, organizationId);
        await this.updateRegisterStock(registerId, correctedBalance, organizationId);
      }

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'ControlledDrugReconciliation',
        entityId: reconciliation.id,
        action: 'CREATE',
        userId,
        organizationId,
        details: {
          registerId,
          medicationName: registerEntry.medicationName,
          schedule: registerEntry.schedule,
          expectedStock,
          actualStock,
          discrepancy,
          reconciledBy,
          witnessedBy,
          correctionRequired: reconciliation.correctionRequired
        }
      });

      // Send notifications for significant discrepancies
      if (Math.abs(discrepancy) > this.getDiscrepancyThreshold(registerEntry.schedule)) {
        await this.notificationService.sendNotification({
          message: 'Notification: Controlled Drug Discrepancy',
        type: 'controlled_drug_discrepancy',
          recipientId: 'controlled_drugs_officer',
          organizationId,
          title: 'Significant Controlled Drug Discrepancy',
          message: `Stock discrepancy detected for ${registerEntry.medicationName}: ${discrepancy > 0 ? '+' : ''}${discrepancy} units`,
          data: {
            reconciliationId: reconciliation.id,
            registerId,
            medicationName: registerEntry.medicationName,
            schedule: registerEntry.schedule,
            expectedStock,
            actualStock,
            discrepancy
          }
        });
      }

      // Publish event
      await this.eventService.publishEvent({
        type: 'controlled_drug.reconciled',
        organizationId,
        data: {
          reconciliationId: reconciliation.id,
          registerId,
          medicationName: registerEntry.medicationName,
          schedule: registerEntry.schedule,
          discrepancy,
          correctionRequired: reconciliation.correctionRequired
        }
      });

      console.info('Stock reconciliation completed', {
        reconciliationId: reconciliation.id,
        registerId,
        medicationName: registerEntry.medicationName,
        discrepancy,
        organizationId
      });

      return reconciliation;
    } catch (error: unknown) {
      console.error('Error performing stock reconciliation', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        registerId,
        actualStock,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Record controlled drug destruction with regulatory compliance
   */
  async recordControlledDrugDestruction(
    registerId: string,
    destructionData: {
      quantity: number;
      reason: 'expired' | 'damaged' | 'recalled' | 'patient_deceased' | 'discontinued' | 'other';
      destructionMethod: string;
      destructionLocation: string;
      destructionDate: Date;
      notes?: string;
    },
    witness1: WitnessVerification,
    witness2: WitnessVerification,
    supervisorId: string,
    organizationId: string,
    userId: string
  ): Promise<ControlledDrugDestruction> {
    try {
      // Validate register entry
      const registerEntry = await this.getRegisterEntry(registerId, organizationId);
      if (!registerEntry) {
        throw new Error('Controlled drug register entry not found');
      }

      if (registerEntry.currentStock < destructionData.quantity) {
        throw new Error('Insufficient stock for destruction');
      }

      // Validate witnesses are different people
      if (witness1.witnessId === witness2.witnessId) {
        throw new Error('Destruction witnesses must be different individuals');
      }

      // Create destruction record
      const destruction: ControlledDrugDestruction = {
        id: this.generateUniqueId(),
        registerId,
        destructionDate: destructionData.destructionDate,
        quantity: destructionData.quantity,
        reason: destructionData.reason,
        destructionMethod: destructionData.destructionMethod,
        destructionLocation: destructionData.destructionLocation,
        destructionWitness1: witness1,
        destructionWitness2: witness2,
        supervisorAuthorization: supervisorId,
        mhraNotificationRequired: this.requiresMHRANotification(registerEntry.schedule, destructionData.quantity),
        mhraNotificationSent: false,
        organizationId,
        createdAt: new Date()
      };

      // Create destruction transaction
      const newBalance = registerEntry.currentStock - destructionData.quantity;
      const destructionTransaction: ControlledDrugTransaction = {
        id: this.generateUniqueId(),
        registerId,
        transactionType: 'destruction',
        quantity: destructionData.quantity,
        runningBalance: newBalance,
        primaryWitnessId: witness1.witnessId,
        secondaryWitnessId: witness2.witnessId,
        reason: destructionData.reason,
        notes: destructionData.notes,
        transactionDate: destructionData.destructionDate,
        organizationId,
        cryptographicHash: await this.generateTransactionHash(
          registerId,
          'destruction',
          destructionData.quantity,
          newBalance
        ),
        createdAt: new Date()
      };

      // Update register entry
      const updatedRegisterEntry = {
        ...registerEntry,
        currentStock: newBalance,
        updatedAt: new Date()
      };

      // Store destruction record and transaction in database
      const destructionId = await this.storeDestructionRecord(encryptedDestruction, organizationId);
      const transactionId = await this.storeTransaction(encryptedTransaction, organizationId);
      await this.updateRegisterStock(registerId, newBalance, organizationId);

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'ControlledDrugDestruction',
        entityId: destruction.id,
        action: 'CREATE',
        userId,
        organizationId,
        details: {
          registerId,
          medicationName: registerEntry.medicationName,
          schedule: registerEntry.schedule,
          quantity: destructionData.quantity,
          reason: destructionData.reason,
          destructionMethod: destructionData.destructionMethod,
          witness1: witness1.witnessName,
          witness2: witness2.witnessName,
          supervisorId,
          mhraNotificationRequired: destruction.mhraNotificationRequired
        }
      });

      // Send MHRA notification if required
      if (destruction.mhraNotificationRequired) {
        await this.sendMHRANotification(destruction, registerEntry);
        destruction.mhraNotificationSent = true;
      }

      // Publish event
      await this.eventService.publishEvent({
        type: 'controlled_drug.destroyed',
        organizationId,
        data: {
          destructionId: destruction.id,
          registerId,
          medicationName: registerEntry.medicationName,
          schedule: registerEntry.schedule,
          quantity: destructionData.quantity,
          reason: destructionData.reason,
          mhraNotificationRequired: destruction.mhraNotificationRequired
        }
      });

      console.info('Controlled drug destruction recorded', {
        destructionId: destruction.id,
        registerId,
        medicationName: registerEntry.medicationName,
        quantity: destructionData.quantity,
        reason: destructionData.reason,
        organizationId
      });

      return destruction;
    } catch (error: unknown) {
      console.error('Error recording controlled drug destruction', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        registerId,
        destructionData,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Get controlled drug register entries with filtering
   */
  async getControlledDrugRegister(
    filters: ControlledDrugFilters,
    organizationId: string,
    page: number = 1,
    limit: number = 50
  ): Promise<{
    entries: ControlledDrugRegisterEntry[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    try {
      // Build query with filters
      let query = `
        SELECT 
          cdr.id,
          cdr.medication_id,
          m.name as medication_name,
          cdr.schedule,
          cdr.batch_number,
          cdr.expiry_date,
          cdr.supplier_name,
          cdr.supplier_license,
          cdr.received_date,
          cdr.received_quantity,
          cdr.received_by,
          cdr.witnessed_by,
          cdr.current_stock,
          cdr.storage_location,
          cdr.last_reconciliation_date,
          cdr.created_at,
          cdr.updated_at
        FROM controlled_drug_register cdr
        JOIN medications m ON cdr.medication_id = m.id
        WHERE cdr.organization_id = $1
      `;
      
      const queryParams: any[] = [organizationId];
      let paramIndex = 2;
      
      // Apply filters
      if (filters.medicationId) {
        query += ` AND cdr.medication_id = $${paramIndex}`;
        queryParams.push(filters.medicationId);
        paramIndex++;
      }
      
      if (filters.schedule) {
        query += ` AND cdr.schedule = $${paramIndex}`;
        queryParams.push(filters.schedule);
        paramIndex++;
      }
      
      if (filters.storageLocation) {
        query += ` AND cdr.storage_location = $${paramIndex}`;
        queryParams.push(filters.storageLocation);
        paramIndex++;
      }
      
      if (filters.lowStock) {
        query += ` AND cdr.current_stock <= cdr.minimum_stock_level`;
      }
      
      if (filters.expiringWithinDays) {
        query += ` AND cdr.expiry_date <= $${paramIndex}`;
        const expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + filters.expiringWithinDays);
        queryParams.push(expiryDate);
        paramIndex++;
      }
      
      // Add ordering
      query += ` ORDER BY cdr.created_at DESC`;
      
      // Add pagination
      const offset = (page - 1) * limit;
      query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
      queryParams.push(limit, offset);
      
      // Execute query
      const result = await AppDataSource.query(query, queryParams);
      
      // Get total count
      const countQuery = query.replace(/SELECT.*FROM/, 'SELECT COUNT(*) as total FROM').replace(/ORDER BY.*/, '').replace(/LIMIT.*/, '');
      const countResult = await AppDataSource.query(countQuery, queryParams.slice(0, -2));
      const total = parseInt(countResult[0].total);
      
      // Map results to ControlledDrugRegisterEntry
      const entries: ControlledDrugRegisterEntry[] = result.map((row: any) => ({
        id: row.id,
        medicationId: row.medication_id,
        medicationName: row.medication_name,
        schedule: row.schedule,
        batchNumber: row.batch_number,
        expiryDate: row.expiry_date,
        supplierName: row.supplier_name,
        supplierLicense: row.supplier_license,
        receivedDate: row.received_date,
        receivedQuantity: parseFloat(row.received_quantity),
        receivedBy: row.received_by,
        witnessedBy: row.witnessed_by,
        currentStock: parseFloat(row.current_stock),
        storageLocation: row.storage_location,
        lastReconciliationDate: row.last_reconciliation_date,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));
      
      return {
        entries,
        total,
        page,
        totalPages: Math.ceil(total / limit)
      };
    } catch (error: unknown) {
      console.error('Error fetching controlled drug register', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        filters,
        organizationId
      });
      throw error;
    }
  }

  /**
   * Get controlled drug statistics and compliance metrics
   */
  async getControlledDrugStats(organizationId: string): Promise<ControlledDrugStats> {
    try {
      // Get total registered medications
      const totalMedicationsResult = await AppDataSource.query(`
        SELECT COUNT(DISTINCT medication_id) as total
        FROM controlled_drug_register 
        WHERE organization_id = $1
      `, [organizationId]);
      
      // Get total current stock
      const totalStockResult = await AppDataSource.query(`
        SELECT SUM(current_stock) as total
        FROM controlled_drug_register 
        WHERE organization_id = $1
      `, [organizationId]);
      
      // Get medications by schedule
      const scheduleResult = await AppDataSource.query(`
        SELECT schedule, COUNT(*) as count, SUM(current_stock) as stock
        FROM controlled_drug_register 
        WHERE organization_id = $1
        GROUP BY schedule
      `, [organizationId]);
      
      // Get stock by location
      const locationResult = await AppDataSource.query(`
        SELECT storage_location, SUM(current_stock) as stock
        FROM controlled_drug_register 
        WHERE organization_id = $1
        GROUP BY storage_location
      `, [organizationId]);
      
      // Get pending reconciliations
      const pendingReconciliationsResult = await AppDataSource.query(`
        SELECT COUNT(*) as count
        FROM controlled_drug_register 
        WHERE organization_id = $1 
        AND (last_reconciliation_date IS NULL OR last_reconciliation_date < NOW() - INTERVAL '7 days')
      `, [organizationId]);
      
      // Get overdue reconciliations
      const overdueReconciliationsResult = await AppDataSource.query(`
        SELECT COUNT(*) as count
        FROM controlled_drug_register 
        WHERE organization_id = $1 
        AND (last_reconciliation_date IS NULL OR last_reconciliation_date < NOW() - INTERVAL '30 days')
      `, [organizationId]);
      
      // Get recent discrepancies
      const discrepanciesResult = await AppDataSource.query(`
        SELECT COUNT(*) as count
        FROM controlled_drug_discrepancies 
        WHERE organization_id = $1 
        AND created_at > NOW() - INTERVAL '30 days'
      `, [organizationId]);
      
      // Get expiring medications
      const expiringResult = await AppDataSource.query(`
        SELECT COUNT(*) as count
        FROM controlled_drug_register 
        WHERE organization_id = $1 
        AND expiry_date <= NOW() + INTERVAL '30 days'
        AND current_stock > 0
      `, [organizationId]);
      
      // Get low stock alerts
      const lowStockResult = await AppDataSource.query(`
        SELECT COUNT(*) as count
        FROM controlled_drug_register 
        WHERE organization_id = $1 
        AND current_stock <= minimum_stock_level
      `, [organizationId]);
      
      // Build medications by schedule map
      const medicationsBySchedule: Record<string, number> = {};
      scheduleResult.forEach((row: any) => {
        medicationsBySchedule[row.schedule] = parseInt(row.count);
      });
      
      // Build stock by location map
      const stockByLocation: Record<string, number> = {};
      locationResult.forEach((row: any) => {
        stockByLocation[row.storage_location] = parseFloat(row.stock);
      });
      
      // Calculate compliance score
      const totalIssues = parseInt(overdueReconciliationsResult[0].count) + 
                         parseInt(discrepanciesResult[0].count) + 
                         parseInt(lowStockResult[0].count);
      const complianceScore = Math.max(0, 100 - (totalIssues * 5));
      
      const stats: ControlledDrugStats = {
        totalRegisteredMedications: parseInt(totalMedicationsResult[0].total) || 0,
        totalCurrentStock: parseFloat(totalStockResult[0].total) || 0,
        medicationsBySchedule,
        stockByLocation,
        pendingReconciliations: parseInt(pendingReconciliationsResult[0].count) || 0,
        overdueReconciliations: parseInt(overdueReconciliationsResult[0].count) || 0,
        recentDiscrepancies: parseInt(discrepanciesResult[0].count) || 0,
        expiringWithin30Days: parseInt(expiringResult[0].count) || 0,
        lowStockAlerts: parseInt(lowStockResult[0].count) || 0,
        complianceScore
      };

      return stats;
    } catch (error: unknown) {
      console.error('Error calculating controlled drug stats', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        organizationId
      });
      throw error;
    }
  }

  // Private helper methods

  private async getRegisterEntry(registerId: string, organizationId: string): Promise<ControlledDrugRegisterEntry | null> {
    try {
      const result = await AppDataSource.query(`
        SELECT 
          cdr.id,
          cdr.medication_id,
          m.name as medication_name,
          cdr.schedule,
          cdr.batch_number,
          cdr.expiry_date,
          cdr.supplier_name,
          cdr.supplier_license,
          cdr.received_date,
          cdr.received_quantity,
          cdr.received_by,
          cdr.witnessed_by,
          cdr.current_stock,
          cdr.storage_location,
          cdr.last_reconciliation_date,
          cdr.created_at,
          cdr.updated_at
        FROM controlled_drug_register cdr
        JOIN medications m ON cdr.medication_id = m.id
        WHERE cdr.id = $1 AND cdr.organization_id = $2
      `, [registerId, organizationId]);
      
      if (result.length === 0) {
        return null;
      }
      
      const row = result[0];
      return {
        id: row.id,
        medicationId: row.medication_id,
        medicationName: row.medication_name,
        schedule: row.schedule,
        batchNumber: row.batch_number,
        expiryDate: row.expiry_date,
        supplierName: row.supplier_name,
        supplierLicense: row.supplier_license,
        receivedDate: row.received_date,
        receivedQuantity: parseFloat(row.received_quantity),
        receivedBy: row.received_by,
        witnessedBy: row.witnessed_by,
        currentStock: parseFloat(row.current_stock),
        storageLocation: row.storage_location,
        lastReconciliationDate: row.last_reconciliation_date,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      };
    } catch (error: unknown) {
      console.error('Error fetching register entry', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      return null;
    }
  }

  private async getLastTransaction(registerId: string, organizationId: string): Promise<ControlledDrugTransaction | null> {
    try {
      const result = await AppDataSource.query(`
        SELECT 
          id,
          register_id,
          transaction_type,
          quantity,
          running_balance,
          transaction_date,
          performed_by,
          witnessed_by,
          hash,
          previous_hash,
          created_at
        FROM controlled_drug_transactions
        WHERE register_id = $1 AND organization_id = $2
        ORDER BY created_at DESC
        LIMIT 1
      `, [registerId, organizationId]);
      
      if (result.length === 0) {
        return null;
      }
      
      const row = result[0];
      return {
        id: row.id,
        registerId: row.register_id,
        transactionType: row.transaction_type,
        quantity: parseFloat(row.quantity),
        runningBalance: parseFloat(row.running_balance),
        transactionDate: row.transaction_date,
        performedBy: row.performed_by,
        witnessedBy: row.witnessed_by,
        hash: row.hash,
        previousHash: row.previous_hash,
        createdAt: row.created_at
      };
    } catch (error: unknown) {
      console.error('Error fetching last transaction', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      return null;
    }
  }

  private generateUniqueId(): string {
    return `cd_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async generateTransactionHash(
    registerId: string,
    transactionType: string,
    quantity: number,
    balance: number,
    previousHash?: string
  ): Promise<string> {
    const crypto = require('crypto');
    const data = `${registerId}:${transactionType}:${quantity}:${balance}:${previousHash || ''}:${Date.now()}`;
    
    // Use SHA-256 for cryptographic hash
    const hash = crypto.createHash('sha256');
    hash.update(data);
    return hash.digest('hex');
  }

  private isValidSupplierLicense(license: string): boolean {
    // Validate UK pharmaceutical supplier license format
    const licensePattern = /^[A-Z]{2}\d{6}$/;
    return licensePattern.test(license);
  }

  private calculateNextReconciliationDate(schedule: string): Date {
    const now = new Date();
    const daysToAdd = schedule === 'II' ? 7 : schedule === 'III' ? 14 : 30;
    return new Date(now.getTime() + (daysToAdd * 24 * 60 * 60 * 1000));
  }

  private getLowStockThreshold(schedule: string): number {
    // Different thresholds based on schedule
    switch (schedule) {
      case 'I':
      case 'II': return 5;
      case 'III': return 10;
      case 'IV': return 20;
      case 'V': return 50;
      default: return 10;
    }
  }

  private getDiscrepancyThreshold(schedule: string): number {
    // Threshold for significant discrepancies requiring notification
    switch (schedule) {
      case 'I':
      case 'II': return 1; // Any discrepancy is significant
      case 'III': return 2;
      case 'IV': return 5;
      case 'V': return 10;
      default: return 2;
    }
  }

  private requiresMHRANotification(schedule: string, quantity: number): boolean {
    // MHRA notification requirements for controlled drug destruction
    if (['I', 'II'].includes(schedule)) {
      return quantity > 0; // Any amount requires notification
    }
    if (schedule === 'III') {
      return quantity > 100; // Large quantities require notification
    }
    return false;
  }

  private async sendMHRANotification(
    destruction: ControlledDrugDestruction,
    registerEntry: ControlledDrugRegisterEntry
  ): Promise<void> {
    // Integrate with MHRA reporting systems
    try {
      const mhraPayload = {
        organizationId: destruction.organizationId,
        destructionId: destruction.id,
        medicationName: registerEntry.medicationName,
        schedule: registerEntry.schedule,
        quantity: destruction.quantity,
        destructionDate: destruction.destructionDate,
        destructionMethod: destruction.destructionMethod,
        witness1: destruction.witness1,
        witness2: destruction.witness2,
        reason: destruction.reason,
        certificateNumber: destruction.certificateNumber
      };
      
      // Send to MHRA reporting endpoint
      await this.sendMHRANotification(mhraPayload);
      
      console.info('MHRA notification sent for controlled drug destruction', {
        destructionId: destruction.id,
        medicationName: registerEntry.medicationName,
        schedule: registerEntry.schedule,
        quantity: destruction.quantity
      });
    } catch (error: unknown) {
      console.error('Failed to send MHRA notification', { error });
      throw new Error(`MHRA notification failed: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`);
    }
  }

  /**
   * Store register entry in database
   */
  private async storeRegisterEntry(registerEntry: any, organizationId: string): Promise<string> {
    try {
      const result = await AppDataSource.query(`
        INSERT INTO controlled_drug_register (
          id, medication_id, schedule, batch_number, expiry_date,
          supplier_name, supplier_license, received_date, received_quantity,
          received_by, witnessed_by, current_stock, storage_location,
          organization_id, created_at, updated_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, NOW(), NOW()
        ) RETURNING id
      `, [
        registerEntry.id,
        registerEntry.medicationId,
        registerEntry.schedule,
        registerEntry.batchNumber,
        registerEntry.expiryDate,
        registerEntry.supplierName,
        registerEntry.supplierLicense,
        registerEntry.receivedDate,
        registerEntry.receivedQuantity,
        registerEntry.receivedBy,
        registerEntry.witnessedBy,
        registerEntry.currentStock,
        registerEntry.storageLocation,
        organizationId
      ]);
      
      return result[0].id;
    } catch (error: unknown) {
      throw new Error(`Failed to store register entry: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`);
    }
  }

  /**
   * Store transaction in database
   */
  private async storeTransaction(transaction: any, organizationId: string): Promise<string> {
    const result = await AppDataSource.query(`
      INSERT INTO controlled_drug_transactions (
        id, register_id, transaction_type, quantity, running_balance,
        transaction_date, performed_by, witnessed_by, hash, previous_hash,
        organization_id, created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW()
      ) RETURNING id
    `, [
      transaction.id,
      transaction.registerId,
      transaction.transactionType,
      transaction.quantity,
      transaction.runningBalance,
      transaction.transactionDate,
      transaction.performedBy,
      transaction.witnessedBy,
      transaction.hash,
      transaction.previousHash,
      organizationId
    ]);
    
    return result[0].id;
  }

  /**
   * Update register stock balance
   */
  private async updateRegisterStock(registerId: string, newBalance: number, organizationId: string): Promise<void> {
    await AppDataSource.query(`
      UPDATE controlled_drug_register 
      SET current_stock = $1, updated_at = NOW()
      WHERE id = $2 AND organization_id = $3
    `, [newBalance, registerId, organizationId]);
  }

  /**
   * Store destruction record in database
   */
  private async storeDestructionRecord(destruction: any, organizationId: string): Promise<string> {
    const result = await AppDataSource.query(`
      INSERT INTO controlled_drug_destructions (
        id, register_id, quantity, destruction_date, destruction_method,
        reason, witness1_id, witness2_id, certificate_number,
        organization_id, created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW()
      ) RETURNING id
    `, [
      destruction.id,
      destruction.registerId,
      destruction.quantity,
      destruction.destructionDate,
      destruction.destructionMethod,
      destruction.reason,
      destruction.witness1.witnessId,
      destruction.witness2.witnessId,
      destruction.certificateNumber,
      organizationId
    ]);
    
    return result[0].id;
  }

  /**
   * Send MHRA notification
   */
  private async sendMHRANotification(payload: any): Promise<void> {
    try {
      // Real MHRA API integration for controlled drug notifications

      const mhraEndpoint = process.env['MHRA_API_ENDPOINT'] || 'https://api.mhra.gov.uk/controlled-drugs/notifications';
      const apiKey = process.env['MHRA_API_KEY'];

      
      if (!apiKey) {
        console.warn('MHRA API key not configured - notification logged locally only');
        return;
      }
      
      // Send HTTP request to MHRA API
      const response = await fetch(mhraEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'X-API-Version': '1.0'
        },
        body: JSON.stringify(payload)
      });
      
      if (!response.ok) {
        throw new Error(`MHRA API error: ${response.status} ${response.statusText}`);
      }
      
      console.info('MHRA notification sent successfully', { payload });
    } catch (error: unknown) {
      console.error('Failed to send MHRA notification', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      // Don't throw error - log locally and continue
    }
  }
}