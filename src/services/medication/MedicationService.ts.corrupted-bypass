/**
 * @fileoverview Medication Service for WriteCareNotes
 * @module MedicationService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-09
 * 
 * @description Core service for medication administration record (MAR) system with real-time tracking,
 * prescription management, drug interaction checking, controlled substance tracking, and compliance reporting.
 * 
 * @compliance
 * - CQC (Care Quality Commission) - England
 * - Care Inspectorate - Scotland  
 * - CIW (Care Inspectorate Wales) - Wales
 * - RQIA (Regulation and Quality Improvement Authority) - Northern Ireland
 * - Controlled Drugs Regulations 2001
 * - NICE Guidelines for Medication Management
 * - MHRA (Medicines and Healthcare products Regulatory Agency)
 * 
 * @security
 * - Implements field-level encryption for sensitive medication data
 * - Comprehensive audit trails for all medication operations
 * - Role-based access control for controlled substances
 * - Witness requirements for controlled drug administration
 */

import { DataSource, Repository } from 'typeorm';
import { validate, ValidationError } from 'class-validator';
import { Medication, MedicationType, MedicationForm, MedicationRoute } from '../../entities/medication/Medication';
import { Prescription, PrescriptionStatus } from '../../entities/medication/Prescription';
import { MedicationAdministration, AdministrationStatus } from '../../entities/medication/MedicationAdministration';
import { DrugInteraction, InteractionSeverity } from '../../entities/medication/DrugInteraction';
import { ControlledSubstance, ControlledSubstanceSchedule } from '../../entities/medication/ControlledSubstance';
import { Resident } from '../../entities/resident/Resident';
import { MedicationRepository } from '../../repositories/medication/MedicationRepository';
import { PrescriptionRepository } from '../../repositories/medication/PrescriptionRepository';
import { MedicationAdministrationRepository } from '../../repositories/medication/MedicationAdministrationRepository';
import { AuditTrailService } from '../audit/AuditTrailService';
import { FieldLevelEncryptionService } from '../encryption/FieldLevelEncryptionService';
import { NotificationService } from '../notifications/NotificationService';
import { EventPublishingService } from '../events/EventPublishingService';
import { HealthcareCacheManager } from '../caching/HealthcareCacheManager';
import { logger } from '../../utils/logger';

export interface CreateMedicationRequest {
  name: string;
  genericName?: string;
  brandName?: string;
  strength: string;
  form: MedicationForm;
  route: MedicationRoute;
  type: MedicationType;
  activeIngredient: string;
  manufacturer?: string;
  ndcCode?: string;
  isControlledSubstance: boolean;
  controlledSubstanceSchedule?: ControlledSubstanceSchedule;
  sideEffects?: string[];
  contraindications?: string[];
  interactions?: string[];
  storageRequirements?: string;
  createdBy: string;
}

export interface CreatePrescriptionRequest {
  residentId: string;
  medicationId: string;
  prescriberId: string;
  prescriberName: string;
  dosage: number;
  dosageUnit: string;
  frequency: string;
  route: MedicationRoute;
  startDate: Date;
  endDate?: Date;
  instructions?: string;
  quantityPrescribed?: number;
  refillsRemaining?: number;
  indication?: string;
  createdBy: string;
}

export interface UpdatePrescriptionRequest {
  dosage?: number;
  dosageUnit?: string;
  frequency?: string;
  route?: MedicationRoute;
  endDate?: Date;
  instructions?: string;
  refillsRemaining?: number;
  status?: PrescriptionStatus;
  updatedBy: string;
}

export interface MedicationAdministrationRequest {
  prescriptionId: string;
  residentId: string;
  scheduledTime: Date;
  dosageGiven?: number;
  administeredBy: string;
  witnessId?: string;
  notes?: string;
  administrationMethod?: string;
  siteOfAdministration?: string;
}

export interface MedicationSearchFilters {
  residentId?: string;
  medicationId?: string;
  prescriptionId?: string;
  status?: PrescriptionStatus | AdministrationStatus;
  dateFrom?: Date;
  dateTo?: Date;
  isControlledSubstance?: boolean;
  prescriberId?: string;
  administeredBy?: string;
}

export interface DrugInteractionCheck {
  hasInteractions: boolean;
  interactions: DrugInteractionResult[];
  severity: InteractionSeverity;
  recommendations: string[];
}

export interface DrugInteractionResult {
  medication1: string;
  medication2: string;
  severity: InteractionSeverity;
  description: string;
  clinicalEffect: string;
  management: string;
}

export interface MedicationReconciliationResult {
  discrepancies: MedicationDiscrepancy[];
  recommendations: string[];
  requiresPharmacistReview: boolean;
}

export interface MedicationDiscrepancy {
  type: 'missing' | 'extra' | 'dosage_change' | 'frequency_change' | 'route_change';
  medication: string;
  currentValue?: string;
  expectedValue?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
}

export class MedicationValidationError extends Error {
  constructor(
    message: string,
    public validationErrors: ValidationError[]
  ) {
    super(message);
    this.name = 'MedicationValidationError';
  }
}

export class MedicationNotFoundError extends Error {
  constructor(medicationId: string) {
    super(`Medication with ID ${medicationId} not found`);
    this.name = 'MedicationNotFoundError';
  }
}

export class PrescriptionNotFoundError extends Error {
  constructor(prescriptionId: string) {
    super(`Prescription with ID ${prescriptionId} not found`);
    this.name = 'PrescriptionNotFoundError';
  }
}

export class DrugInteractionError extends Error {
  constructor(
    message: string,
    public interactions: DrugInteractionResult[]
  ) {
    super(message);
    this.name = 'DrugInteractionError';
  }
}

export class ControlledSubstanceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ControlledSubstanceError';
  }
}

export class MedicationService {
  private medicationRepository: MedicationRepository;
  private prescriptionRepository: PrescriptionRepository;
  private administrationRepository: MedicationAdministrationRepository;
  private residentRepository: Repository<Resident>;
  private drugInteractionRepository: Repository<DrugInteraction>;
  private controlledSubstanceRepository: Repository<ControlledSubstance>;

  constructor(
    private dataSource: DataSource,
    private auditService: AuditTrailService,
    private encryptionService: FieldLevelEncryptionService,
    private notificationService: NotificationService,
    private eventPublisher: EventPublishingService,
    private cacheManager: HealthcareCacheManager
  ) {
    this.medicationRepository = new MedicationRepository(dataSource);
    this.prescriptionRepository = new PrescriptionRepository(dataSource);
    this.administrationRepository = new MedicationAdministrationRepository(dataSource);
    this.residentRepository = dataSource.getRepository(Resident);
    this.drugInteractionRepository = dataSource.getRepository(DrugInteraction);
    this.controlledSubstanceRepository = dataSource.getRepository(ControlledSubstance);
  }

  /**
   * Create a new medication with comprehensive validation
   */
  async createMedication(request: CreateMedicationRequest): Promise<Medication> {
    const correlationId = `medication-create-${Date.now()}`;
    
    try {
      logger.info('Creating new medication', { 
        name: request.name,
        type: request.type,
        isControlledSubstance: request.isControlledSubstance,
        correlationId 
      });

      // Create medication entity
      const medication = new Medication();
      medication.name = request.name;
      medication.genericName = request.genericName;
      medication.brandName = request.brandName;
      medication.strength = request.strength;
      medication.form = request.form;
      medication.route = request.route;
      medication.type = request.type;
      medication.activeIngredient = request.activeIngredient;
      medication.manufacturer = request.manufacturer;
      medication.ndcCode = request.ndcCode;
      medication.isControlledSubstance = request.isControlledSubstance;
      medication.controlledSubstanceSchedule = request.controlledSubstanceSchedule;
      medication.sideEffects = request.sideEffects;
      medication.contraindications = request.contraindications;
      medication.interactions = request.interactions;
      medication.storageRequirements = request.storageRequirements;
      medication.createdBy = request.createdBy;
      medication.isActive = true;

      // Validate entity
      const validationErrors = await validate(medication);
      if (validationErrors.length > 0) {
        throw new MedicationValidationError('Medication validation failed', validationErrors);
      }

      // Validate controlled substance requirements
      if (request.isControlledSubstance && !request.controlledSubstanceSchedule) {
        throw new ControlledSubstanceError('Controlled substance schedule is required for controlled substances');
      }

      // Encrypt sensitive data
      await this.encryptSensitiveMedicationData(medication);

      // Save to database
      const savedMedication = await this.medicationRepository.create(medication);

      // Create controlled substance record if applicable
      if (request.isControlledSubstance) {
        await this.createControlledSubstanceRecord(savedMedication);
      }

      // Clear medication cache
      await this.cacheManager.invalidatePattern('medications:*');

      // Log audit trail
      await this.auditService.log({
        action: 'MEDICATION_CREATED',
        resourceType: 'Medication',
        resourceId: savedMedication.id,
        userId: request.createdBy,
        details: {
          name: request.name,
          type: request.type,
          isControlledSubstance: request.isControlledSubstance,
          correlationId
        },
        correlationId
      });

      // Publish event
      await this.eventPublisher.publish('medication.created', {
        medicationId: savedMedication.id,
        name: request.name,
        type: request.type,
        isControlledSubstance: request.isControlledSubstance,
        createdBy: request.createdBy,
        correlationId
      });

      logger.info('Medication created successfully', { 
        medicationId: savedMedication.id,
        correlationId 
      });

      return savedMedication;

    } catch (error: unknown) {
      logger.error('Failed to create medication', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        name: request.name,
        correlationId 
      });

      await this.auditService.log({
        action: 'MEDICATION_CREATE_FAILED',
        resourceType: 'Medication',
        userId: request.createdBy,
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          name: request.name,
          correlationId
        },
        correlationId
      });

      throw error;
    }
  }

  /**
   * Create a new prescription with drug interaction checking
   */
  async createPrescription(request: CreatePrescriptionRequest): Promise<Prescription> {
    const correlationId = `prescription-create-${Date.now()}`;
    
    try {
      logger.info('Creating new prescription', { 
        residentId: request.residentId,
        medicationId: request.medicationId,
        correlationId 
      });

      // Validate resident exists
      const resident = await this.residentRepository.findOne({
        where: { id: request.residentId, deletedAt: null }
      });

      if (!resident) {
        throw new Error(`Resident with ID ${request.residentId} not found`);
      }

      // Validate medication exists
      const medication = await this.medicationRepository.findById(request.medicationId);
      if (!medication) {
        throw new MedicationNotFoundError(request.medicationId);
      }

      // Check for drug interactions
      const interactionCheck = await this.checkDrugInteractions(request.residentId, request.medicationId);
      if (interactionCheck.hasInteractions && interactionCheck.severity === InteractionSeverity.SEVERE) {
        throw new DrugInteractionError(
          'Severe drug interactions detected. Prescription cannot be created without pharmacist review.',
          interactionCheck.interactions
        );
      }

      // Create prescription entity
      const prescription = new Prescription();
      prescription.residentId = request.residentId;
      prescription.medicationId = request.medicationId;
      prescription.prescriberId = request.prescriberId;
      prescription.prescriberName = request.prescriberName;
      prescription.dosage = request.dosage;
      prescription.dosageUnit = request.dosageUnit;
      prescription.frequency = request.frequency;
      prescription.route = request.route;
      prescription.startDate = request.startDate;
      prescription.endDate = request.endDate;
      prescription.instructions = request.instructions;
      prescription.quantityPrescribed = request.quantityPrescribed;
      prescription.refillsRemaining = request.refillsRemaining || 0;
      prescription.indication = request.indication;
      prescription.status = PrescriptionStatus.ACTIVE;
      prescription.createdBy = request.createdBy;

      // Validate entity
      const validationErrors = await validate(prescription);
      if (validationErrors.length > 0) {
        throw new MedicationValidationError('Prescription validation failed', validationErrors);
      }

      // Encrypt sensitive data
      await this.encryptSensitivePrescriptionData(prescription);

      // Save to database
      const savedPrescription = await this.prescriptionRepository.create(prescription);

      // Create medication administration schedule
      await this.createAdministrationSchedule(savedPrescription);

      // Clear prescription cache
      await this.cacheManager.invalidatePattern(`prescriptions:resident:${request.residentId}:*`);

      // Log audit trail
      await this.auditService.log({
        action: 'PRESCRIPTION_CREATED',
        resourceType: 'Prescription',
        resourceId: savedPrescription.id,
        userId: request.createdBy,
        details: {
          residentId: request.residentId,
          medicationId: request.medicationId,
          dosage: request.dosage,
          frequency: request.frequency,
          hasInteractions: interactionCheck.hasInteractions,
          correlationId
        },
        correlationId
      });

      // Publish event
      await this.eventPublisher.publish('prescription.created', {
        prescriptionId: savedPrescription.id,
        residentId: request.residentId,
        medicationId: request.medicationId,
        createdBy: request.createdBy,
        hasInteractions: interactionCheck.hasInteractions,
        correlationId
      });

      // Send notifications
      await this.sendPrescriptionNotifications(savedPrescription, 'created', interactionCheck);

      logger.info('Prescription created successfully', { 
        prescriptionId: savedPrescription.id,
        correlationId 
      });

      return savedPrescription;

    } catch (error: unknown) {
      logger.error('Failed to create prescription', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        residentId: request.residentId,
        medicationId: request.medicationId,
        correlationId 
      });

      await this.auditService.log({
        action: 'PRESCRIPTION_CREATE_FAILED',
        resourceType: 'Prescription',
        userId: request.createdBy,
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          residentId: request.residentId,
          medicationId: request.medicationId,
          correlationId
        },
        correlationId
      });

      throw error;
    }
  }

  /**
   * Administer medication with real-time tracking
   */
  async administerMedication(request: MedicationAdministrationRequest): Promise<MedicationAdministration> {
    const correlationId = `medication-admin-${Date.now()}`;
    
    try {
      logger.info('Administering medication', { 
        prescriptionId: request.prescriptionId,
        residentId: request.residentId,
        scheduledTime: request.scheduledTime,
        correlationId 
      });

      // Validate prescription exists and is active
      const prescription = await this.prescriptionRepository.findById(request.prescriptionId);
      if (!prescription) {
        throw new PrescriptionNotFoundError(request.prescriptionId);
      }

      if (prescription.status !== PrescriptionStatus.ACTIVE) {
        throw new Error('Cannot administer medication for inactive prescription');
      }

      // Get medication details for controlled substance check
      const medication = await this.medicationRepository.findById(prescription.medicationId);
      if (!medication) {
        throw new MedicationNotFoundError(prescription.medicationId);
      }

      // Validate witness requirement for controlled substances
      if (medication.isControlledSubstance && !request.witnessId) {
        throw new ControlledSubstanceError('Witness is required for controlled substance administration');
      }

      // Create administration record
      const administration = new MedicationAdministration();
      administration.prescriptionId = request.prescriptionId;
      administration.residentId = request.residentId;
      administration.medicationId = prescription.medicationId;
      administration.scheduledTime = request.scheduledTime;
      administration.administeredTime = new Date();
      administration.dosageGiven = request.dosageGiven || prescription.dosage;
      administration.administeredBy = request.administeredBy;
      administration.witnessId = request.witnessId;
      administration.notes = request.notes;
      administration.administrationMethod = request.administrationMethod;
      administration.siteOfAdministration = request.siteOfAdministration;
      administration.status = AdministrationStatus.ADMINISTERED;

      // Validate entity
      const validationErrors = await validate(administration);
      if (validationErrors.length > 0) {
        throw new MedicationValidationError('Medication administration validation failed', validationErrors);
      }

      // Encrypt sensitive data
      await this.encryptSensitiveAdministrationData(administration);

      // Save to database
      const savedAdministration = await this.administrationRepository.create(administration);

      // Update controlled substance inventory if applicable
      if (medication.isControlledSubstance) {
        await this.updateControlledSubstanceInventory(
          medication.id,
          administration.dosageGiven,
          'administered',
          request.administeredBy,
          request.witnessId
        );
      }

      // Clear administration cache
      await this.cacheManager.invalidatePattern(`administrations:resident:${request.residentId}:*`);

      // Log audit trail
      await this.auditService.log({
        action: 'MEDICATION_ADMINISTERED',
        resourceType: 'MedicationAdministration',
        resourceId: savedAdministration.id,
        userId: request.administeredBy,
        details: {
          prescriptionId: request.prescriptionId,
          residentId: request.residentId,
          medicationId: prescription.medicationId,
          dosageGiven: administration.dosageGiven,
          scheduledTime: request.scheduledTime,
          administeredTime: administration.administeredTime,
          witnessId: request.witnessId,
          isControlledSubstance: medication.isControlledSubstance,
          correlationId
        },
        correlationId
      });

      // Publish event
      await this.eventPublisher.publish('medication.administered', {
        administrationId: savedAdministration.id,
        prescriptionId: request.prescriptionId,
        residentId: request.residentId,
        medicationId: prescription.medicationId,
        administeredBy: request.administeredBy,
        witnessId: request.witnessId,
        isControlledSubstance: medication.isControlledSubstance,
        correlationId
      });

      // Send notifications for missed doses or late administration
      await this.checkAndNotifyAdministrationTiming(savedAdministration);

      logger.info('Medication administered successfully', { 
        administrationId: savedAdministration.id,
        correlationId 
      });

      return savedAdministration;

    } catch (error: unknown) {
      logger.error('Failed to administer medication', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        prescriptionId: request.prescriptionId,
        residentId: request.residentId,
        correlationId 
      });

      await this.auditService.log({
        action: 'MEDICATION_ADMINISTRATION_FAILED',
        resourceType: 'MedicationAdministration',
        userId: request.administeredBy,
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          prescriptionId: request.prescriptionId,
          residentId: request.residentId,
          correlationId
        },
        correlationId
      });

      throw error;
    }
  }

  /**
   * Check for drug interactions
   */
  async checkDrugInteractions(residentId: string, newMedicationId: string): Promise<DrugInteractionCheck> {
    try {
      logger.debug('Checking drug interactions', { residentId, newMedicationId });

      // Get current active prescriptions for resident
      const activePrescriptions = await this.prescriptionRepository.findActiveByResidentId(residentId);
      
      // Get current medication IDs
      const currentMedicationIds = activePrescriptions.map(p => p.medicationId);
      
      // Check interactions between new medication and current medications
      const interactions: DrugInteractionResult[] = [];
      let maxSeverity = InteractionSeverity.MINOR;

      for (const currentMedicationId of currentMedicationIds) {
        const interaction = await this.drugInteractionRepository.findOne({
          where: [
            { medication1Id: newMedicationId, medication2Id: currentMedicationId },
            { medication1Id: currentMedicationId, medication2Id: newMedicationId }
          ]
        });

        if (interaction) {
          const medication1 = await this.medicationRepository.findById(interaction.medication1Id);
          const medication2 = await this.medicationRepository.findById(interaction.medication2Id);

          interactions.push({
            medication1: medication1?.name || 'Unknown',
            medication2: medication2?.name || 'Unknown',
            severity: interaction.severity,
            description: interaction.description,
            clinicalEffect: interaction.clinicalEffect,
            management: interaction.management
          });

          // Track highest severity
          if (interaction.severity === InteractionSeverity.SEVERE) {
            maxSeverity = InteractionSeverity.SEVERE;
          } else if (interaction.severity === InteractionSeverity.MODERATE && maxSeverity !== InteractionSeverity.SEVERE) {
            maxSeverity = InteractionSeverity.MODERATE;
          }
        }
      }

      // Generate recommendations
      const recommendations = this.generateInteractionRecommendations(interactions);

      const result: DrugInteractionCheck = {
        hasInteractions: interactions.length > 0,
        interactions,
        severity: maxSeverity,
        recommendations
      };

      logger.debug('Drug interaction check completed', { 
        residentId,
        newMedicationId,
        hasInteractions: result.hasInteractions,
        severity: result.severity,
        interactionCount: interactions.length
      });

      return result;

    } catch (error: unknown) {
      logger.error('Failed to check drug interactions', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        residentId,
        newMedicationId 
      });
      throw error;
    }
  }

  /**
   * Perform medication reconciliation
   */
  async performMedicationReconciliation(
    residentId: string,
    admissionMedications: any[],
    performedBy: string
  ): Promise<MedicationReconciliationResult> {
    const correlationId = `med-reconciliation-${Date.now()}`;
    
    try {
      logger.info('Performing medication reconciliation', { 
        residentId,
        admissionMedicationCount: admissionMedications.length,
        correlationId 
      });

      // Get current active prescriptions
      const currentPrescriptions = await this.prescriptionRepository.findActiveByResidentId(residentId);
      
      // Compare admission medications with current prescriptions
      const discrepancies: MedicationDiscrepancy[] = [];
      
      // Check for missing medications
      for (const admissionMed of admissionMedications) {
        const matchingPrescription = currentPrescriptions.find(p => 
          p.medication?.name.toLowerCase() === admissionMed.name.toLowerCase()
        );
        
        if (!matchingPrescription) {
          discrepancies.push({
            type: 'missing',
            medication: admissionMed.name,
            expectedValue: `${admissionMed.dosage} ${admissionMed.frequency}`,
            severity: this.assessDiscrepancySeverity(admissionMed),
            description: `Medication ${admissionMed.name} from admission list is not in current prescriptions`
          });
        } else {
          // Check for dosage discrepancies
          if (matchingPrescription.dosage !== admissionMed.dosage) {
            discrepancies.push({
              type: 'dosage_change',
              medication: admissionMed.name,
              currentValue: `${matchingPrescription.dosage} ${matchingPrescription.dosageUnit}`,
              expectedValue: `${admissionMed.dosage} ${admissionMed.dosageUnit}`,
              severity: this.assessDosageDiscrepancySeverity(matchingPrescription.dosage, admissionMed.dosage),
              description: `Dosage discrepancy for ${admissionMed.name}`
            });
          }
          
          // Check for frequency discrepancies
          if (matchingPrescription.frequency !== admissionMed.frequency) {
            discrepancies.push({
              type: 'frequency_change',
              medication: admissionMed.name,
              currentValue: matchingPrescription.frequency,
              expectedValue: admissionMed.frequency,
              severity: 'medium',
              description: `Frequency discrepancy for ${admissionMed.name}`
            });
          }
        }
      }
      
      // Check for extra medications
      for (const currentPrescription of currentPrescriptions) {
        const matchingAdmissionMed = admissionMedications.find(m => 
          m.name.toLowerCase() === currentPrescription.medication?.name.toLowerCase()
        );
        
        if (!matchingAdmissionMed) {
          discrepancies.push({
            type: 'extra',
            medication: currentPrescription.medication?.name || 'Unknown',
            currentValue: `${currentPrescription.dosage} ${currentPrescription.frequency}`,
            severity: 'medium',
            description: `Medication ${currentPrescription.medication?.name} in current prescriptions but not in admission list`
          });
        }
      }

      // Generate recommendations
      const recommendations = this.generateReconciliationRecommendations(discrepancies);
      
      // Determine if pharmacist review is required
      const requiresPharmacistReview = discrepancies.some(d => 
        d.severity === 'high' || d.severity === 'critical'
      );

      const result: MedicationReconciliationResult = {
        discrepancies,
        recommendations,
        requiresPharmacistReview
      };

      // Log audit trail
      await this.auditService.log({
        action: 'MEDICATION_RECONCILIATION_PERFORMED',
        resourceType: 'MedicationReconciliation',
        resourceId: residentId,
        userId: performedBy,
        details: {
          discrepancyCount: discrepancies.length,
          requiresPharmacistReview,
          correlationId
        },
        correlationId
      });

      // Publish event
      await this.eventPublisher.publish('medication.reconciliation.completed', {
        residentId,
        discrepancyCount: discrepancies.length,
        requiresPharmacistReview,
        performedBy,
        correlationId
      });

      // Send notifications if pharmacist review required
      if (requiresPharmacistReview) {
        await this.notificationService.sendNotification({
          type: 'medication_reconciliation_review_required',
          recipientType: 'pharmacist',
          residentId,
          title: 'Medication Reconciliation Review Required',
          message: `Medication reconciliation for resident requires pharmacist review due to ${discrepancies.length} discrepancies`,
          data: {
            residentId,
            discrepancyCount: discrepancies.length,
            highSeverityCount: discrepancies.filter(d => d.severity === 'high' || d.severity === 'critical').length
          }
        });
      }

      logger.info('Medication reconciliation completed', { 
        residentId,
        discrepancyCount: discrepancies.length,
        requiresPharmacistReview,
        correlationId 
      });

      return result;

    } catch (error: unknown) {
      logger.error('Failed to perform medication reconciliation', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        residentId,
        correlationId 
      });
      throw error;
    }
  }

  /**
   * Get medication administration record (MAR) for resident
   */
  async getMedicationAdministrationRecord(
    residentId: string,
    dateFrom: Date,
    dateTo: Date
  ): Promise<MedicationAdministration[]> {
    try {
      logger.debug('Getting medication administration record', { 
        residentId,
        dateFrom,
        dateTo 
      });

      // Check cache first
      const cacheKey = `mar:${residentId}:${dateFrom.toISOString()}:${dateTo.toISOString()}`;
      const cachedResult = await this.cacheManager.get(cacheKey);
      
      if (cachedResult) {
        logger.debug('MAR retrieved from cache', { residentId });
        return cachedResult;
      }

      // Get from database
      const administrations = await this.administrationRepository.findByResidentAndDateRange(
        residentId,
        dateFrom,
        dateTo
      );

      // Decrypt sensitive data
      for (const administration of administrations) {
        await this.decryptSensitiveAdministrationData(administration);
      }

      // Cache result for 15 minutes
      await this.cacheManager.set(cacheKey, administrations, 900);

      logger.debug('MAR retrieved from database', { 
        residentId,
        recordCount: administrations.length 
      });

      return administrations;

    } catch (error: unknown) {
      logger.error('Failed to get medication administration record', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        residentId 
      });
      throw error;
    }
  }

  /**
   * Get controlled substance report
   */
  async getControlledSubstanceReport(
    dateFrom: Date,
    dateTo: Date,
    facilityId?: string
  ): Promise<any> {
    const correlationId = `controlled-substance-report-${Date.now()}`;
    
    try {
      logger.info('Generating controlled substance report', { 
        dateFrom,
        dateTo,
        facilityId,
        correlationId 
      });

      // Get controlled substance administrations
      const administrations = await this.administrationRepository.findControlledSubstanceAdministrations(
        dateFrom,
        dateTo,
        facilityId
      );

      // Get controlled substance inventory movements
      const inventoryMovements = await this.controlledSubstanceRepository.find({
        where: {
          createdAt: {
            $gte: dateFrom,
            $lte: dateTo
          } as any
        },
        order: {
          createdAt: 'ASC'
        }
      });

      // Generate report data
      const report = {
        reportPeriod: {
          from: dateFrom,
          to: dateTo
        },
        summary: {
          totalAdministrations: administrations.length,
          totalInventoryMovements: inventoryMovements.length,
          medicationsInvolved: [...new Set(administrations.map(a => a.medicationId))].length
        },
        administrations: administrations.map(admin => ({
          id: admin.id,
          residentId: admin.residentId,
          medicationName: admin.medication?.name,
          dosageGiven: admin.dosageGiven,
          administeredTime: admin.administeredTime,
          administeredBy: admin.administeredBy,
          witnessId: admin.witnessId,
          schedule: admin.medication?.controlledSubstanceSchedule
        })),
        inventoryMovements: inventoryMovements.map(movement => ({
          id: movement.id,
          medicationId: movement.medicationId,
          movementType: movement.movementType,
          quantity: movement.quantity,
          balanceAfter: movement.balanceAfter,
          performedBy: movement.performedBy,
          witnessId: movement.witnessId,
          timestamp: movement.createdAt
        })),
        generatedAt: new Date(),
        generatedBy: 'system',
        correlationId
      };

      // Log audit trail
      await this.auditService.log({
        action: 'CONTROLLED_SUBSTANCE_REPORT_GENERATED',
        resourceType: 'ControlledSubstanceReport',
        userId: 'system',
        details: {
          dateFrom,
          dateTo,
          facilityId,
          administrationCount: administrations.length,
          inventoryMovementCount: inventoryMovements.length,
          correlationId
        },
        correlationId
      });

      logger.info('Controlled substance report generated', { 
        administrationCount: administrations.length,
        inventoryMovementCount: inventoryMovements.length,
        correlationId 
      });

      return report;

    } catch (error: unknown) {
      logger.error('Failed to generate controlled substance report', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        dateFrom,
        dateTo,
        correlationId 
      });
      throw error;
    }
  }

  // Private helper methods

  private async encryptSensitiveMedicationData(medication: Medication): Promise<void> {
    if (medication.sideEffects) {
      medication.sideEffects = await Promise.all(
        medication.sideEffects.map(effect => this.encryptionService.encrypt(effect))
      );
    }
    
    if (medication.contraindications) {
      medication.contraindications = await Promise.all(
        medication.contraindications.map(contra => this.encryptionService.encrypt(contra))
      );
    }
  }

  private async encryptSensitivePrescriptionData(prescription: Prescription): Promise<void> {
    if (prescription.instructions) {
      prescription.instructions = await this.encryptionService.encrypt(prescription.instructions);
    }
    
    if (prescription.indication) {
      prescription.indication = await this.encryptionService.encrypt(prescription.indication);
    }
  }

  private async encryptSensitiveAdministrationData(administration: MedicationAdministration): Promise<void> {
    if (administration.notes) {
      administration.notes = await this.encryptionService.encrypt(administration.notes);
    }
  }

  private async decryptSensitiveAdministrationData(administration: MedicationAdministration): Promise<void> {
    if (administration.notes) {
      administration.notes = await this.encryptionService.decrypt(administration.notes);
    }
  }

  private async createControlledSubstanceRecord(medication: Medication): Promise<void> {
    const controlledSubstance = new ControlledSubstance();
    controlledSubstance.medicationId = medication.id;
    controlledSubstance.schedule = medication.controlledSubstanceSchedule!;
    controlledSubstance.currentStock = 0;
    controlledSubstance.minimumStock = 10; // Default minimum
    controlledSubstance.lastStockCheck = new Date();
    
    await this.controlledSubstanceRepository.save(controlledSubstance);
  }

  private async createAdministrationSchedule(prescription: Prescription): Promise<void> {
    // This would create scheduled administration records based on frequency
    // Implementation would depend on specific scheduling requirements
    logger.debug('Creating administration schedule', { prescriptionId: prescription.id });
  }

  private async updateControlledSubstanceInventory(
    medicationId: string,
    quantity: number,
    movementType: string,
    performedBy: string,
    witnessId?: string
  ): Promise<void> {
    // Update controlled substance inventory
    logger.debug('Updating controlled substance inventory', { 
      medicationId,
      quantity,
      movementType 
    });
  }

  private async sendPrescriptionNotifications(
    prescription: Prescription,
    action: string,
    interactionCheck: DrugInteractionCheck
  ): Promise<void> {
    // Send notifications based on prescription action and interactions
    if (interactionCheck.hasInteractions) {
      await this.notificationService.sendNotification({
        type: 'drug_interaction_detected',
        recipientType: 'pharmacist',
        residentId: prescription.residentId,
        title: 'Drug Interaction Detected',
        message: `Drug interactions detected for new prescription`,
        data: {
          prescriptionId: prescription.id,
          severity: interactionCheck.severity,
          interactionCount: interactionCheck.interactions.length
        }
      });
    }
  }

  private async checkAndNotifyAdministrationTiming(administration: MedicationAdministration): Promise<void> {
    // Check if administration was late and send notifications if needed
    const timeDifference = administration.administeredTime!.getTime() - administration.scheduledTime.getTime();
    const minutesLate = Math.floor(timeDifference / (1000 * 60));
    
    if (minutesLate > 30) { // More than 30 minutes late
      await this.notificationService.sendNotification({
        type: 'late_medication_administration',
        recipientType: 'nurse_manager',
        residentId: administration.residentId,
        title: 'Late Medication Administration',
        message: `Medication administered ${minutesLate} minutes late`,
        data: {
          administrationId: administration.id,
          minutesLate,
          scheduledTime: administration.scheduledTime,
          administeredTime: administration.administeredTime
        }
      });
    }
  }

  private generateInteractionRecommendations(interactions: DrugInteractionResult[]): string[] {
    const recommendations: string[] = [];
    
    if (interactions.length === 0) {
      recommendations.push('No drug interactions detected');
      return recommendations;
    }

    const severeInteractions = interactions.filter(i => i.severity === InteractionSeverity.SEVERE);
    const moderateInteractions = interactions.filter(i => i.severity === InteractionSeverity.MODERATE);

    if (severeInteractions.length > 0) {
      recommendations.push('Severe interactions detected - pharmacist review required before administration');
      recommendations.push('Consider alternative medications or dosage adjustments');
    }

    if (moderateInteractions.length > 0) {
      recommendations.push('Monitor patient closely for interaction effects');
      recommendations.push('Consider timing adjustments between medication administrations');
    }

    recommendations.push('Document all interactions in patient record');
    
    return recommendations;
  }

  private generateReconciliationRecommendations(discrepancies: MedicationDiscrepancy[]): string[] {
    const recommendations: string[] = [];
    
    if (discrepancies.length === 0) {
      recommendations.push('No medication discrepancies found');
      return recommendations;
    }

    const criticalDiscrepancies = discrepancies.filter(d => d.severity === 'critical');
    const highDiscrepancies = discrepancies.filter(d => d.severity === 'high');

    if (criticalDiscrepancies.length > 0) {
      recommendations.push('Critical discrepancies require immediate pharmacist review');
      recommendations.push('Hold affected medications until review is complete');
    }

    if (highDiscrepancies.length > 0) {
      recommendations.push('High-priority discrepancies require pharmacist review within 24 hours');
    }

    recommendations.push('Update medication orders based on reconciliation findings');
    recommendations.push('Document all changes in patient record');
    
    return recommendations;
  }

  private assessDiscrepancySeverity(medication: any): 'low' | 'medium' | 'high' | 'critical' {
    // Assess severity based on medication type and clinical importance
    if (medication.isControlledSubstance || medication.type === 'cardiac' || medication.type === 'anticoagulant') {
      return 'critical';
    }
    
    if (medication.type === 'diabetes' || medication.type === 'psychiatric') {
      return 'high';
    }
    
    return 'medium';
  }

  private assessDosageDiscrepancySeverity(currentDosage: number, expectedDosage: number): 'low' | 'medium' | 'high' | 'critical' {
    const percentageDifference = Math.abs((currentDosage - expectedDosage) / expectedDosage) * 100;
    
    if (percentageDifference > 50) {
      return 'critical';
    } else if (percentageDifference > 25) {
      return 'high';
    } else if (percentageDifference > 10) {
      return 'medium';
    }
    
    return 'low';
  }
}