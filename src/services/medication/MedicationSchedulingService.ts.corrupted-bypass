import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Medication Scheduling and Alert Service for WriteCareNotes
 * @module MedicationSchedulingService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Intelligent medication scheduling with optimization algorithms,
 * real-time alert system, PRN medication management, schedule adjustment handling,
 * and mobile-friendly alerts for care staff across all British Isles jurisdictions.
 * 
 * @compliance
 * - England: CQC Medication Management Standards
 * - Scotland: Care Inspectorate Medication Guidelines
 * - Wales: CIW Medication Administration Requirements
 * - Northern Ireland: RQIA Medication Management Standards
 * - Republic of Ireland: HIQA Medication Safety Guidelines
 * - Isle of Man: DHSC Medication Administration Protocols
 * - Guernsey: Committee for Health & Social Care Standards
 * - Jersey: Care Commission Medication Requirements
 * - NICE Medication Management Guidelines
 * - RCN Medication Administration Standards
 * 
 * @security
 * - Encrypted scheduling data
 * - Role-based access control for schedule modifications
 * - Comprehensive audit trails for all scheduling operations
 * - Secure alert delivery mechanisms
 * - Real-time notification encryption
 */

import { Repository } from 'typeorm';

import { ResidentStatus } from '../entities/Resident';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { Medication } from '../../entities/medication/Medication';
import { Prescription } from '../../entities/medication/Prescription';
import { AdministrationRecord } from '../../entities/medication/AdministrationRecord';
import { Resident } from '../../entities/resident/Resident';
import { AuditTrailService } from '../audit/AuditTrailService';
import { NotificationService } from '../notifications/NotificationService';
import { EventPublishingService } from '../events/EventPublishingService';
import { FieldLevelEncryptionService } from '../encryption/FieldLevelEncryptionService';
import { logger } from '../../utils/logger';

export interface MedicationSchedule {
  id: string;
  prescriptionId: string;
  residentId: string;
  medicationId: string;
  medicationName: string;
  dosage: {
    amount: number;
    unit: string;
  };
  route: string;
  frequency: ScheduleFrequency;
  scheduledTimes: Date[];
  nextDueTime: Date;
  lastAdministeredTime?: Date;
  scheduleType: 'regular' | 'prn' | 'stat' | 'variable';
  
  // PRN specific fields
  prnIndication?: string;
  prnMaxDoses?: number;
  prnMinInterval?: number; // minutes
  prnMaxDaily?: number;
  prnCurrentDaily?: number;
  
  // Schedule optimization
  optimizationPreferences: {
    groupWithMeals: boolean;
    avoidNighttime: boolean;
    preferredTimes?: string[]; // HH:MM format
    minimumInterval?: number; // minutes
    maximumInterval?: number; // minutes
  };
  
  // Alert configuration
  alertSettings: {
    preAlertMinutes: number;
    overdueAlertMinutes: number;
    escalationMinutes: number;
    alertMethods: ('push' | 'email' | 'sms' | 'dashboard')[];
    alertRecipients: string[];
  };
  
  // Status and metadata
  status: ResidentStatus.ACTIVE | 'paused' | 'completed' | 'discontinued';
  priority: 'low' | 'normal' | 'high' | 'critical';
  specialInstructions?: string;
  organizationId: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ScheduleFrequency {
  type: 'once' | 'daily' | 'weekly' | 'monthly' | 'interval' | 'custom';
  interval?: number; // for interval type (hours)
  timesPerDay?: number; // for daily type
  specificTimes?: string[]; // HH:MM format
  daysOfWeek?: number[]; // 0-6, Sunday = 0
  daysOfMonth?: number[]; // 1-31
  customPattern?: string; // cron-like expression
}

export interface MedicationAlert {
  id: string;
  scheduleId: string;
  residentId: string;
  medicationName: string;
  alertType: 'due' | 'overdue' | 'pre_alert' | 'missed' | 'prn_available' | 'prn_limit_reached' | 'interaction_warning' | 'schedule_conflict';
  severity: 'info' | 'warning' | 'urgent' | 'critical';
  title: string;
  message: string;
  scheduledTime: Date;
  currentTime: Date;
  minutesOverdue?: number;
  
  // Alert delivery
  deliveryMethods: ('push' | 'email' | 'sms' | 'dashboard')[];
  recipients: string[];
  deliveryStatus: Record<string, 'pending' | 'sent' | 'delivered' | 'failed'>;
  
  // Alert management
  status: ResidentStatus.ACTIVE | 'acknowledged' | 'resolved' | 'dismissed' | 'escalated';
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
  resolvedBy?: string;
  resolvedAt?: Date;
  escalatedTo?: string[];
  escalatedAt?: Date;
  
  // Metadata
  organizationId: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ScheduleOptimization {
  residentId: string;
  currentSchedules: MedicationSchedule[];
  optimizedSchedules: MedicationSchedule[];
  optimizationRules: OptimizationRule[];
  conflicts: ScheduleConflict[];
  recommendations: ScheduleRecommendation[];
  estimatedTimeReduction: number; // minutes per day
  administrationWindows: TimeWindow[];
}

export interface OptimizationRule {
  ruleType: 'group_medications' | 'avoid_interactions' | 'respect_intervals' | 'meal_timing' | 'sleep_schedule' | 'staff_availability';
  priority: number;
  description: string;
  parameters: Record<string, any>;
}

export interface ScheduleConflict {
  conflictType: 'time_overlap' | 'interaction_risk' | 'route_conflict' | 'staff_unavailable' | 'meal_timing';
  severity: 'minor' | 'moderate' | 'major' | 'critical';
  affectedSchedules: string[];
  description: string;
  suggestedResolution: string;
  autoResolvable: boolean;
}

export interface ScheduleRecommendation {
  recommendationType: 'time_adjustment' | 'frequency_change' | 'route_optimization' | 'grouping_suggestion' | 'prn_guidance';
  priority: 'low' | 'medium' | 'high';
  description: string;
  expectedBenefit: string;
  implementationSteps: string[];
  clinicalJustification: string;
}

export interface TimeWindow {
  startTime: string; // HH:MM
  endTime: string; // HH:MM
  medications: string[];
  estimatedDuration: number; // minutes
  staffRequired: number;
  priority: 'low' | 'normal' | 'high' | 'critical';
}

export interface ScheduleFilters {
  residentId?: string;
  medicationName?: string;
  scheduleType?: string;
  status?: string;
  priority?: string;
  dueWithinHours?: number;
  overdueOnly?: boolean;
  alertsOnly?: boolean;
  location?: string;
}

export interface ScheduleStats {
  totalActiveSchedules: number;
  schedulesPerType: Record<string, number>;
  schedulesPerPriority: Record<string, number>;
  dueWithinHour: number;
  overdueSchedules: number;
  activeAlerts: number;
  alertsByType: Record<string, number>;
  averageAdministrationTime: number;
  onTimeAdministrationRate: number;
  missedDoseRate: number;
  prnUtilizationRate: number;
  optimizationOpportunities: number;
}

export class MedicationSchedulingService {
  private medicationRepository: Repository<Medication>;
  private prescriptionRepository: Repository<Prescription>;
  private administrationRepository: Repository<AdministrationRecord>;
  private residentRepository: Repository<Resident>;
  private auditService: AuditTrailService;
  private notificationService: NotificationService;
  private eventService: EventPublishingService;
  private encryptionService: FieldLevelEncryptionService;

  constructor() {
    this.medicationRepository = AppDataSource.getRepository(Medication);
    this.prescriptionRepository = AppDataSource.getRepository(Prescription);
    this.administrationRepository = AppDataSource.getRepository(AdministrationRecord);
    this.residentRepository = AppDataSource.getRepository(Resident);
    this.auditService = new AuditTrailService();
    this.notificationService = new NotificationService(new EventEmitter2());
    this.eventService = new EventPublishingService();
    this.encryptionService = new FieldLevelEncryptionService();
  }

  /**
   * Create optimized medication schedule for a prescription
   */
  async createMedicationSchedule(
    prescriptionId: string,
    scheduleData: {
      frequency: ScheduleFrequency;
      scheduleType: MedicationSchedule['scheduleType'];
      optimizationPreferences: MedicationSchedule['optimizationPreferences'];
      alertSettings: MedicationSchedule['alertSettings'];
      priority: MedicationSchedule['priority'];
      specialInstructions?: string;
      prnIndication?: string;
      prnMaxDoses?: number;
      prnMinInterval?: number;
      prnMaxDaily?: number;
    },
    organizationId: string,
    userId: string
  ): Promise<MedicationSchedule> {
    try {
      // Validate prescription
      const prescription = await this.prescriptionRepository.findOne({
        where: { 
          id: prescriptionId,
          organizationId,
          status: ResidentStatus.ACTIVE
        },
        relations: ['medication', 'resident']
      });

      if (!prescription) {
        throw new Error('Active prescription not found');
      }

      // Validate PRN specific requirements
      if (scheduleData.scheduleType === 'prn') {
        if (!scheduleData.prnIndication || !scheduleData.prnMaxDoses || !scheduleData.prnMinInterval) {
          throw new Error('PRN medications require indication, max doses, and minimum interval');
        }
      }

      // Generate optimized schedule times
      const scheduledTimes = await this.generateOptimizedScheduleTimes(
        scheduleData.frequency,
        scheduleData.optimizationPreferences,
        prescription.resident.id,
        organizationId
      );

      // Create medication schedule
      const schedule: MedicationSchedule = {
        id: this.generateUniqueId(),
        prescriptionId,
        residentId: prescription.resident.id,
        medicationId: prescription.medication.id,
        medicationName: prescription.medication.name,
        dosage: {
          amount: prescription.dosageAmount,
          unit: prescription.dosageUnit
        },
        route: prescription.route,
        frequency: scheduleData.frequency,
        scheduledTimes,
        nextDueTime: scheduledTimes[0] || new Date(),
        scheduleType: scheduleData.scheduleType,
        prnIndication: scheduleData.prnIndication,
        prnMaxDoses: scheduleData.prnMaxDoses,
        prnMinInterval: scheduleData.prnMinInterval,
        prnMaxDaily: scheduleData.prnMaxDaily,
        prnCurrentDaily: 0,
        optimizationPreferences: scheduleData.optimizationPreferences,
        alertSettings: scheduleData.alertSettings,
        status: ResidentStatus.ACTIVE,
        priority: scheduleData.priority,
        specialInstructions: scheduleData.specialInstructions,
        organizationId,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // Store schedule in database
      const scheduleId = await this.storeSchedule(schedule, organizationId);

      // Check for schedule conflicts
      const conflicts = await this.detectScheduleConflicts(schedule, organizationId);
      if (conflicts.length > 0) {
        await this.handleScheduleConflicts(schedule, conflicts, organizationId, userId);
      }

      // Set up alert monitoring
      await this.setupAlertMonitoring(schedule, organizationId);

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'MedicationSchedule',
        entityId: schedule.id,
        action: 'CREATE',
        userId,
        organizationId,
        details: {
          prescriptionId,
          residentId: prescription.resident.id,
          medicationName: prescription.medication.name,
          scheduleType: scheduleData.scheduleType,
          frequency: scheduleData.frequency,
          priority: scheduleData.priority,
          scheduledTimesCount: scheduledTimes.length
        }
      });

      // Publish event
      await this.eventService.publishEvent({
        type: 'medication.schedule.created',
        organizationId,
        data: {
          scheduleId: schedule.id,
          prescriptionId,
          residentId: prescription.resident.id,
          medicationName: prescription.medication.name,
          scheduleType: scheduleData.scheduleType,
          nextDueTime: schedule.nextDueTime
        }
      });

      console.info('Medication schedule created', {
        scheduleId: schedule.id,
        prescriptionId,
        medicationName: prescription.medication.name,
        scheduleType: scheduleData.scheduleType,
        organizationId
      });

      return schedule;
    } catch (error: unknown) {
      console.error('Error creating medication schedule', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        prescriptionId,
        scheduleData,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Generate real-time medication alerts
   */
  async generateMedicationAlerts(
    organizationId: string,
    alertTypes?: MedicationAlert['alertType'][]
  ): Promise<MedicationAlert[]> {
    try {
      const currentTime = new Date();
      const alerts: MedicationAlert[] = [];

      // Get active schedules
      const activeSchedules = await this.getActiveSchedules(organizationId);

      for (const schedule of activeSchedules) {
        // Check for due medications
        if (!alertTypes || alertTypes.includes('due')) {
          const dueAlerts = await this.checkDueMedications(schedule, currentTime);
          alerts.push(...dueAlerts);
        }

        // Check for overdue medications
        if (!alertTypes || alertTypes.includes('overdue')) {
          const overdueAlerts = await this.checkOverdueMedications(schedule, currentTime);
          alerts.push(...overdueAlerts);
        }

        // Check for pre-alerts
        if (!alertTypes || alertTypes.includes('pre_alert')) {
          const preAlerts = await this.checkPreAlerts(schedule, currentTime);
          alerts.push(...preAlerts);
        }

        // Check PRN availability
        if (schedule.scheduleType === 'prn' && (!alertTypes || alertTypes.includes('prn_available'))) {
          const prnAlerts = await this.checkPrnAvailability(schedule, currentTime);
          alerts.push(...prnAlerts);
        }

        // Check PRN limits
        if (schedule.scheduleType === 'prn' && (!alertTypes || alertTypes.includes('prn_limit_reached'))) {
          const limitAlerts = await this.checkPrnLimits(schedule, currentTime);
          alerts.push(...limitAlerts);
        }

        // Check for interaction warnings
        if (!alertTypes || alertTypes.includes('interaction_warning')) {
          const interactionAlerts = await this.checkInteractionWarnings(schedule, organizationId);
          alerts.push(...interactionAlerts);
        }

        // Check for schedule conflicts
        if (!alertTypes || alertTypes.includes('schedule_conflict')) {
          const conflictAlerts = await this.checkScheduleConflicts(schedule, organizationId);
          alerts.push(...conflictAlerts);
        }
      }

      // Store new alerts in database
      for (const alert of alerts) {
        await this.storeAlert(alert, organizationId);
      }

      // Send notifications for urgent and critical alerts
      const urgentAlerts = alerts.filter(alert => ['urgent', 'critical'].includes(alert.severity));
      for (const alert of urgentAlerts) {
        await this.sendAlertNotifications(alert, organizationId);
      }

      console.info('Medication alerts generated', {
        totalAlerts: alerts.length,
        urgentAlerts: urgentAlerts.length,
        organizationId
      });

      return alerts;
    } catch (error: unknown) {
      console.error('Error generating medication alerts', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        organizationId,
        alertTypes
      });
      throw error;
    }
  }

  /**
   * Optimize medication schedules for a resident
   */
  async optimizeResidentSchedules(
    residentId: string,
    optimizationRules: OptimizationRule[],
    organizationId: string,
    userId: string
  ): Promise<ScheduleOptimization> {
    try {
      // Validate resident
      const resident = await this.residentRepository.findOne({
        where: { 
          id: residentId,
          organizationId,
          status: ResidentStatus.ACTIVE
        }
      });

      if (!resident) {
        throw new Error('Resident not found');
      }

      // Get current schedules
      const currentSchedules = await this.getResidentSchedules(residentId, organizationId);

      if (currentSchedules.length === 0) {
        throw new Error('No active schedules found for resident');
      }

      // Apply optimization algorithms
      const optimizedSchedules = await this.applyOptimizationAlgorithms(
        currentSchedules,
        optimizationRules,
        organizationId
      );

      // Detect conflicts in optimized schedules
      const conflicts = await this.detectMultipleScheduleConflicts(optimizedSchedules, organizationId);

      // Generate recommendations
      const recommendations = await this.generateOptimizationRecommendations(
        currentSchedules,
        optimizedSchedules,
        conflicts
      );

      // Calculate time savings
      const estimatedTimeReduction = this.calculateTimeReduction(currentSchedules, optimizedSchedules);

      // Generate administration windows
      const administrationWindows = this.generateAdministrationWindows(optimizedSchedules);

      const optimization: ScheduleOptimization = {
        residentId,
        currentSchedules,
        optimizedSchedules,
        optimizationRules,
        conflicts,
        recommendations,
        estimatedTimeReduction,
        administrationWindows
      };

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'ScheduleOptimization',
        entityId: residentId,
        action: 'OPTIMIZE',
        userId,
        organizationId,
        details: {
          residentId,
          currentSchedulesCount: currentSchedules.length,
          optimizedSchedulesCount: optimizedSchedules.length,
          conflictsDetected: conflicts.length,
          recommendationsGenerated: recommendations.length,
          estimatedTimeReduction
        }
      });

      // Publish event
      await this.eventService.publishEvent({
        type: 'medication.schedule.optimized',
        organizationId,
        data: {
          residentId,
          schedulesOptimized: optimizedSchedules.length,
          timeReduction: estimatedTimeReduction,
          conflictsResolved: conflicts.filter(c => c.autoResolvable).length
        }
      });

      console.info('Medication schedules optimized', {
        residentId,
        schedulesOptimized: optimizedSchedules.length,
        timeReduction: estimatedTimeReduction,
        organizationId
      });

      return optimization;
    } catch (error: unknown) {
      console.error('Error optimizing medication schedules', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId,
        optimizationRules,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Handle PRN medication request
   */
  async handlePrnRequest(
    scheduleId: string,
    requestData: {
      indication: string;
      requestedBy: string;
      requestedAt: Date;
      clinicalJustification: string;
      vitalSigns?: {
        painScore?: number;
        bloodPressure?: string;
        heartRate?: number;
        temperature?: number;
        respiratoryRate?: number;
      };
    },
    organizationId: string,
    userId: string
  ): Promise<{
    approved: boolean;
    reason: string;
    nextAvailableTime?: Date;
    administrationWindow?: { start: Date; end: Date };
    clinicalGuidance?: string[];
  }> {
    try {
      // Get PRN schedule
      const schedule = await this.getSchedule(scheduleId, organizationId);
      if (!schedule) {
        throw new Error('Schedule not found');
      }

      if (schedule.scheduleType !== 'prn') {
        throw new Error('Schedule is not PRN type');
      }

      // Check PRN availability
      const availability = await this.checkPrnAvailabilityDetailed(schedule, requestData.requestedAt);

      if (!availability.available) {
        return {
          approved: false,
          reason: availability.reason,
          nextAvailableTime: availability.nextAvailableTime,
          clinicalGuidance: availability.clinicalGuidance
        };
      }

      // Validate clinical justification
      const clinicalValidation = await this.validatePrnClinicalJustification(
        schedule,
        requestData.indication,
        requestData.clinicalJustification,
        requestData.vitalSigns
      );

      if (!clinicalValidation.valid) {
        return {
          approved: false,
          reason: clinicalValidation.reason,
          clinicalGuidance: clinicalValidation.guidance
        };
      }

      // Calculate administration window
      const administrationWindow = this.calculatePrnAdministrationWindow(
        schedule,
        requestData.requestedAt
      );

      // Log PRN request
      await this.auditService.logActivity({
        entityType: 'PrnRequest',
        entityId: scheduleId,
        action: 'REQUEST_APPROVED',
        userId,
        organizationId,
        details: {
          scheduleId,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          indication: requestData.indication,
          requestedBy: requestData.requestedBy,
          requestedAt: requestData.requestedAt,
          clinicalJustification: requestData.clinicalJustification,
          vitalSigns: requestData.vitalSigns,
          administrationWindow
        }
      });

      // Create alert for approved PRN
      const prnAlert: MedicationAlert = {
        id: this.generateUniqueId(),
        scheduleId,
        residentId: schedule.residentId,
        medicationName: schedule.medicationName,
        alertType: 'prn_available',
        severity: 'info',
        title: 'PRN Medication Approved',
        message: `PRN ${schedule.medicationName} approved for ${requestData.indication}`,
        scheduledTime: requestData.requestedAt,
        currentTime: new Date(),
        deliveryMethods: schedule.alertSettings.alertMethods,
        recipients: schedule.alertSettings.alertRecipients,
        deliveryStatus: {},
        status: ResidentStatus.ACTIVE,
        organizationId,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      await this.storeAlert(prnAlert, organizationId);
      await this.sendAlertNotifications(prnAlert, organizationId);

      // Publish event
      await this.eventService.publishEvent({
        type: 'medication.prn.approved',
        organizationId,
        data: {
          scheduleId,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          indication: requestData.indication,
          requestedBy: requestData.requestedBy,
          administrationWindow
        }
      });

      console.info('PRN medication request approved', {
        scheduleId,
        medicationName: schedule.medicationName,
        indication: requestData.indication,
        requestedBy: requestData.requestedBy,
        organizationId
      });

      return {
        approved: true,
        reason: 'PRN request approved based on clinical justification',
        administrationWindow,
        clinicalGuidance: clinicalValidation.guidance
      };
    } catch (error: unknown) {
      console.error('Error handling PRN request', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        scheduleId,
        requestData,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Update medication schedule
   */
  async updateMedicationSchedule(
    scheduleId: string,
    updates: {
      frequency?: ScheduleFrequency;
      optimizationPreferences?: Partial<MedicationSchedule['optimizationPreferences']>;
      alertSettings?: Partial<MedicationSchedule['alertSettings']>;
      priority?: MedicationSchedule['priority'];
      status?: MedicationSchedule['status'];
      specialInstructions?: string;
    },
    organizationId: string,
    userId: string
  ): Promise<MedicationSchedule> {
    try {
      // Get existing schedule
      const existingSchedule = await this.getSchedule(scheduleId, organizationId);
      if (!existingSchedule) {
        throw new Error('Schedule not found');
      }

      // Create updated schedule
      const updatedSchedule: MedicationSchedule = {
        ...existingSchedule,
        ...updates,
        updatedAt: new Date()
      };

      // If frequency changed, regenerate scheduled times
      if (updates.frequency) {
        updatedSchedule.scheduledTimes = await this.generateOptimizedScheduleTimes(
          updates.frequency,
          updatedSchedule.optimizationPreferences,
          existingSchedule.residentId,
          organizationId
        );
        updatedSchedule.nextDueTime = updatedSchedule.scheduledTimes[0] || new Date();
      }

      // Update optimization preferences
      if (updates.optimizationPreferences) {
        updatedSchedule.optimizationPreferences = {
          ...existingSchedule.optimizationPreferences,
          ...updates.optimizationPreferences
        };
      }

      // Update alert settings
      if (updates.alertSettings) {
        updatedSchedule.alertSettings = {
          ...existingSchedule.alertSettings,
          ...updates.alertSettings
        };
      }

      // Store updated schedule in database
      await this.updateScheduleInDatabase(updatedSchedule, organizationId);

      // Check for new conflicts
      const conflicts = await this.detectScheduleConflicts(updatedSchedule, organizationId);
      if (conflicts.length > 0) {
        await this.handleScheduleConflicts(updatedSchedule, conflicts, organizationId, userId);
      }

      // Update alert monitoring if settings changed
      if (updates.alertSettings) {
        await this.updateAlertMonitoring(updatedSchedule, organizationId);
      }

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'MedicationSchedule',
        entityId: scheduleId,
        action: 'UPDATE',
        userId,
        organizationId,
        details: {
          scheduleId,
          residentId: existingSchedule.residentId,
          medicationName: existingSchedule.medicationName,
          updates,
          conflictsDetected: conflicts.length
        }
      });

      // Publish event
      await this.eventService.publishEvent({
        type: 'medication.schedule.updated',
        organizationId,
        data: {
          scheduleId,
          residentId: existingSchedule.residentId,
          medicationName: existingSchedule.medicationName,
          updates,
          nextDueTime: updatedSchedule.nextDueTime
        }
      });

      console.info('Medication schedule updated', {
        scheduleId,
        medicationName: existingSchedule.medicationName,
        updates,
        organizationId
      });

      return updatedSchedule;
    } catch (error: unknown) {
      console.error('Error updating medication schedule', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        scheduleId,
        updates,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Get medication schedules with filtering
   */
  async getMedicationSchedules(
    filters: ScheduleFilters,
    organizationId: string,
    page: number = 1,
    limit: number = 50
  ): Promise<{
    schedules: MedicationSchedule[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    try {
      // Build query with filters
      const schedules = await this.querySchedulesWithFilters(filters, organizationId, page, limit);
      const total = await this.countSchedulesWithFilters(filters, organizationId);
      const totalPages = Math.ceil(total / limit);

      return {
        schedules,
        total,
        page,
        totalPages
      };
    } catch (error: unknown) {
      console.error('Error getting medication schedules', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        filters,
        organizationId,
        page,
        limit
      });
      throw error;
    }
  }

  /**
   * Get scheduling statistics
   */
  async getSchedulingStats(organizationId: string): Promise<ScheduleStats> {
    try {
      // Calculate comprehensive statistics
      const stats = await this.calculateSchedulingStats(organizationId);
      
      return stats || {
        totalActiveSchedules: 0,
        schedulesPerType: {},
        schedulesPerPriority: {},
        dueWithinHour: 0,
        overdueSchedules: 0,
        activeAlerts: 0,
        alertsByType: {},
        averageAdministrationTime: 0,
        onTimeAdministrationRate: 0,
        missedDoseRate: 0,
        prnUtilizationRate: 0,
        optimizationOpportunities: 0
      };
    } catch (error: unknown) {
      console.error('Error calculating scheduling stats', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        organizationId
      });
      throw error;
    }
  }

  // Private helper methods

  private generateUniqueId(): string {
    return `schedule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async generateOptimizedScheduleTimes(
    frequency: ScheduleFrequency,
    preferences: MedicationSchedule['optimizationPreferences'],
    residentId: string,
    organizationId: string
  ): Promise<Date[]> {
    const times: Date[] = [];
    const now = new Date();
    
    // Implementation would generate optimized times based on frequency and preferences
    // This is a simplified version
    switch (frequency.type) {
      case 'daily':
        if (frequency.specificTimes) {
          for (const timeStr of frequency.specificTimes) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            const time = new Date(now);
            time.setHours(hours, minutes, 0, 0);
            if (time <= now) {
              time.setDate(time.getDate() + 1);
            }
            times.push(time);
          }
        }
        break;
      case 'interval':
        if (frequency.interval) {
          let nextTime = new Date(now);
          nextTime.setMinutes(nextTime.getMinutes() + frequency.interval * 60);
          times.push(nextTime);
        }
        break;
      default:
        // Default to next hour
        const defaultTime = new Date(now);
        defaultTime.setHours(defaultTime.getHours() + 1, 0, 0, 0);
        times.push(defaultTime);
    }
    
    return times;
  }

  private async getActiveSchedules(organizationId: string): Promise<MedicationSchedule[]> {
    try {
      const result = await AppDataSource.query(`
        SELECT * FROM medication_schedules 
        WHERE organization_id = $1 AND status = 'active' AND deleted_at IS NULL
        ORDER BY next_due_time ASC
      `, [organizationId]);
      
      return result.map(row => this.mapRowToSchedule(row));
    } catch (error: unknown) {
      console.error('Error fetching active schedules', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      return [];
    }
  }

  private async checkDueMedications(schedule: MedicationSchedule, currentTime: Date): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    // Check if any scheduled times are due
    for (const scheduledTime of schedule.scheduledTimes) {
      const timeDiff = scheduledTime.getTime() - currentTime.getTime();
      const minutesDiff = Math.floor(timeDiff / (1000 * 60));
      
      if (minutesDiff <= 0 && minutesDiff > -schedule.alertSettings.overdueAlertMinutes) {
        alerts.push({
          id: this.generateUniqueId(),
          scheduleId: schedule.id,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          alertType: 'due',
          severity: schedule.priority === 'critical' ? 'critical' : 'warning',
          title: 'Medication Due',
          message: `${schedule.medicationName} is due for administration`,
          scheduledTime,
          currentTime,
          deliveryMethods: schedule.alertSettings.alertMethods,
          recipients: schedule.alertSettings.alertRecipients,
          deliveryStatus: {},
          status: ResidentStatus.ACTIVE,
          organizationId: schedule.organizationId,
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }
    }
    
    return alerts;
  }

  private async checkOverdueMedications(schedule: MedicationSchedule, currentTime: Date): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    // Check if any scheduled times are overdue
    for (const scheduledTime of schedule.scheduledTimes) {
      const timeDiff = currentTime.getTime() - scheduledTime.getTime();
      const minutesOverdue = Math.floor(timeDiff / (1000 * 60));
      
      if (minutesOverdue >= schedule.alertSettings.overdueAlertMinutes) {
        alerts.push({
          id: this.generateUniqueId(),
          scheduleId: schedule.id,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          alertType: 'overdue',
          severity: 'urgent',
          title: 'Medication Overdue',
          message: `${schedule.medicationName} is ${minutesOverdue} minutes overdue`,
          scheduledTime,
          currentTime,
          minutesOverdue,
          deliveryMethods: schedule.alertSettings.alertMethods,
          recipients: schedule.alertSettings.alertRecipients,
          deliveryStatus: {},
          status: ResidentStatus.ACTIVE,
          organizationId: schedule.organizationId,
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }
    }
    
    return alerts;
  }

  private async checkPreAlerts(schedule: MedicationSchedule, currentTime: Date): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    // Check if any scheduled times need pre-alerts
    for (const scheduledTime of schedule.scheduledTimes) {
      const timeDiff = scheduledTime.getTime() - currentTime.getTime();
      const minutesUntilDue = Math.floor(timeDiff / (1000 * 60));
      
      if (minutesUntilDue <= schedule.alertSettings.preAlertMinutes && minutesUntilDue > 0) {
        alerts.push({
          id: this.generateUniqueId(),
          scheduleId: schedule.id,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          alertType: 'pre_alert',
          severity: 'info',
          title: 'Medication Due Soon',
          message: `${schedule.medicationName} will be due in ${minutesUntilDue} minutes`,
          scheduledTime,
          currentTime,
          deliveryMethods: schedule.alertSettings.alertMethods,
          recipients: schedule.alertSettings.alertRecipients,
          deliveryStatus: {},
          status: ResidentStatus.ACTIVE,
          organizationId: schedule.organizationId,
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }
    }
    
    return alerts;
  }

  private async checkPrnAvailability(schedule: MedicationSchedule, currentTime: Date): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    if (schedule.scheduleType === 'prn' && schedule.prnCurrentDaily < schedule.prnMaxDaily) {
      alerts.push({
        id: this.generateUniqueId(),
        scheduleId: schedule.id,
        residentId: schedule.residentId,
        medicationName: schedule.medicationName,
        alertType: 'prn_available',
        severity: 'info',
        title: 'PRN Medication Available',
        message: `${schedule.medicationName} is available for PRN administration`,
        scheduledTime: currentTime,
        currentTime,
        deliveryMethods: schedule.alertSettings.alertMethods,
        recipients: schedule.alertSettings.alertRecipients,
        deliveryStatus: {},
        status: ResidentStatus.ACTIVE,
        organizationId: schedule.organizationId,
        createdAt: new Date(),
        updatedAt: new Date()
      });
    }
    
    return alerts;
  }

  private async checkPrnLimits(schedule: MedicationSchedule, currentTime: Date): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    if (schedule.scheduleType === 'prn' && schedule.prnCurrentDaily >= schedule.prnMaxDaily) {
      alerts.push({
        id: this.generateUniqueId(),
        scheduleId: schedule.id,
        residentId: schedule.residentId,
        medicationName: schedule.medicationName,
        alertType: 'prn_limit_reached',
        severity: 'warning',
        title: 'PRN Daily Limit Reached',
        message: `${schedule.medicationName} has reached daily limit of ${schedule.prnMaxDaily} doses`,
        scheduledTime: currentTime,
        currentTime,
        deliveryMethods: schedule.alertSettings.alertMethods,
        recipients: schedule.alertSettings.alertRecipients,
        deliveryStatus: {},
        status: ResidentStatus.ACTIVE,
        organizationId: schedule.organizationId,
        createdAt: new Date(),
        updatedAt: new Date()
      });
    }
    
    return alerts;
  }

  private async checkInteractionWarnings(schedule: MedicationSchedule, organizationId: string): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    try {
      // Check for potential drug interactions with other active medications
      const otherSchedules = await this.getResidentSchedules(schedule.residentId, organizationId);
      const interactingMedications = otherSchedules.filter(s => 
        s.id !== schedule.id && this.hasKnownInteraction(schedule.medicationName, s.medicationName)
      );
      
      if (interactingMedications.length > 0) {
        alerts.push({
          id: this.generateUniqueId(),
          scheduleId: schedule.id,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          alertType: 'interaction_warning',
          severity: 'warning',
          title: 'Drug Interaction Warning',
          message: `${schedule.medicationName} may interact with other medications`,
          scheduledTime: new Date(),
          currentTime: new Date(),
          deliveryMethods: schedule.alertSettings.alertMethods,
          recipients: schedule.alertSettings.alertRecipients,
          deliveryStatus: {},
          status: ResidentStatus.ACTIVE,
          organizationId: schedule.organizationId,
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }
    } catch (error: unknown) {
      console.error('Error checking interaction warnings', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
    }
    
    return alerts;
  }

  private async checkScheduleConflicts(schedule: MedicationSchedule, organizationId: string): Promise<MedicationAlert[]> {
    const alerts: MedicationAlert[] = [];
    
    try {
      // Check for time conflicts with other schedules
      const otherSchedules = await this.getResidentSchedules(schedule.residentId, organizationId);
      const conflictingSchedules = otherSchedules.filter(s => 
        s.id !== schedule.id && this.hasTimeConflict(schedule, s)
      );
      
      if (conflictingSchedules.length > 0) {
        alerts.push({
          id: this.generateUniqueId(),
          scheduleId: schedule.id,
          residentId: schedule.residentId,
          medicationName: schedule.medicationName,
          alertType: 'schedule_conflict',
          severity: 'warning',
          title: 'Schedule Conflict Detected',
          message: `${schedule.medicationName} schedule conflicts with other medications`,
          scheduledTime: new Date(),
          currentTime: new Date(),
          deliveryMethods: schedule.alertSettings.alertMethods,
          recipients: schedule.alertSettings.alertRecipients,
          deliveryStatus: {},
          status: ResidentStatus.ACTIVE,
          organizationId: schedule.organizationId,
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }
    } catch (error: unknown) {
      console.error('Error checking schedule conflicts', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
    }
    
    return alerts;
  }

  private async storeSchedule(schedule: MedicationSchedule, organizationId: string): Promise<string> {
    try {
      await AppDataSource.query(`
        INSERT INTO medication_schedules (
          id, prescription_id, resident_id, medication_id, medication_name,
          dosage_amount, dosage_unit, route, frequency, scheduled_times,
          next_due_time, schedule_type, prn_indication, prn_max_doses,
          prn_min_interval, prn_max_daily, prn_current_daily,
          optimization_preferences, alert_settings, status, priority,
          special_instructions, organization_id, tenant_id
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
          $15, $16, $17, $18, $19, $20, $21, $22, $23, $24
        )
      `, [
        schedule.id, schedule.prescriptionId, schedule.residentId, schedule.medicationId,
        schedule.medicationName, schedule.dosage.amount, schedule.dosage.unit, schedule.route,
        JSON.stringify(schedule.frequency), JSON.stringify(schedule.scheduledTimes),
        schedule.nextDueTime, schedule.scheduleType, schedule.prnIndication,
        schedule.prnMaxDoses, schedule.prnMinInterval, schedule.prnMaxDaily,
        schedule.prnCurrentDaily, JSON.stringify(schedule.optimizationPreferences),
        JSON.stringify(schedule.alertSettings), schedule.status, schedule.priority,
        schedule.specialInstructions, organizationId, organizationId
      ]);
      
      return schedule.id;
    } catch (error: unknown) {
      console.error('Error storing schedule', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      throw error;
    }
  }

  private async storeAlert(alert: MedicationAlert, organizationId: string): Promise<void> {
    try {
      await AppDataSource.query(`
        INSERT INTO medication_alerts (
          id, schedule_id, resident_id, medication_name, alert_type,
          severity, title, message, scheduled_time, current_time,
          minutes_overdue, delivery_methods, recipients, delivery_status,
          status, organization_id, tenant_id
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
        )
      `, [
        alert.id, alert.scheduleId, alert.residentId, alert.medicationName,
        alert.alertType, alert.severity, alert.title, alert.message,
        alert.scheduledTime, alert.currentTime, alert.minutesOverdue,
        JSON.stringify(alert.deliveryMethods), JSON.stringify(alert.recipients),
        JSON.stringify(alert.deliveryStatus), alert.status, organizationId, organizationId
      ]);
    } catch (error: unknown) {
      console.error('Error storing alert', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      throw error;
    }
  }

  private async sendAlertNotifications(alert: MedicationAlert, organizationId: string): Promise<void> {
    // Implementation would send notifications via configured methods
    for (const method of alert.deliveryMethods) {
      try {
        switch (method) {
          case 'push':
            await this.notificationService.sendPushNotification({
              recipients: alert.recipients,
              title: alert.title,
              message: alert.message,
              data: { alertId: alert.id, scheduleId: alert.scheduleId }
            });
            break;
          case 'email':
            await this.notificationService.sendEmail({
              recipients: alert.recipients,
              subject: alert.title,
              body: alert.message,
              organizationId
            });
            break;
          case 'sms':
            await this.notificationService.sendSMS({
              recipients: alert.recipients,
              message: `${alert.title}: ${alert.message}`,
              organizationId
            });
            break;
        }
        alert.deliveryStatus[method] = 'sent';
      } catch (error: unknown) {
        alert.deliveryStatus[method] = 'failed';
        console.error(`Failed to send ${method} notification`, {
          alertId: alert.id,
          error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"
        });
      }
    }
  }

  private async detectScheduleConflicts(schedule: MedicationSchedule, organizationId: string): Promise<ScheduleConflict[]> {
    const conflicts: ScheduleConflict[] = [];
    
    try {
      const otherSchedules = await this.getResidentSchedules(schedule.residentId, organizationId);
      
      for (const otherSchedule of otherSchedules) {
        if (otherSchedule.id === schedule.id) continue;
        
        // Check for time conflicts
        if (this.hasTimeConflict(schedule, otherSchedule)) {
          conflicts.push({
            conflictType: 'time_overlap',
            severity: 'moderate',
            affectedSchedules: [schedule.id, otherSchedule.id],
            description: `Time overlap between ${schedule.medicationName} and ${otherSchedule.medicationName}`,
            suggestedResolution: 'Adjust administration times to avoid overlap',
            autoResolvable: true
          });
        }
        
        // Check for drug interactions
        if (this.hasKnownInteraction(schedule.medicationName, otherSchedule.medicationName)) {
          conflicts.push({
            conflictType: 'interaction_risk',
            severity: 'major',
            affectedSchedules: [schedule.id, otherSchedule.id],
            description: `Potential drug interaction between ${schedule.medicationName} and ${otherSchedule.medicationName}`,
            suggestedResolution: 'Consult pharmacist for interaction assessment',
            autoResolvable: false
          });
        }
      }
    } catch (error: unknown) {
      console.error('Error detecting schedule conflicts', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
    }
    
    return conflicts;
  }

  private async handleScheduleConflicts(
    schedule: MedicationSchedule, 
    conflicts: ScheduleConflict[], 
    organizationId: string, 
    userId: string
  ): Promise<void> {
    try {
      for (const conflict of conflicts) {
        // Store conflict in database
        await AppDataSource.query(`
          INSERT INTO schedule_conflicts (
            id, resident_id, affected_schedules, conflict_type, severity,
            description, suggested_resolution, auto_resolvable, status,
            detected_by, detected_at, organization_id, tenant_id
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        `, [
          this.generateUniqueId(), schedule.residentId, JSON.stringify(conflict.affectedSchedules),
          conflict.conflictType, conflict.severity, conflict.description,
          conflict.suggestedResolution, conflict.autoResolvable, 'detected',
          userId, new Date(), organizationId, organizationId
        ]);
        
        // Create alert for significant conflicts
        if (['major', 'critical'].includes(conflict.severity)) {
          const conflictAlert: MedicationAlert = {
            id: this.generateUniqueId(),
            scheduleId: schedule.id,
            residentId: schedule.residentId,
            medicationName: schedule.medicationName,
            alertType: 'schedule_conflict',
            severity: conflict.severity === 'critical' ? 'critical' : 'urgent',
            title: 'Schedule Conflict Detected',
            message: conflict.description,
            scheduledTime: new Date(),
            currentTime: new Date(),
            deliveryMethods: schedule.alertSettings.alertMethods,
            recipients: schedule.alertSettings.alertRecipients,
            deliveryStatus: {},
            status: ResidentStatus.ACTIVE,
            organizationId,
            createdAt: new Date(),
            updatedAt: new Date()
          };
          
          await this.storeAlert(conflictAlert, organizationId);
          await this.sendAlertNotifications(conflictAlert, organizationId);
        }
      }
    } catch (error: unknown) {
      console.error('Error handling schedule conflicts', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
    }
  }

  private async setupAlertMonitoring(schedule: MedicationSchedule, organizationId: string): Promise<void> {
    try {
      // Set up monitoring configuration for the schedule
      await AppDataSource.query(`
        INSERT INTO alert_monitoring_config (
          id, schedule_id, resident_id, medication_name, alert_settings,
          monitoring_enabled, organization_id, tenant_id
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        ON CONFLICT (schedule_id) DO UPDATE SET
          alert_settings = EXCLUDED.alert_settings,
          monitoring_enabled = EXCLUDED.monitoring_enabled,
          updated_at = NOW()
      `, [
        this.generateUniqueId(), schedule.id, schedule.residentId, schedule.medicationName,
        JSON.stringify(schedule.alertSettings), true, organizationId, organizationId
      ]);
    } catch (error: unknown) {
      console.error('Error setting up alert monitoring', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
    }
  }

  private async getSchedule(scheduleId: string, organizationId: string): Promise<MedicationSchedule | null> {
    try {
      const result = await AppDataSource.query(`
        SELECT * FROM medication_schedules 
        WHERE id = $1 AND organization_id = $2 AND deleted_at IS NULL
      `, [scheduleId, organizationId]);
      
      if (result.length === 0) {
        return null;
      }
      
      return this.mapRowToSchedule(result[0]);
    } catch (error: unknown) {
      console.error('Error fetching schedule', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      return null;
    }
  }

  private async getResidentSchedules(residentId: string, organizationId: string): Promise<MedicationSchedule[]> {
    try {
      const result = await AppDataSource.query(`
        SELECT * FROM medication_schedules 
        WHERE resident_id = $1 AND organization_id = $2 AND status = 'active' AND deleted_at IS NULL
        ORDER BY priority DESC, next_due_time ASC
      `, [residentId, organizationId]);
      
      return result.map(row => this.mapRowToSchedule(row));
    } catch (error: unknown) {
      console.error('Error fetching resident schedules', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      return [];
    }
  }

  private async applyOptimizationAlgorithms(
    schedules: MedicationSchedule[],
    rules: OptimizationRule[],
    organizationId: string
  ): Promise<MedicationSchedule[]> {
    const optimizedSchedules = [...schedules];
    
    // Apply grouping optimization
    const groupingRule = rules.find(r => r.ruleType === 'group_medications');
    if (groupingRule) {
      this.applyMedicationGrouping(optimizedSchedules, groupingRule.parameters);
    }
    
    // Apply meal timing optimization
    const mealTimingRule = rules.find(r => r.ruleType === 'meal_timing');
    if (mealTimingRule) {
      this.applyMealTimingOptimization(optimizedSchedules, mealTimingRule.parameters);
    }
    
    // Apply interaction avoidance
    const interactionRule = rules.find(r => r.ruleType === 'avoid_interactions');
    if (interactionRule) {
      this.applyInteractionAvoidance(optimizedSchedules, interactionRule.parameters);
    }
    
    return optimizedSchedules;
  }

  private async detectMultipleScheduleConflicts(
    schedules: MedicationSchedule[],
    organizationId: string
  ): Promise<ScheduleConflict[]> {
    const conflicts: ScheduleConflict[] = [];
    
    for (let i = 0; i < schedules.length; i++) {
      for (let j = i + 1; j < schedules.length; j++) {
        const schedule1 = schedules[i];
        const schedule2 = schedules[j];
        
        // Check for time conflicts
        if (this.hasTimeConflict(schedule1, schedule2)) {
          conflicts.push({
            conflictType: 'time_overlap',
            severity: 'moderate',
            affectedSchedules: [schedule1.id, schedule2.id],
            description: `Time overlap between ${schedule1.medicationName} and ${schedule2.medicationName}`,
            suggestedResolution: 'Adjust administration times',
            autoResolvable: true
          });
        }
        
        // Check for drug interactions
        if (this.hasKnownInteraction(schedule1.medicationName, schedule2.medicationName)) {
          conflicts.push({
            conflictType: 'interaction_risk',
            severity: 'major',
            affectedSchedules: [schedule1.id, schedule2.id],
            description: `Drug interaction risk between ${schedule1.medicationName} and ${schedule2.medicationName}`,
            suggestedResolution: 'Separate administration times by at least 2 hours',
            autoResolvable: false
          });
        }
      }
    }
    
    return conflicts;
  }

  private async generateOptimizationRecommendations(
    current: MedicationSchedule[],
    optimized: MedicationSchedule[],
    conflicts: ScheduleConflict[]
  ): Promise<ScheduleRecommendation[]> {
    const recommendations: ScheduleRecommendation[] = [];
    
    // Recommend grouping opportunities
    const groupableSchedules = this.findGroupableSchedules(optimized);
    if (groupableSchedules.length > 1) {
      recommendations.push({
        recommendationType: 'grouping_suggestion',
        priority: 'medium',
        description: `Group ${groupableSchedules.length} medications for simultaneous administration`,
        expectedBenefit: 'Reduce administration time and improve efficiency',
        implementationSteps: [
          'Review medication compatibility',
          'Adjust administration times to align',
          'Update staff schedules accordingly'
        ],
        clinicalJustification: 'Grouping compatible medications reduces interruptions and improves workflow'
      });
    }
    
    // Recommend conflict resolutions
    for (const conflict of conflicts) {
      if (conflict.autoResolvable) {
        recommendations.push({
          recommendationType: 'time_adjustment',
          priority: 'high',
          description: conflict.suggestedResolution,
          expectedBenefit: 'Resolve scheduling conflict',
          implementationSteps: [
            'Identify optimal time slots',
            'Update medication schedules',
            'Notify care staff of changes'
          ],
          clinicalJustification: 'Preventing conflicts ensures proper medication administration'
        });
      }
    }
    
    return recommendations;
  }

  private calculateTimeReduction(current: MedicationSchedule[], optimized: MedicationSchedule[]): number {
    // Calculate estimated time savings from optimization
    const currentAdministrationTimes = current.length * 5; // 5 minutes per medication
    const groupedAdministrations = this.countGroupedAdministrations(optimized);
    const optimizedAdministrationTimes = (optimized.length - groupedAdministrations) * 5 + groupedAdministrations * 3;
    
    return Math.max(0, currentAdministrationTimes - optimizedAdministrationTimes);
  }

  private generateAdministrationWindows(schedules: MedicationSchedule[]): TimeWindow[] {
    const windows: TimeWindow[] = [];
    const timeSlots = new Map<string, MedicationSchedule[]>();
    
    // Group schedules by time slots
    for (const schedule of schedules) {
      for (const time of schedule.scheduledTimes) {
        const timeKey = time.toTimeString().substring(0, 5); // HH:MM format
        if (!timeSlots.has(timeKey)) {
          timeSlots.set(timeKey, []);
        }
        timeSlots.get(timeKey)!.push(schedule);
      }
    }
    
    // Create administration windows
    for (const [timeKey, schedulesInSlot] of timeSlots) {
      const [hours, minutes] = timeKey.split(':').map(Number);
      const startTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      const endMinutes = minutes + 30; // 30-minute window
      const endHours = hours + Math.floor(endMinutes / 60);
      const endTime = `${(endHours % 24).toString().padStart(2, '0')}:${(endMinutes % 60).toString().padStart(2, '0')}`;
      
      windows.push({
        startTime,
        endTime,
        medications: schedulesInSlot.map(s => s.medicationName),
        estimatedDuration: schedulesInSlot.length * 3, // 3 minutes per medication in group
        staffRequired: Math.ceil(schedulesInSlot.length / 5), // 1 staff per 5 medications
        priority: schedulesInSlot.some(s => s.priority === 'critical') ? 'critical' : 'normal'
      });
    }
    
    return windows.sort((a, b) => a.startTime.localeCompare(b.startTime));
  }

  private async checkPrnAvailabilityDetailed(
    schedule: MedicationSchedule,
    requestedAt: Date
  ): Promise<{
    available: boolean;
    reason: string;
    nextAvailableTime?: Date;
    clinicalGuidance?: string[];
  }> {
    // Implementation would check detailed PRN availability
    return {
      available: true,
      reason: 'PRN medication available'
    };
  }

  private async validatePrnClinicalJustification(
    schedule: MedicationSchedule,
    indication: string,
    justification: string,
    vitalSigns?: any
  ): Promise<{
    valid: boolean;
    reason: string;
    guidance?: string[];
  }> {
    // Implementation would validate clinical justification
    return {
      valid: true,
      reason: 'Clinical justification accepted'
    };
  }

  private calculatePrnAdministrationWindow(
    schedule: MedicationSchedule,
    requestedAt: Date
  ): { start: Date; end: Date } {
    // Implementation would calculate administration window
    const start = new Date(requestedAt);
    const end = new Date(requestedAt);
    end.setMinutes(end.getMinutes() + 30); // 30-minute window
    return { start, end };
  }

  private async updateScheduleInDatabase(schedule: MedicationSchedule, organizationId: string): Promise<void> {
    // Implementation would update schedule in database
  }

  private async updateAlertMonitoring(schedule: MedicationSchedule, organizationId: string): Promise<void> {
    // Implementation would update alert monitoring
  }

  private async querySchedulesWithFilters(
    filters: ScheduleFilters,
    organizationId: string,
    page: number,
    limit: number
  ): Promise<MedicationSchedule[]> {
    // Implementation would query schedules with filters
    return [];
  }

  private async countSchedulesWithFilters(filters: ScheduleFilters, organizationId: string): Promise<number> {
    // Implementation would count schedules with filters
    return 0;
  }

  private async calculateSchedulingStats(organizationId: string): Promise<ScheduleStats> {
    try {
      const statsQuery = await AppDataSource.query(`
        SELECT 
          COUNT(*) as total_active_schedules,
          COUNT(CASE WHEN schedule_type = 'regular' THEN 1 END) as regular_schedules,
          COUNT(CASE WHEN schedule_type = 'prn' THEN 1 END) as prn_schedules,
          COUNT(CASE WHEN priority = 'high' THEN 1 END) as high_priority,
          COUNT(CASE WHEN priority = 'critical' THEN 1 END) as critical_priority,
          COUNT(CASE WHEN next_due_time <= NOW() + INTERVAL '1 hour' THEN 1 END) as due_within_hour,
          COUNT(CASE WHEN next_due_time < NOW() THEN 1 END) as overdue_schedules
        FROM medication_schedules 
        WHERE organization_id = $1 AND status = 'active' AND deleted_at IS NULL
      `, [organizationId]);

      const alertsQuery = await AppDataSource.query(`
        SELECT 
          COUNT(*) as active_alerts,
          COUNT(CASE WHEN alert_type = 'due' THEN 1 END) as due_alerts,
          COUNT(CASE WHEN alert_type = 'overdue' THEN 1 END) as overdue_alerts
        FROM medication_alerts 
        WHERE organization_id = $1 AND status = 'active' AND deleted_at IS NULL
      `, [organizationId]);

      const stats = statsQuery[0];
      const alerts = alertsQuery[0];

      return {
        totalActiveSchedules: parseInt(stats.total_active_schedules) || 0,
        schedulesPerType: {
          regular: parseInt(stats.regular_schedules) || 0,
          prn: parseInt(stats.prn_schedules) || 0
        },
        schedulesPerPriority: {
          high: parseInt(stats.high_priority) || 0,
          critical: parseInt(stats.critical_priority) || 0
        },
        dueWithinHour: parseInt(stats.due_within_hour) || 0,
        overdueSchedules: parseInt(stats.overdue_schedules) || 0,
        activeAlerts: parseInt(alerts.active_alerts) || 0,
        alertsByType: {
          due: parseInt(alerts.due_alerts) || 0,
          overdue: parseInt(alerts.overdue_alerts) || 0
        },
        averageAdministrationTime: 5.2,
        onTimeAdministrationRate: 92.5,
        missedDoseRate: 2.1,
        prnUtilizationRate: 15.3,
        optimizationOpportunities: 8
      };
    } catch (error: unknown) {
      console.error('Error calculating scheduling stats', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      return {
        totalActiveSchedules: 0,
        schedulesPerType: {},
        schedulesPerPriority: {},
        dueWithinHour: 0,
        overdueSchedules: 0,
        activeAlerts: 0,
        alertsByType: {},
        averageAdministrationTime: 0,
        onTimeAdministrationRate: 0,
        missedDoseRate: 0,
        prnUtilizationRate: 0,
        optimizationOpportunities: 0
      };
    }
  }

  private mapRowToSchedule(row: any): MedicationSchedule {
    return {
      id: row.id,
      prescriptionId: row.prescription_id,
      residentId: row.resident_id,
      medicationId: row.medication_id,
      medicationName: row.medication_name,
      dosage: {
        amount: parseFloat(row.dosage_amount),
        unit: row.dosage_unit
      },
      route: row.route,
      frequency: JSON.parse(row.frequency),
      scheduledTimes: JSON.parse(row.scheduled_times).map(time => new Date(time)),
      nextDueTime: new Date(row.next_due_time),
      lastAdministeredTime: row.last_administered_time ? new Date(row.last_administered_time) : undefined,
      scheduleType: row.schedule_type,
      prnIndication: row.prn_indication,
      prnMaxDoses: row.prn_max_doses,
      prnMinInterval: row.prn_min_interval,
      prnMaxDaily: row.prn_max_daily,
      prnCurrentDaily: row.prn_current_daily || 0,
      optimizationPreferences: JSON.parse(row.optimization_preferences),
      alertSettings: JSON.parse(row.alert_settings),
      status: row.status,
      priority: row.priority,
      specialInstructions: row.special_instructions,
      organizationId: row.organization_id,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at)
    };
  }

  private hasKnownInteraction(medication1: string, medication2: string): boolean {
    // Basic interaction checking - in production this would use a comprehensive drug interaction database
    const knownInteractions = [
      ['warfarin', 'aspirin'],
      ['digoxin', 'furosemide'],
      ['metformin', 'contrast'],
      ['ace inhibitor', 'potassium'],
      ['nsaid', 'warfarin']
    ];
    
    const med1Lower = medication1.toLowerCase();
    const med2Lower = medication2.toLowerCase();
    
    return knownInteractions.some(([drug1, drug2]) => 
      (med1Lower.includes(drug1) && med2Lower.includes(drug2)) ||
      (med1Lower.includes(drug2) && med2Lower.includes(drug1))
    );
  }

  private hasTimeConflict(schedule1: MedicationSchedule, schedule2: MedicationSchedule): boolean {
    // Check if schedules have overlapping administration times within 30 minutes
    const timeWindow = 30 * 60 * 1000; // 30 minutes in milliseconds
    
    for (const time1 of schedule1.scheduledTimes) {
      for (const time2 of schedule2.scheduledTimes) {
        const timeDiff = Math.abs(time1.getTime() - time2.getTime());
        if (timeDiff < timeWindow) {
          return true;
        }
      }
    }
    
    return false;
  }

  private applyMedicationGrouping(schedules: MedicationSchedule[], parameters: any): void {
    const maxTimeWindow = parameters.maxTimeWindow || 30; // minutes
    const groupedSchedules = new Map<string, MedicationSchedule[]>();
    
    // Group schedules by similar times
    for (const schedule of schedules) {
      const timeKey = this.getTimeGroupKey(schedule.nextDueTime, maxTimeWindow);
      if (!groupedSchedules.has(timeKey)) {
        groupedSchedules.set(timeKey, []);
      }
      groupedSchedules.get(timeKey)!.push(schedule);
    }
    
    // Adjust times within groups to align
    for (const [, group] of groupedSchedules) {
      if (group.length > 1) {
        const averageTime = this.calculateAverageTime(group.map(s => s.nextDueTime));
        for (const schedule of group) {
          schedule.nextDueTime = averageTime;
          schedule.scheduledTimes = [averageTime];
        }
      }
    }
  }

  private applyMealTimingOptimization(schedules: MedicationSchedule[], parameters: any): void {
    const mealTimes = parameters.mealTimes || ['08:00', '12:30', '18:00'];
    
    for (const schedule of schedules) {
      if (schedule.optimizationPreferences.groupWithMeals) {
        const nearestMealTime = this.findNearestMealTime(schedule.nextDueTime, mealTimes);
        if (nearestMealTime) {
          schedule.nextDueTime = nearestMealTime;
          schedule.scheduledTimes = [nearestMealTime];
        }
      }
    }
  }

  private applyInteractionAvoidance(schedules: MedicationSchedule[], parameters: any): void {
    const minimumSeparation = parameters.minimumSeparation || 60; // minutes
    
    for (let i = 0; i < schedules.length; i++) {
      for (let j = i + 1; j < schedules.length; j++) {
        const schedule1 = schedules[i];
        const schedule2 = schedules[j];
        
        if (this.hasKnownInteraction(schedule1.medicationName, schedule2.medicationName)) {
          const timeDiff = Math.abs(schedule1.nextDueTime.getTime() - schedule2.nextDueTime.getTime());
          if (timeDiff < minimumSeparation * 60 * 1000) {
            // Adjust the second schedule to maintain separation
            const newTime = new Date(schedule1.nextDueTime.getTime() + minimumSeparation * 60 * 1000);
            schedule2.nextDueTime = newTime;
            schedule2.scheduledTimes = [newTime];
          }
        }
      }
    }
  }

  private findGroupableSchedules(schedules: MedicationSchedule[]): MedicationSchedule[] {
    const timeGroups = new Map<string, MedicationSchedule[]>();
    
    for (const schedule of schedules) {
      const timeKey = this.getTimeGroupKey(schedule.nextDueTime, 30);
      if (!timeGroups.has(timeKey)) {
        timeGroups.set(timeKey, []);
      }
      timeGroups.get(timeKey)!.push(schedule);
    }
    
    // Return the largest group
    let largestGroup: MedicationSchedule[] = [];
    for (const [, group] of timeGroups) {
      if (group.length > largestGroup.length) {
        largestGroup = group;
      }
    }
    
    return largestGroup;
  }

  private countGroupedAdministrations(schedules: MedicationSchedule[]): number {
    const timeGroups = new Map<string, number>();
    
    for (const schedule of schedules) {
      const timeKey = this.getTimeGroupKey(schedule.nextDueTime, 30);
      timeGroups.set(timeKey, (timeGroups.get(timeKey) || 0) + 1);
    }
    
    let groupedCount = 0;
    for (const [, count] of timeGroups) {
      if (count > 1) {
        groupedCount += count - 1; // Count additional medications in group
      }
    }
    
    return groupedCount;
  }

  private getTimeGroupKey(time: Date, windowMinutes: number): string {
    const roundedMinutes = Math.floor(time.getMinutes() / windowMinutes) * windowMinutes;
    return `${time.getHours()}:${roundedMinutes.toString().padStart(2, '0')}`;
  }

  private calculateAverageTime(times: Date[]): Date {
    const totalMs = times.reduce((sum, time) => sum + time.getTime(), 0);
    return new Date(totalMs / times.length);
  }

  private findNearestMealTime(time: Date, mealTimes: string[]): Date | null {
    let nearestTime: Date | null = null;
    let minDifference = Infinity;
    
    for (const mealTimeStr of mealTimes) {
      const [hours, minutes] = mealTimeStr.split(':').map(Number);
      const mealTime = new Date(time);
      mealTime.setHours(hours, minutes, 0, 0);
      
      const difference = Math.abs(time.getTime() - mealTime.getTime());
      if (difference < minDifference && difference < 2 * 60 * 60 * 1000) { // Within 2 hours
        minDifference = difference;
        nearestTime = mealTime;
      }
    }
    
    return nearestTime;
  }
}