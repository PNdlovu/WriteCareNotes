import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Medication Interaction and Allergy Checker Service for WriteCareNotes Healthcare Management
 * @module MedicationInteractionService
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive medication interaction and allergy checking service providing
 * real-time drug interaction detection, allergy alerts, contraindication warnings,
 * and clinical decision support across all British Isles healthcare jurisdictions.
 * 
 * @compliance
 * - MHRA Drug Safety Guidelines
 * - BNF (British National Formulary) Standards
 * - NICE Clinical Guidelines
 * - CQC Regulation 12 - Safe care and treatment
 * - Professional Standards (GMC, NMC, GPhC)
 * - GDPR and Data Protection Act 2018
 * 
 * @security
 * - Real-time clinical decision support
 * - Severity-based alert system
 * - Audit trail for all interactions
 * - Integration with external drug databases
 */

import { Repository } from 'typeorm';
import { EventEmitter2 } from 'eventemitter2';
import AppDataSource from '../../config/database';
import { AuditTrailService } from '../audit/AuditTrailService';
import { NotificationService } from '../notifications/NotificationService';
import { EventPublishingService } from '../events/EventPublishingService';
import { logger } from '../../utils/logger';

export interface DrugInteraction {
  id: string;
  drug1Id: string;
  drug1Name: string;
  drug2Id: string;
  drug2Name: string;
  interactionType: 'major' | 'moderate' | 'minor' | 'contraindicated';
  severity: 'critical' | 'high' | 'medium' | 'low';
  mechanism: string;
  clinicalEffect: string;
  management: string;
  evidence: 'established' | 'theoretical' | 'anecdotal';
  references: string[];
  lastUpdated: Date;
  isActive: boolean;
}

export interface AllergyAlert {
  id: string;
  residentId: string;
  allergen: string;
  allergenType: 'drug' | 'food' | 'environmental' | 'other';
  reactionType: 'allergy' | 'intolerance' | 'adverse_reaction';
  severity: 'mild' | 'moderate' | 'severe' | 'anaphylaxis';
  symptoms: string[];
  onsetDate?: Date;
  verifiedBy: string;
  verificationDate: Date;
  notes?: string;
  isActive: boolean;
  organizationId: string;
}

export interface ContraindicationAlert {
  id: string;
  medicationId: string;
  medicationName: string;
  contraindicationType: 'absolute' | 'relative' | 'caution';
  condition: string;
  reason: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  clinicalGuidance: string;
  alternativeOptions?: string[];
  references: string[];
  lastReviewed: Date;
}

export interface InteractionCheckRequest {
  residentId: string;
  medications: {
    id: string;
    name: string;
    activeIngredient: string;
    dosage: string;
    route: string;
  }[];
  newMedication?: {
    name: string;
    activeIngredient: string;
    dosage: string;
    route: string;
  };
  checkAllergies: boolean;
  checkContraindications: boolean;
  organizationId: string;
  userId: string;
}

export interface InteractionCheckResult {
  checkId: string;
  residentId: string;
  checkDate: Date;
  overallRisk: 'low' | 'medium' | 'high' | 'critical';
  interactions: {
    interaction: DrugInteraction;
    affectedMedications: string[];
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    clinicalRecommendation: string;
    requiresAction: boolean;
  }[];
  allergyAlerts: {
    alert: AllergyAlert;
    triggeredBy: string;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    clinicalRecommendation: string;
    requiresAction: boolean;
  }[];
  contraindicationAlerts: {
    alert: ContraindicationAlert;
    triggeredBy: string;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    clinicalRecommendation: string;
    requiresAction: boolean;
  }[];
  clinicalDecisionSupport: {
    recommendations: string[];
    alternatives: string[];
    monitoringRequirements: string[];
    followUpActions: string[];
  };
  safetyScore: number; // 0-100, higher is safer
}

export class MedicationInteractionService {
  private auditService: AuditTrailService;
  private notificationService: NotificationService;
  private eventService: EventPublishingService;
  private interactionCache: Map<string, DrugInteraction[]> = new Map();
  private drugDatabaseCache: Map<string, any> = new Map();

  constructor() {
    this.auditService = new AuditTrailService();
    this.notificationService = new NotificationService(new EventEmitter2());
    this.eventService = new EventPublishingService();
    this.initializeInteractionDatabase();
  }

  /**
   * Initialize interaction database and cache
   */
  private async initializeInteractionDatabase(): Promise<void> {
    try {
      // Load drug interactions from database
      const interactions = await this.loadDrugInteractions();
      
      // Build interaction cache for fast lookups
      interactions.forEach(interaction => {
        const key1 = `${interaction.drug1Id}_${interaction.drug2Id}`;
        const key2 = `${interaction.drug2Id}_${interaction.drug1Id}`;
        
        if (!this.interactionCache.has(key1)) {
          this.interactionCache.set(key1, []);
        }
        if (!this.interactionCache.has(key2)) {
          this.interactionCache.set(key2, []);
        }
        
        this.interactionCache.get(key1)!.push(interaction);
        this.interactionCache.get(key2)!.push(interaction);
      });

      // Load drug database
      const drugs = await this.loadDrugDatabase();
      drugs.forEach(drug => {
        this.drugDatabaseCache.set(drug.id, drug);
        this.drugDatabaseCache.set(drug.name.toLowerCase(), drug);
      });

      console.info('Medication interaction database initialized', {
        interactionsCount: interactions.length,
        drugsCount: drugs.length
      });
    } catch (error: unknown) {
      console.error('Error initializing interaction database', { error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error" });
      throw error;
    }
  }

  /**
   * Perform comprehensive medication interaction check
   */
  async checkMedicationInteractions(
    request: InteractionCheckRequest
  ): Promise<InteractionCheckResult> {
    try {
      const checkId = this.generateUniqueId();
      const checkDate = new Date();

      // Get resident's current allergies and medical conditions
      const residentData = await this.getResidentMedicalData(request.residentId, request.organizationId);

      // Prepare medication list for checking
      const allMedications = [...request.medications];
      if (request.newMedication) {
        allMedications.push({
          id: 'new_medication',
          ...request.newMedication
        });
      }

      // Check drug-drug interactions
      const interactions = await this.checkDrugInteractions(allMedications);

      // Check allergy alerts
      const allergyAlerts = request.checkAllergies ? 
        await this.checkAllergyAlerts(allMedications, residentData.allergies) : [];

      // Check contraindications
      const contraindicationAlerts = request.checkContraindications ? 
        await this.checkContraindications(allMedications, residentData.conditions) : [];

      // Generate clinical decision support
      const clinicalDecisionSupport = await this.generateClinicalDecisionSupport(
        interactions,
        allergyAlerts,
        contraindicationAlerts,
        residentData
      );

      // Calculate overall risk and safety score
      const overallRisk = this.calculateOverallRisk(interactions, allergyAlerts, contraindicationAlerts);
      const safetyScore = this.calculateSafetyScore(interactions, allergyAlerts, contraindicationAlerts);

      const result: InteractionCheckResult = {
        checkId,
        residentId: request.residentId,
        checkDate,
        overallRisk,
        interactions,
        allergyAlerts,
        contraindicationAlerts,
        clinicalDecisionSupport,
        safetyScore
      };

      // Store check result
      await this.storeInteractionCheckResult(result, request.organizationId);

      // Send alerts for critical findings
      await this.sendCriticalAlerts(result, request.organizationId, request.userId);

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'MedicationInteractionCheck',
        entityId: checkId,
        action: 'CREATE',
        userId: request.userId,
        organizationId: request.organizationId,
        details: {
          residentId: request.residentId,
          medicationsCount: allMedications.length,
          overallRisk,
          safetyScore,
          interactionsFound: interactions.length,
          allergyAlertsFound: allergyAlerts.length,
          contraindicationAlertsFound: contraindicationAlerts.length
        }
      });

      console.info('Medication interaction check completed', {
        checkId,
        residentId: request.residentId,
        overallRisk,
        safetyScore,
        organizationId: request.organizationId
      });

      return result;
    } catch (error: unknown) {
      console.error('Error performing medication interaction check', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId: request.residentId,
        organizationId: request.organizationId,
        userId: request.userId
      });
      throw error;
    }
  }

  /**
   * Add or update allergy information for a resident
   */
  async addAllergyAlert(
    residentId: string,
    allergyData: Omit<AllergyAlert, 'id' | 'verificationDate'>,
    organizationId: string,
    userId: string
  ): Promise<AllergyAlert> {
    try {
      const allergyId = this.generateUniqueId();
      const verificationDate = new Date();

      const allergy: AllergyAlert = {
        id: allergyId,
        residentId,
        verificationDate,
        ...allergyData,
        organizationId
      };

      // Store allergy in database
      await AppDataSource.query(`
        INSERT INTO resident_allergies (
          id, resident_id, allergen, allergen_type, reaction_type, severity,
          symptoms, onset_date, verified_by, verification_date, notes,
          is_active, organization_id, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      `, [
        allergyId, residentId, allergy.allergen, allergy.allergenType,
        allergy.reactionType, allergy.severity, JSON.stringify(allergy.symptoms),
        allergy.onsetDate, allergy.verifiedBy, verificationDate, allergy.notes,
        allergy.isActive, organizationId, new Date()
      ]);

      // Check for potential interactions with current medications
      const currentMedications = await this.getCurrentMedications(residentId, organizationId);
      if (currentMedications.length > 0) {
        const interactionCheck = await this.checkMedicationInteractions({
          residentId,
          medications: currentMedications,
          checkAllergies: true,
          checkContraindications: false,
          organizationId,
          userId
        });

        // Send alerts if new allergy creates risks
        if (interactionCheck.allergyAlerts.length > 0) {
          await this.sendAllergyInteractionAlert(interactionCheck, organizationId, userId);
        }
      }

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'ResidentAllergy',
        entityId: allergyId,
        action: 'CREATE',
        userId,
        organizationId,
        details: {
          residentId,
          allergen: allergy.allergen,
          allergenType: allergy.allergenType,
          severity: allergy.severity,
          reactionType: allergy.reactionType
        }
      });

      console.info('Allergy alert added', {
        allergyId,
        residentId,
        allergen: allergy.allergen,
        severity: allergy.severity,
        organizationId
      });

      return allergy;
    } catch (error: unknown) {
      console.error('Error adding allergy alert', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Update interaction database from external sources
   */
  async updateInteractionDatabase(
    source: 'bnf' | 'mhra' | 'nice' | 'lexicomp' | 'micromedex',
    organizationId: string,
    userId: string
  ): Promise<{
    updated: boolean;
    newInteractions: number;
    updatedInteractions: number;
    lastUpdateDate: Date;
  }> {
    try {
      const updateDate = new Date();
      let newInteractions = 0;
      let updatedInteractions = 0;

      // Fetch updates from external source
      const externalData = await this.fetchExternalInteractionData(source);

      for (const interaction of externalData.interactions) {
        const existingInteraction = await this.findExistingInteraction(
          interaction.drug1Name,
          interaction.drug2Name
        );

        if (existingInteraction) {
          // Update existing interaction
          await this.updateExistingInteraction(existingInteraction.id, interaction);
          updatedInteractions++;
        } else {
          // Add new interaction
          await this.addNewInteraction(interaction, organizationId);
          newInteractions++;
        }
      }

      // Update drug database
      for (const drug of externalData.drugs) {
        await this.updateDrugDatabase(drug, organizationId);
      }

      // Refresh cache
      await this.initializeInteractionDatabase();

      // Log update activity
      await this.auditService.logActivity({
        entityType: 'InteractionDatabase',
        entityId: 'database_update',
        action: 'UPDATE',
        userId,
        organizationId,
        details: {
          source,
          newInteractions,
          updatedInteractions,
          updateDate
        }
      });

      console.info('Interaction database updated', {
        source,
        newInteractions,
        updatedInteractions,
        organizationId
      });

      return {
        updated: true,
        newInteractions,
        updatedInteractions,
        lastUpdateDate: updateDate
      };
    } catch (error: unknown) {
      console.error('Error updating interaction database', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        source,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Get interaction history for a resident
   */
  async getInteractionHistory(
    residentId: string,
    organizationId: string,
    startDate?: Date,
    endDate?: Date
  ): Promise<InteractionCheckResult[]> {
    try {
      let query = `
        SELECT * FROM medication_interaction_checks
        WHERE resident_id = $1 AND organization_id = $2
      `;
      const params: any[] = [residentId, organizationId];

      if (startDate && endDate) {
        query += ' AND check_date BETWEEN $3 AND $4';
        params.push(startDate, endDate);
      } else if (startDate) {
        query += ' AND check_date >= $3';
        params.push(startDate);
      } else if (endDate) {
        query += ' AND check_date <= $3';
        params.push(endDate);
      }

      query += ' ORDER BY check_date DESC LIMIT 50';

      const results = await AppDataSource.query(query, params);

      return results.map((row: any) => ({
        checkId: row.check_id,
        residentId: row.resident_id,
        checkDate: row.check_date,
        overallRisk: row.overall_risk,
        interactions: JSON.parse(row.interactions || '[]'),
        allergyAlerts: JSON.parse(row.allergy_alerts || '[]'),
        contraindicationAlerts: JSON.parse(row.contraindication_alerts || '[]'),
        clinicalDecisionSupport: JSON.parse(row.clinical_decision_support || '{}'),
        safetyScore: row.safety_score
      }));
    } catch (error: unknown) {
      console.error('Error getting interaction history', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId,
        organizationId
      });
      throw error;
    }
  }

  /**
   * Generate interaction report for clinical review
   */
  async generateInteractionReport(
    organizationId: string,
    reportType: 'summary' | 'detailed' | 'trends',
    dateRange: { startDate: Date; endDate: Date },
    userId: string
  ): Promise<{
    reportId: string;
    reportType: string;
    generatedDate: Date;
    summary: {
      totalChecks: number;
      criticalInteractions: number;
      allergyAlerts: number;
      contraindicationAlerts: number;
      averageSafetyScore: number;
    };
    details: any;
  }> {
    try {
      const reportId = this.generateUniqueId();
      const generatedDate = new Date();

      // Get interaction check data for the period
      const checksData = await AppDataSource.query(`
        SELECT 
          COUNT(*) as total_checks,
          AVG(safety_score) as avg_safety_score,
          COUNT(CASE WHEN overall_risk = 'critical' THEN 1 END) as critical_interactions,
          SUM(CASE WHEN allergy_alerts != '[]' THEN 1 ELSE 0 END) as allergy_alerts,
          SUM(CASE WHEN contraindication_alerts != '[]' THEN 1 ELSE 0 END) as contraindication_alerts
        FROM medication_interaction_checks
        WHERE organization_id = $1 AND check_date BETWEEN $2 AND $3
      `, [organizationId, dateRange.startDate, dateRange.endDate]);

      const summary = {
        totalChecks: parseInt(checksData[0].total_checks) || 0,
        criticalInteractions: parseInt(checksData[0].critical_interactions) || 0,
        allergyAlerts: parseInt(checksData[0].allergy_alerts) || 0,
        contraindicationAlerts: parseInt(checksData[0].contraindication_alerts) || 0,
        averageSafetyScore: parseFloat(checksData[0].avg_safety_score) || 0
      };

      // Generate detailed data based on report type
      let details = {};
      if (reportType === 'detailed') {
        details = await this.generateDetailedReportData(organizationId, dateRange);
      } else if (reportType === 'trends') {
        details = await this.generateTrendsReportData(organizationId, dateRange);
      }

      const report = {
        reportId,
        reportType,
        generatedDate,
        summary,
        details
      };

      // Store report
      await AppDataSource.query(`
        INSERT INTO interaction_reports (
          id, report_type, generated_date, date_range_start, date_range_end,
          summary, details, organization_id, generated_by, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      `, [
        reportId, reportType, generatedDate, dateRange.startDate, dateRange.endDate,
        JSON.stringify(summary), JSON.stringify(details), organizationId, userId, new Date()
      ]);

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'InteractionReport',
        entityId: reportId,
        action: 'GENERATE',
        userId,
        organizationId,
        details: {
          reportType,
          dateRange,
          totalChecks: summary.totalChecks,
          criticalInteractions: summary.criticalInteractions
        }
      });

      console.info('Interaction report generated', {
        reportId,
        reportType,
        organizationId,
        totalChecks: summary.totalChecks
      });

      return report;
    } catch (error: unknown) {
      console.error('Error generating interaction report', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        reportType,
        organizationId,
        userId
      });
      throw error;
    }
  }

  /**
   * Get resident allergies
   */
  async getResidentAllergies(
    residentId: string,
    organizationId: string
  ): Promise<AllergyAlert[]> {
    try {
      const result = await AppDataSource.query(`
        SELECT * FROM resident_allergies
        WHERE resident_id = $1 AND organization_id = $2 AND is_active = true
        ORDER BY severity DESC, verification_date DESC
      `, [residentId, organizationId]);

      return result.map((row: any) => ({
        id: row.id,
        residentId: row.resident_id,
        allergen: row.allergen,
        allergenType: row.allergen_type,
        reactionType: row.reaction_type,
        severity: row.severity,
        symptoms: JSON.parse(row.symptoms || '[]'),
        onsetDate: row.onset_date,
        verifiedBy: row.verified_by,
        verificationDate: row.verification_date,
        notes: row.notes,
        isActive: row.is_active,
        organizationId: row.organization_id
      }));
    } catch (error: unknown) {
      console.error('Error getting resident allergies', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId,
        organizationId
      });
      throw error;
    }
  }

  /**
   * Update allergy alert
   */
  async updateAllergyAlert(
    allergyId: string,
    updateData: Partial<Omit<AllergyAlert, 'id' | 'residentId' | 'organizationId'>>,
    organizationId: string,
    userId: string
  ): Promise<AllergyAlert> {
    try {
      // Get existing allergy
      const existing = await AppDataSource.query(`
        SELECT * FROM resident_allergies
        WHERE id = $1 AND organization_id = $2
      `, [allergyId, organizationId]);

      if (!existing.length) {
        throw new Error('Allergy alert not found');
      }

      const currentAllergy = existing[0];

      // Build update query dynamically
      const updateFields: string[] = [];
      const updateValues: any[] = [];
      let paramIndex = 1;

      if (updateData.allergen !== undefined) {
        updateFields.push(`allergen = $${paramIndex++}`);
        updateValues.push(updateData.allergen);
      }

      if (updateData.allergenType !== undefined) {
        updateFields.push(`allergen_type = $${paramIndex++}`);
        updateValues.push(updateData.allergenType);
      }

      if (updateData.reactionType !== undefined) {
        updateFields.push(`reaction_type = $${paramIndex++}`);
        updateValues.push(updateData.reactionType);
      }

      if (updateData.severity !== undefined) {
        updateFields.push(`severity = $${paramIndex++}`);
        updateValues.push(updateData.severity);
      }

      if (updateData.symptoms !== undefined) {
        updateFields.push(`symptoms = $${paramIndex++}`);
        updateValues.push(JSON.stringify(updateData.symptoms));
      }

      if (updateData.onsetDate !== undefined) {
        updateFields.push(`onset_date = $${paramIndex++}`);
        updateValues.push(updateData.onsetDate);
      }

      if (updateData.notes !== undefined) {
        updateFields.push(`notes = $${paramIndex++}`);
        updateValues.push(updateData.notes);
      }

      if (updateData.isActive !== undefined) {
        updateFields.push(`is_active = $${paramIndex++}`);
        updateValues.push(updateData.isActive);
      }

      updateFields.push(`updated_at = $${paramIndex++}`);
      updateValues.push(new Date());

      updateValues.push(allergyId, organizationId);

      if (updateFields.length > 1) { // More than just updated_at
        await AppDataSource.query(`
          UPDATE resident_allergies
          SET ${updateFields.join(', ')}
          WHERE id = $${paramIndex++} AND organization_id = $${paramIndex++}
        `, updateValues);
      }

      // Get updated allergy
      const updated = await AppDataSource.query(`
        SELECT * FROM resident_allergies
        WHERE id = $1 AND organization_id = $2
      `, [allergyId, organizationId]);

      const updatedAllergy: AllergyAlert = {
        id: updated[0].id,
        residentId: updated[0].resident_id,
        allergen: updated[0].allergen,
        allergenType: updated[0].allergen_type,
        reactionType: updated[0].reaction_type,
        severity: updated[0].severity,
        symptoms: JSON.parse(updated[0].symptoms || '[]'),
        onsetDate: updated[0].onset_date,
        verifiedBy: updated[0].verified_by,
        verificationDate: updated[0].verification_date,
        notes: updated[0].notes,
        isActive: updated[0].is_active,
        organizationId: updated[0].organization_id
      };

      // Log audit trail
      await this.auditService.logActivity({
        entityType: 'ResidentAllergy',
        entityId: allergyId,
        action: 'UPDATE',
        userId,
        organizationId,
        details: {
          residentId: updatedAllergy.residentId,
          changes: updateData,
          previousValues: {
            allergen: currentAllergy.allergen,
            severity: currentAllergy.severity,
            isActive: currentAllergy.is_active
          }
        }
      });

      console.info('Allergy alert updated', {
        allergyId,
        residentId: updatedAllergy.residentId,
        organizationId
      });

      return updatedAllergy;
    } catch (error: unknown) {
      console.error('Error updating allergy alert', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        allergyId,
        organizationId,
        userId
      });
      throw error;
    }
  }

  // Private helper methods

  private generateUniqueId(): string {
    return 'int_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private async loadDrugInteractions(): Promise<DrugInteraction[]> {
    const result = await AppDataSource.query(`
      SELECT * FROM drug_interactions WHERE is_active = true
      ORDER BY severity DESC, interaction_type
    `);

    return result.map((row: any) => ({
      id: row.id,
      drug1Id: row.drug1_id,
      drug1Name: row.drug1_name,
      drug2Id: row.drug2_id,
      drug2Name: row.drug2_name,
      interactionType: row.interaction_type,
      severity: row.severity,
      mechanism: row.mechanism,
      clinicalEffect: row.clinical_effect,
      management: row.management,
      evidence: row.evidence,
      references: JSON.parse(row.references || '[]'),
      lastUpdated: row.last_updated,
      isActive: row.is_active
    }));
  }

  private async loadDrugDatabase(): Promise<any[]> {
    const result = await AppDataSource.query(`
      SELECT * FROM drug_database
      ORDER BY name
    `);

    return result.map((row: any) => ({
      id: row.id,
      name: row.name,
      activeIngredients: JSON.parse(row.active_ingredients || '[]'),
      therapeuticClass: row.therapeutic_class,
      pharmacologicalClass: row.pharmacological_class,
      mechanism: row.mechanism,
      indications: JSON.parse(row.indications || '[]'),
      contraindications: JSON.parse(row.contraindications || '[]'),
      warnings: JSON.parse(row.warnings || '[]'),
      interactions: JSON.parse(row.interactions || '[]'),
      sideEffects: JSON.parse(row.side_effects || '[]'),
      dosageInformation: JSON.parse(row.dosage_information || '[]'),
      specialPopulations: JSON.parse(row.special_populations || '{}'),
      monitoringParameters: JSON.parse(row.monitoring_parameters || '[]'),
      lastUpdated: row.last_updated
    }));
  }

  private async getResidentMedicalData(
    residentId: string,
    organizationId: string
  ): Promise<{
    allergies: AllergyAlert[];
    conditions: string[];
    demographics: {
      age: number;
      weight?: number;
      renalFunction?: string;
      hepaticFunction?: string;
    };
  }> {
    // Get allergies
    const allergiesResult = await AppDataSource.query(`
      SELECT * FROM resident_allergies
      WHERE resident_id = $1 AND organization_id = $2 AND is_active = true
    `, [residentId, organizationId]);

    const allergies = allergiesResult.map((row: any) => ({
      id: row.id,
      residentId: row.resident_id,
      allergen: row.allergen,
      allergenType: row.allergen_type,
      reactionType: row.reaction_type,
      severity: row.severity,
      symptoms: JSON.parse(row.symptoms || '[]'),
      onsetDate: row.onset_date,
      verifiedBy: row.verified_by,
      verificationDate: row.verification_date,
      notes: row.notes,
      isActive: row.is_active,
      organizationId: row.organization_id
    }));

    // Get medical conditions
    const conditionsResult = await AppDataSource.query(`
      SELECT condition_name FROM resident_conditions
      WHERE resident_id = $1 AND organization_id = $2 AND is_active = true
    `, [residentId, organizationId]);

    const conditions = conditionsResult.map((row: any) => row.condition_name);

    // Get demographics
    const demographicsResult = await AppDataSource.query(`
      SELECT date_of_birth, weight, renal_function, hepatic_function
      FROM residents
      WHERE id = $1 AND organization_id = $2
    `, [residentId, organizationId]);

    const demographics = demographicsResult[0] ? {
      age: this.calculateAge(demographicsResult[0].date_of_birth),
      weight: demographicsResult[0].weight,
      renalFunction: demographicsResult[0].renal_function,
      hepaticFunction: demographicsResult[0].hepatic_function
    } : { age: 0 };

    return { allergies, conditions, demographics };
  }

  private async checkDrugInteractions(
    medications: { id: string; name: string; activeIngredient: string }[]
  ): Promise<InteractionCheckResult['interactions']> {
    const interactions: InteractionCheckResult['interactions'] = [];

    // Check all medication pairs for interactions
    for (let i = 0; i < medications.length; i++) {
      for (let j = i + 1; j < medications.length; j++) {
        const med1 = medications[i];
        const med2 = medications[j];

        // Look up interactions in cache
        const key = `${med1.activeIngredient}_${med2.activeIngredient}`;
        const foundInteractions = this.interactionCache.get(key) || [];

        for (const interaction of foundInteractions) {
          const riskLevel = this.mapSeverityToRiskLevel(interaction.severity);
          const clinicalRecommendation = this.generateClinicalRecommendation(interaction);
          const requiresAction = riskLevel === 'high' || riskLevel === 'critical';

          interactions.push({
            interaction,
            affectedMedications: [med1.name, med2.name],
            riskLevel,
            clinicalRecommendation,
            requiresAction
          });
        }
      }
    }

    return interactions.sort((a, b) => {
      const severityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
      return severityOrder[b.riskLevel] - severityOrder[a.riskLevel];
    });
  }

  private async checkAllergyAlerts(
    medications: { name: string; activeIngredient: string }[],
    allergies: AllergyAlert[]
  ): Promise<InteractionCheckResult['allergyAlerts']> {
    const alerts: InteractionCheckResult['allergyAlerts'] = [];

    for (const medication of medications) {
      for (const allergy of allergies) {
        // Check if medication matches allergy
        const isMatch = this.checkAllergyMatch(medication, allergy);
        
        if (isMatch) {
          const riskLevel = this.mapAllergyToRiskLevel(allergy.severity);
          const clinicalRecommendation = this.generateAllergyRecommendation(allergy, medication);
          const requiresAction = riskLevel === 'high' || riskLevel === 'critical';

          alerts.push({
            alert: allergy,
            triggeredBy: medication.name,
            riskLevel,
            clinicalRecommendation,
            requiresAction
          });
        }
      }
    }

    return alerts.sort((a, b) => {
      const severityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
      return severityOrder[b.riskLevel] - severityOrder[a.riskLevel];
    });
  }

  private async checkContraindications(
    medications: { name: string; activeIngredient: string }[],
    conditions: string[]
  ): Promise<InteractionCheckResult['contraindicationAlerts']> {
    const alerts: InteractionCheckResult['contraindicationAlerts'] = [];

    for (const medication of medications) {
      // Get contraindications for this medication
      const contraindications = await this.getMedicationContraindications(medication.activeIngredient);
      
      for (const contraindication of contraindications) {
        // Check if resident has contraindicated condition
        const hasCondition = conditions.some(condition => 
          condition.toLowerCase().includes(contraindication.condition.toLowerCase())
        );

        if (hasCondition) {
          const riskLevel = this.mapContraindicationToRiskLevel(contraindication.severity);
          const clinicalRecommendation = contraindication.clinicalGuidance;
          const requiresAction = contraindication.contraindicationType === 'absolute' || riskLevel === 'critical';

          alerts.push({
            alert: contraindication,
            triggeredBy: medication.name,
            riskLevel,
            clinicalRecommendation,
            requiresAction
          });
        }
      }
    }

    return alerts.sort((a, b) => {
      const severityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
      return severityOrder[b.riskLevel] - severityOrder[a.riskLevel];
    });
  }

  private async generateClinicalDecisionSupport(
    interactions: InteractionCheckResult['interactions'],
    allergyAlerts: InteractionCheckResult['allergyAlerts'],
    contraindicationAlerts: InteractionCheckResult['contraindicationAlerts'],
    residentData: any
  ): Promise<InteractionCheckResult['clinicalDecisionSupport']> {
    const recommendations: any[] = [];
    const alternatives: string[] = [];
    const monitoringRequirements: string[] = [];
    const followUpActions: string[] = [];

    // Generate recommendations based on findings
    if (interactions.length > 0) {
      const criticalInteractions = interactions.filter(i => i.riskLevel === 'critical');
      if (criticalInteractions.length > 0) {
        recommendations.push('CRITICAL: Review medication regimen immediately');
        recommendations.push('Consider alternative medications for critical interactions');
        followUpActions.push('Consult clinical pharmacist within 24 hours');
      }

      const highRiskInteractions = interactions.filter(i => i.riskLevel === 'high');
      if (highRiskInteractions.length > 0) {
        recommendations.push('Monitor closely for interaction effects');
        monitoringRequirements.push('Increased monitoring frequency recommended');
      }
    }

    if (allergyAlerts.length > 0) {
      const severeAllergies = allergyAlerts.filter(a => a.riskLevel === 'critical' || a.riskLevel === 'high');
      if (severeAllergies.length > 0) {
        recommendations.push('STOP: Severe allergy risk identified');
        recommendations.push('Do not administer - find alternative medication');
        followUpActions.push('Update allergy alerts in medical record');
      }
    }

    if (contraindicationAlerts.length > 0) {
      const absoluteContraindications = contraindicationAlerts.filter(
        c => c.alert.contraindicationType === 'absolute'
      );
      if (absoluteContraindications.length > 0) {
        recommendations.push('CONTRAINDICATED: Do not use this medication');
        followUpActions.push('Seek alternative treatment options');
      }
    }

    // Generate alternatives and monitoring based on specific findings
    for (const interaction of interactions) {
      if (interaction.requiresAction) {
        alternatives.push(...this.generateAlternatives(interaction.interaction));
        monitoringRequirements.push(...this.generateMonitoringRequirements(interaction.interaction));
      }
    }

    return {
      recommendations: [...new Set(recommendations)],
      alternatives: [...new Set(alternatives)],
      monitoringRequirements: [...new Set(monitoringRequirements)],
      followUpActions: [...new Set(followUpActions)]
    };
  }

  private calculateOverallRisk(
    interactions: InteractionCheckResult['interactions'],
    allergyAlerts: InteractionCheckResult['allergyAlerts'],
    contraindicationAlerts: InteractionCheckResult['contraindicationAlerts']
  ): 'low' | 'medium' | 'high' | 'critical' {
    const allRisks = [
      ...interactions.map(i => i.riskLevel),
      ...allergyAlerts.map(a => a.riskLevel),
      ...contraindicationAlerts.map(c => c.riskLevel)
    ];

    if (allRisks.includes('critical')) return 'critical';
    if (allRisks.includes('high')) return 'high';
    if (allRisks.includes('medium')) return 'medium';
    return 'low';
  }

  private calculateSafetyScore(
    interactions: InteractionCheckResult['interactions'],
    allergyAlerts: InteractionCheckResult['allergyAlerts'],
    contraindicationAlerts: InteractionCheckResult['contraindicationAlerts']
  ): number {
    let score = 100;

    // Deduct points for each finding based on severity
    const severityPenalties = { 'critical': 25, 'high': 15, 'medium': 8, 'low': 3 };

    interactions.forEach(i => {
      score -= severityPenalties[i.riskLevel] || 0;
    });

    allergyAlerts.forEach(a => {
      score -= severityPenalties[a.riskLevel] || 0;
    });

    contraindicationAlerts.forEach(c => {
      score -= severityPenalties[c.riskLevel] || 0;
    });

    return Math.max(0, Math.min(100, score));
  }

  private mapSeverityToRiskLevel(severity: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (severity) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'medium': return 'medium';
      case 'low': return 'low';
      default: return 'low';
    }
  }

  private mapAllergyToRiskLevel(severity: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (severity) {
      case 'anaphylaxis': return 'critical';
      case 'severe': return 'high';
      case 'moderate': return 'medium';
      case 'mild': return 'low';
      default: return 'low';
    }
  }

  private mapContraindicationToRiskLevel(severity: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (severity) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'medium': return 'medium';
      case 'low': return 'low';
      default: return 'medium';
    }
  }

  private generateClinicalRecommendation(interaction: DrugInteraction): string {
    return `${interaction.management} Monitor for: ${interaction.clinicalEffect}`;
  }

  private generateAllergyRecommendation(allergy: AllergyAlert, medication: any): string {
    if (allergy.severity === 'anaphylaxis' || allergy.severity === 'severe') {
      return `CONTRAINDICATED: Patient has ${allergy.severity} allergy to ${allergy.allergen}. Do not administer ${medication.name}.`;
    }
    return `CAUTION: Patient has ${allergy.severity} ${allergy.reactionType} to ${allergy.allergen}. Monitor closely if ${medication.name} is administered.`;
  }

  private checkAllergyMatch(medication: any, allergy: AllergyAlert): boolean {
    const medicationLower = medication.name.toLowerCase();
    const ingredientLower = medication.activeIngredient.toLowerCase();
    const allergenLower = allergy.allergen.toLowerCase();

    return medicationLower.includes(allergenLower) || 
           ingredientLower.includes(allergenLower) ||
           allergenLower.includes(medicationLower) ||
           allergenLower.includes(ingredientLower);
  }

  private async getMedicationContraindications(activeIngredient: string): Promise<ContraindicationAlert[]> {
    const result = await AppDataSource.query(`
      SELECT * FROM medication_contraindications
      WHERE medication_name = $1 OR active_ingredient = $2
    `, [activeIngredient, activeIngredient]);

    return result.map((row: any) => ({
      id: row.id,
      medicationId: row.medication_id,
      medicationName: row.medication_name,
      contraindicationType: row.contraindication_type,
      condition: row.condition,
      reason: row.reason,
      severity: row.severity,
      clinicalGuidance: row.clinical_guidance,
      alternativeOptions: JSON.parse(row.alternative_options || '[]'),
      references: JSON.parse(row.references || '[]'),
      lastReviewed: row.last_reviewed
    }));
  }

  private generateAlternatives(interaction: DrugInteraction): string[] {
    // This would integrate with clinical decision support systems
    // For now, return generic alternatives based on interaction type
    const alternatives: string[] = [];
    
    if (interaction.interactionType === 'major' || interaction.interactionType === 'contraindicated') {
      alternatives.push('Consider alternative medication from different therapeutic class');
      alternatives.push('Consult clinical pharmacist for alternative recommendations');
    }
    
    return alternatives;
  }

  private generateMonitoringRequirements(interaction: DrugInteraction): string[] {
    const monitoring: string[] = [];
    
    if (interaction.severity === 'critical' || interaction.severity === 'high') {
      monitoring.push('Monitor vital signs more frequently');
      monitoring.push('Consider laboratory monitoring if indicated');
      monitoring.push('Assess for signs and symptoms of interaction');
    }
    
    return monitoring;
  }

  private calculateAge(dateOfBirth: Date): number {
    const today = new Date();
    const birthDate = new Date(dateOfBirth);
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  }

  private async getCurrentMedications(
    residentId: string,
    organizationId: string
  ): Promise<{ id: string; name: string; activeIngredient: string; dosage: string; route: string }[]> {
    const result = await AppDataSource.query(`
      SELECT p.id, m.name, m.active_ingredient, p.dosage, p.route
      FROM prescriptions p
      JOIN medications m ON p.medication_id = m.id
      WHERE p.resident_id = $1 AND p.organization_id = $2 
        AND p.status = 'active' AND p.end_date > CURRENT_DATE
    `, [residentId, organizationId]);

    return result.map((row: any) => ({
      id: row.id,
      name: row.name,
      activeIngredient: row.active_ingredient,
      dosage: row.dosage,
      route: row.route
    }));
  }

  private async storeInteractionCheckResult(
    result: InteractionCheckResult,
    organizationId: string
  ): Promise<void> {
    await AppDataSource.query(`
      INSERT INTO medication_interaction_checks (
        check_id, resident_id, check_date, overall_risk, interactions,
        allergy_alerts, contraindication_alerts, clinical_decision_support,
        safety_score, organization_id, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    `, [
      result.checkId, result.residentId, result.checkDate, result.overallRisk,
      JSON.stringify(result.interactions), JSON.stringify(result.allergyAlerts),
      JSON.stringify(result.contraindicationAlerts), JSON.stringify(result.clinicalDecisionSupport),
      result.safetyScore, organizationId, new Date()
    ]);
  }

  private async sendCriticalAlerts(
    result: InteractionCheckResult,
    organizationId: string,
    userId: string
  ): Promise<void> {
    if (result.overallRisk === 'critical') {
      await this.notificationService.sendNotification({
        message: 'Notification: Critical Medication Interaction',
        type: 'critical_medication_interaction',
        recipientId: 'clinical_team',
        organizationId,
        title: 'CRITICAL: Medication Interaction Alert',
        message: `Critical medication interaction detected for resident ${result.residentId}`,
        data: {
          checkId: result.checkId,
          residentId: result.residentId,
          overallRisk: result.overallRisk,
          safetyScore: result.safetyScore,
          interactionsCount: result.interactions.length,
          allergyAlertsCount: result.allergyAlerts.length
        }
      });
    }
  }

  private async sendAllergyInteractionAlert(
    result: InteractionCheckResult,
    organizationId: string,
    userId: string
  ): Promise<void> {
    const criticalAllergies = result.allergyAlerts.filter(a => a.riskLevel === 'critical');
    
    if (criticalAllergies.length > 0) {
      await this.notificationService.sendNotification({
        message: 'Notification: Allergy Medication Alert',
        type: 'allergy_medication_alert',
        recipientId: 'clinical_team',
        organizationId,
        title: 'ALLERGY ALERT: Medication Contraindicated',
        message: `New allergy creates medication contraindication for resident ${result.residentId}`,
        data: {
          checkId: result.checkId,
          residentId: result.residentId,
          criticalAllergies: criticalAllergies.length
        }
      });
    }
  }

  private async fetchExternalInteractionData(source: string): Promise<{
    interactions: any[];
    drugs: any[];
  }> {
    // This would integrate with external drug databases
    // For now, return empty data structure
    console.info('Fetching external interaction data', { source });
    
    return {
      interactions: [],
      drugs: []
    };
  }

  private async findExistingInteraction(
    drug1Name: string,
    drug2Name: string
  ): Promise<DrugInteraction | null> {
    const result = await AppDataSource.query(`
      SELECT * FROM drug_interactions
      WHERE (drug1_name = $1 AND drug2_name = $2) OR (drug1_name = $2 AND drug2_name = $1)
      LIMIT 1
    `, [drug1Name, drug2Name]);

    return result.length > 0 ? result[0] : null;
  }

  private async updateExistingInteraction(id: string, interactionData: any): Promise<void> {
    await AppDataSource.query(`
      UPDATE drug_interactions
      SET mechanism = $1, clinical_effect = $2, management = $3, 
          evidence = $4, last_updated = $5
      WHERE id = $6
    `, [
      interactionData.mechanism,
      interactionData.clinicalEffect,
      interactionData.management,
      interactionData.evidence,
      new Date(),
      id
    ]);
  }

  private async addNewInteraction(interactionData: any, organizationId: string): Promise<void> {
    await AppDataSource.query(`
      INSERT INTO drug_interactions (
        id, drug1_name, drug2_name, interaction_type, severity,
        mechanism, clinical_effect, management, evidence, references,
        is_active, last_updated, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
    `, [
      this.generateUniqueId(),
      interactionData.drug1Name,
      interactionData.drug2Name,
      interactionData.interactionType,
      interactionData.severity,
      interactionData.mechanism,
      interactionData.clinicalEffect,
      interactionData.management,
      interactionData.evidence,
      JSON.stringify(interactionData.references || []),
      true,
      new Date(),
      new Date()
    ]);
  }

  private async updateDrugDatabase(drugData: any, organizationId: string): Promise<void> {
    // Update or insert drug information
    const existing = await AppDataSource.query(`
      SELECT id FROM drug_database WHERE name = $1
    `, [drugData.name]);

    if (existing.length > 0) {
      await AppDataSource.query(`
        UPDATE drug_database
        SET active_ingredients = $1, therapeutic_class = $2, contraindications = $3,
            warnings = $4, interactions = $5, last_updated = $6
        WHERE id = $7
      `, [
        JSON.stringify(drugData.activeIngredients),
        drugData.therapeuticClass,
        JSON.stringify(drugData.contraindications),
        JSON.stringify(drugData.warnings),
        JSON.stringify(drugData.interactions),
        new Date(),
        existing[0].id
      ]);
    } else {
      await AppDataSource.query(`
        INSERT INTO drug_database (
          id, name, active_ingredients, therapeutic_class, contraindications,
          warnings, interactions, last_updated, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      `, [
        this.generateUniqueId(),
        drugData.name,
        JSON.stringify(drugData.activeIngredients),
        drugData.therapeuticClass,
        JSON.stringify(drugData.contraindications),
        JSON.stringify(drugData.warnings),
        JSON.stringify(drugData.interactions),
        new Date(),
        new Date()
      ]);
    }
  }

  private async generateDetailedReportData(
    organizationId: string,
    dateRange: { startDate: Date; endDate: Date }
  ): Promise<any> {
    // Get detailed interaction data
    const interactionDetails = await AppDataSource.query(`
      SELECT 
        check_id, resident_id, check_date, overall_risk, safety_score,
        interactions, allergy_alerts, contraindication_alerts
      FROM medication_interaction_checks
      WHERE organization_id = $1 AND check_date BETWEEN $2 AND $3
      ORDER BY check_date DESC
    `, [organizationId, dateRange.startDate, dateRange.endDate]);

    return {
      checks: interactionDetails,
      riskDistribution: this.calculateRiskDistribution(interactionDetails),
      commonInteractions: this.identifyCommonInteractions(interactionDetails)
    };
  }

  private async generateTrendsReportData(
    organizationId: string,
    dateRange: { startDate: Date; endDate: Date }
  ): Promise<any> {
    // Generate trends data over time
    const trendsData = await AppDataSource.query(`
      SELECT 
        DATE(check_date) as check_date,
        COUNT(*) as total_checks,
        AVG(safety_score) as avg_safety_score,
        COUNT(CASE WHEN overall_risk = 'critical' THEN 1 END) as critical_count
      FROM medication_interaction_checks
      WHERE organization_id = $1 AND check_date BETWEEN $2 AND $3
      GROUP BY DATE(check_date)
      ORDER BY check_date
    `, [organizationId, dateRange.startDate, dateRange.endDate]);

    return {
      dailyTrends: trendsData,
      safetyScoreTrend: this.calculateSafetyScoreTrend(trendsData),
      riskTrend: this.calculateRiskTrend(trendsData)
    };
  }

  private calculateRiskDistribution(checks: any[]): any {
    const distribution = { low: 0, medium: 0, high: 0, critical: 0 };
    
    checks.forEach(check => {
      distribution[check.overall_risk]++;
    });
    
    return distribution;
  }

  private identifyCommonInteractions(checks: any[]): any[] {
    const interactionCounts: Map<string, number> = new Map();
    
    checks.forEach(check => {
      const interactions = JSON.parse(check.interactions || '[]');
      interactions.forEach((interaction: any) => {
        const key = `${interaction.interaction.drug1Name} + ${interaction.interaction.drug2Name}`;
        interactionCounts.set(key, (interactionCounts.get(key) || 0) + 1);
      });
    });
    
    return Array.from(interactionCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([interaction, count]) => ({ interaction, count }));
  }

  private calculateSafetyScoreTrend(trendsData: any[]): any {
    return trendsData.map(day => ({
      date: day.check_date,
      averageScore: parseFloat(day.avg_safety_score) || 0
    }));
  }

  private calculateRiskTrend(trendsData: any[]): any {
    return trendsData.map(day => ({
      date: day.check_date,
      totalChecks: parseInt(day.total_checks) || 0,
      criticalCount: parseInt(day.critical_count) || 0,
      criticalPercentage: day.total_checks > 0 ? 
        Math.round((day.critical_count / day.total_checks) * 100) : 0
    }));
  }
}