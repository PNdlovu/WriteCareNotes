import { EventEmitter2 } from "eventemitter2";

import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, Between } from 'typeorm';
import { SmartDeviceEntity, DeviceType, DeviceStatus, ConnectivityType } from '../entities/smart-device.entity';
import { IoTIntegrationService } from './iot-integration.service';
import { VoiceAssistantService } from './voice-assistant.service';
import { FallDetectionService } from './fall-detection.service';
import { EnvironmentControlService } from './environment-control.service';
import { SecuritySystemService } from './security-system.service';
import { EventEmitter2 } from '@nestjs/event-emitter';

export interface DeviceRegistrationDto {
  deviceName: string;
  deviceType: DeviceType;
  manufacturer: string;
  model: string;
  serialNumber: string;
  roomId?: string;
  residentId?: string;
  connectivityType: ConnectivityType;
  configuration?: Record<string, any>;
  capabilities?: Record<string, any>;
}

export interface DeviceUpdateDto {
  deviceName?: string;
  status?: DeviceStatus;
  configuration?: Record<string, any>;
  currentState?: Record<string, any>;
  automationRules?: Record<string, any>;
  notes?: string;
  batteryLevel?: number;
  requiresAttention?: boolean;
}

export interface SmartHomeMetrics {
  totalDevices: number;
  activeDevices: number;
  offlineDevices: number;
  devicesNeedingMaintenance: number;
  lowBatteryDevices: number;
  devicesByType: Record<DeviceType, number>;
  devicesByRoom: Record<string, number>;
  systemHealthScore: number;
  averageBatteryLevel: number;
  connectivityDistribution: Record<ConnectivityType, number>;
}

export interface AutomationRule {
  id: string;
  name: string;
  trigger: {
    deviceId: string;
    condition: string;
    value: any;
  };
  actions: Array<{
    deviceId: string;
    action: string;
    parameters: Record<string, any>;
  }>;
  isActive: boolean;
  schedule?: {
    startTime?: string;
    endTime?: string;
    days?: string[];
  };
}


export class SmartHomeService {
  // Logger removed

  constructor(
    
    private readonly deviceRepository: Repository<SmartDeviceEntity>,
    private readonly iotService: IoTIntegrationService,
    private readonly voiceAssistantService: VoiceAssistantService,
    private readonly fallDetectionService: FallDetectionService,
    private readonly environmentService: EnvironmentControlService,
    private readonly securityService: SecuritySystemService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * Register a new smart device in the system
   */
  async registerDevice(deviceData: DeviceRegistrationDto, installedBy: string): Promise<SmartDeviceEntity> {
    try {
      // Check if device already exists
      const existingDevice = await this.deviceRepository.findOne({
        where: { serialNumber: deviceData.serialNumber }
      });

      if (existingDevice) {
        throw new Error(`Device with serial number ${deviceData.serialNumber} already registered`);
      }

      // Create new device entity
      const device = this.deviceRepository.create({
        ...deviceData,
        installedBy,
        status: DeviceStatus.INACTIVE,
        isOnline: false,
        batteryLevel: 100,
        installationDate: new Date(),
      });

      const savedDevice = await this.deviceRepository.save(device);

      // Initialize device-specific services
      await this.initializeDeviceServices(savedDevice);

      // Attempt to connect to the device
      await this.connectDevice(savedDevice.id);

      this.eventEmitter.emit('device.registered', savedDevice);
      console.log(`Device ${savedDevice.deviceName} registered successfully`);

      return savedDevice;
    } catch (error: unknown) {
      console.error(`Failed to register device: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Connect to a registered device
   */
  async connectDevice(deviceId: string): Promise<boolean> {
    try {
      const device = await this.deviceRepository.findOne({ where: { id: deviceId } });
      if (!device) {
        throw new Error(`Device with ID ${deviceId} not found`);
      }

      // Use IoT service to establish connection
      const connected = await this.iotService.connectDevice(device);

      if (connected) {
        device.status = DeviceStatus.ACTIVE;
        device.isOnline = true;
        device.lastSeen = new Date();
        await this.deviceRepository.save(device);

        this.eventEmitter.emit('device.connected', device);
        console.log(`Device ${device.deviceName} connected successfully`);
      }

      return connected;
    } catch (error: unknown) {
      console.error(`Failed to connect device ${deviceId}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      return false;
    }
  }

  /**
   * Update device state and configuration
   */
  async updateDevice(deviceId: string, updateData: DeviceUpdateDto): Promise<SmartDeviceEntity> {
    try {
      const device = await this.deviceRepository.findOne({ where: { id: deviceId } });
      if (!device) {
        throw new Error(`Device with ID ${deviceId} not found`);
      }

      // Update device properties
      Object.assign(device, updateData);
      
      if (updateData.currentState) {
        device.updateState(updateData.currentState);
      }

      const updatedDevice = await this.deviceRepository.save(device);

      // Sync changes with physical device
      await this.iotService.syncDeviceState(updatedDevice);

      this.eventEmitter.emit('device.updated', updatedDevice);
      console.log(`Device ${updatedDevice.deviceName} updated successfully`);

      return updatedDevice;
    } catch (error: unknown) {
      console.error(`Failed to update device ${deviceId}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get comprehensive smart home metrics
   */
  async getSmartHomeMetrics(): Promise<SmartHomeMetrics> {
    try {
      const devices = await this.deviceRepository.find();
      
      const totalDevices = devices.length;
      const activeDevices = devices.filter(d => d.status === DeviceStatus.ACTIVE).length;
      const offlineDevices = devices.filter(d => !d.isOnline).length;
      const devicesNeedingMaintenance = devices.filter(d => d.needsMaintenance()).length;
      const lowBatteryDevices = devices.filter(d => d.batteryLevel < 20).length;

      // Device distribution by type
      const devicesByType = devices.reduce((acc, device) => {
        acc[device.deviceType] = (acc[device.deviceType] || 0) + 1;
        return acc;
      }, {} as Record<DeviceType, number>);

      // Device distribution by room
      const devicesByRoom = devices.reduce((acc, device) => {
        if (device.roomId) {
          acc[device.roomId] = (acc[device.roomId] || 0) + 1;
        }
        return acc;
      }, {} as Record<string, number>);

      // Connectivity distribution
      const connectivityDistribution = devices.reduce((acc, device) => {
        acc[device.connectivityType] = (acc[device.connectivityType] || 0) + 1;
        return acc;
      }, {} as Record<ConnectivityType, number>);

      // Calculate system health score (0-100)
      const healthyDevices = devices.filter(d => d.isHealthy()).length;
      const systemHealthScore = totalDevices > 0 ? Math.round((healthyDevices / totalDevices) * 100) : 100;

      // Average battery level
      const averageBatteryLevel = totalDevices > 0 
        ? Math.round(devices.reduce((sum, d) => sum + d.batteryLevel, 0) / totalDevices)
        : 100;

      return {
        totalDevices,
        activeDevices,
        offlineDevices,
        devicesNeedingMaintenance,
        lowBatteryDevices,
        devicesByType,
        devicesByRoom,
        systemHealthScore,
        averageBatteryLevel,
        connectivityDistribution,
      };
    } catch (error: unknown) {
      console.error(`Failed to get smart home metrics: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get devices by room
   */
  async getDevicesByRoom(roomId: string): Promise<SmartDeviceEntity[]> {
    try {
      return await this.deviceRepository.find({
        where: { roomId },
        order: { deviceType: 'ASC', deviceName: 'ASC' }
      });
    } catch (error: unknown) {
      console.error(`Failed to get devices for room ${roomId}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Get devices by resident
   */
  async getDevicesByResident(residentId: string): Promise<SmartDeviceEntity[]> {
    try {
      return await this.deviceRepository.find({
        where: { residentId },
        order: { deviceType: 'ASC', deviceName: 'ASC' }
      });
    } catch (error: unknown) {
      console.error(`Failed to get devices for resident ${residentId}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Execute automation rule
   */
  async executeAutomationRule(rule: AutomationRule): Promise<boolean> {
    try {
      console.log(`Executing automation rule: ${rule.name}`);

      for (const action of rule.actions) {
        const device = await this.deviceRepository.findOne({ where: { id: action.deviceId } });
        if (!device || !device.isOnline) {
          console.warn(`Cannot execute action on device ${action.deviceId} - device offline or not found`);
          continue;
        }

        // Execute action based on device type
        await this.executeDeviceAction(device, action.action, action.parameters);
      }

      this.eventEmitter.emit('automation.executed', rule);
      return true;
    } catch (error: unknown) {
      console.error(`Failed to execute automation rule ${rule.name}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      return false;
    }
  }

  /**
   * Get devices needing maintenance
   */
  async getDevicesNeedingMaintenance(): Promise<SmartDeviceEntity[]> {
    try {
      const devices = await this.deviceRepository.find();
      return devices.filter(device => device.needsMaintenance() || device.requiresAttention);
    } catch (error: unknown) {
      console.error(`Failed to get devices needing maintenance: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }

  /**
   * Perform system health check
   */
  async performHealthCheck(): Promise<{ healthy: boolean; issues: string[] }> {
    try {
      const issues: string[] = [];
      const devices = await this.deviceRepository.find();

      // Check for offline devices
      const offlineDevices = devices.filter(d => !d.isOnline);
      if (offlineDevices.length > 0) {
        issues.push(`${offlineDevices.length} devices are offline`);
      }

      // Check for low battery devices
      const lowBatteryDevices = devices.filter(d => d.batteryLevel < 20);
      if (lowBatteryDevices.length > 0) {
        issues.push(`${lowBatteryDevices.length} devices have low battery`);
      }

      // Check for devices needing attention
      const attentionDevices = devices.filter(d => d.requiresAttention);
      if (attentionDevices.length > 0) {
        issues.push(`${attentionDevices.length} devices require attention`);
      }

      // Check for devices needing maintenance
      const maintenanceDevices = devices.filter(d => d.needsMaintenance());
      if (maintenanceDevices.length > 0) {
        issues.push(`${maintenanceDevices.length} devices need maintenance`);
      }

      return {
        healthy: issues.length === 0,
        issues
      };
    } catch (error: unknown) {
      console.error(`Failed to perform health check: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      return { healthy: false, issues: ['Health check failed'] };
    }
  }

  /**
   * Initialize device-specific services
   */
  private async initializeDeviceServices(device: SmartDeviceEntity): Promise<void> {
    try {
      switch (device.deviceType) {
        case DeviceType.VOICE_ASSISTANT:
        case DeviceType.SMART_SPEAKER:
          await this.voiceAssistantService.initializeDevice(device);
          break;

        case DeviceType.FALL_DETECTOR:
        case DeviceType.EMERGENCY_BUTTON:
          await this.fallDetectionService.initializeDevice(device);
          break;

        case DeviceType.SMART_LIGHT:
        case DeviceType.SMART_THERMOSTAT:
        case DeviceType.ENVIRONMENTAL_SENSOR:
        case DeviceType.AIR_QUALITY_MONITOR:
          await this.environmentService.initializeDevice(device);
          break;

        case DeviceType.SMART_LOCK:
        case DeviceType.SECURITY_CAMERA:
          await this.securityService.initializeDevice(device);
          break;
      }
    } catch (error: unknown) {
      console.error(`Failed to initialize services for device ${device.id}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
    }
  }

  /**
   * Execute action on a specific device
   */
  private async executeDeviceAction(device: SmartDeviceEntity, action: string, parameters: Record<string, any>): Promise<void> {
    try {
      switch (device.deviceType) {
        case DeviceType.SMART_LIGHT:
          if (action === 'turn_on' || action === 'turn_off') {
            await this.environmentService.controlLight(device.id, action === 'turn_on', parameters);
          } else if (action === 'set_brightness') {
            await this.environmentService.setLightBrightness(device.id, parameters.brightness);
          }
          break;

        case DeviceType.SMART_THERMOSTAT:
          if (action === 'set_temperature') {
            await this.environmentService.setTemperature(device.id, parameters.temperature);
          }
          break;

        case DeviceType.VOICE_ASSISTANT:
          if (action === 'speak') {
            await this.voiceAssistantService.speak(device.id, parameters.message);
          } else if (action === 'play_music') {
            await this.voiceAssistantService.playMusic(device.id, parameters.playlist);
          }
          break;

        case DeviceType.SMART_LOCK:
          if (action === 'lock' || action === 'unlock') {
            await this.securityService.controlLock(device.id, action === 'lock');
          }
          break;

        default:
          console.warn(`Unknown action ${action} for device type ${device.deviceType}`);
      }
    } catch (error: unknown) {
      console.error(`Failed to execute action ${action} on device ${device.id}: ${error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error"}`, error instanceof Error ? error instanceof Error ? error.stack : undefined : undefined);
      throw error;
    }
  }
}