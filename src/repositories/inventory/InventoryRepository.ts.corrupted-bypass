/**
 * @fileoverview Inventory Repository for WriteCareNotes
 * @module InventoryRepository
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Data access layer for inventory management operations
 * providing comprehensive database operations for medical supplies, equipment,
 * purchase orders, suppliers, stock movements, and maintenance records.
 * 
 * @compliance
 * - Medical Device Regulations (MDR)
 * - MHRA requirements for medical supplies
 * - CQC inventory management standards
 * - Database audit trail requirements
 */

import { Injectable } from '@nestjs/common';
import { Pool, PoolClient } from 'pg';
import { logger } from '@/utils/logger';
import {
  InventoryItem,
  Supplier,
  PurchaseOrder,
  PurchaseOrderItem,
  StockMovement,
  MaintenanceRecord,
  AssetTag,
  InventoryReport,
  StockAlert,
  BatchTracking,
  SerialNumberTracking
} from '@/entities/inventory/InventoryEntities';
import {
  InventorySearchFilters,
  CreateSupplierRequest
} from '@/services/inventory/interfaces/InventoryInterfaces';

@Injectable()
export class InventoryRepository {
  constructor(private readonly pool: Pool) {}

  // Inventory Item operations

  async createInventoryItem(inventoryItem: Partial<InventoryItem>): Promise<InventoryItem> {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      const inventoryItemQuery = `
        INSERT INTO inventory_items (
          id, item_code, name, description, category, subcategory,
          current_stock, reserved_stock, available_stock, min_stock_level,
          max_stock_level, reorder_level, reorder_quantity, unit_cost,
          unit_price, currency, unit, weight, dimensions, storage_location,
          storage_requirements, temperature_range, primary_supplier_id,
          alternative_supplier_ids, is_controlled_substance, requires_prescription,
          medical_device_class, regulatory_approvals, has_expiry_date,
          shelf_life_days, requires_maintenance, maintenance_interval_days,
          barcode, manufacturer_code, batch_tracking, serial_number_tracking,
          auto_reorder, critical_item, status, care_home_id, created_at,
          updated_at, created_by, updated_by, version, correlation_id
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
          $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28,
          $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41,
          $42, $43, $44, $45, $46
        ) RETURNING *
      `;

      const result = await client.query(inventoryItemQuery, [
        inventoryItem.id,
        inventoryItem.itemCode,
        inventoryItem.name,
        inventoryItem.description,
        inventoryItem.category,
        inventoryItem.subcategory,
        inventoryItem.currentStock,
        inventoryItem.reservedStock,
        inventoryItem.availableStock,
        inventoryItem.minStockLevel,
        inventoryItem.maxStockLevel,
        inventoryItem.reorderLevel,
        inventoryItem.reorderQuantity,
        inventoryItem.unitCost,
        inventoryItem.unitPrice,
        inventoryItem.currency,
        inventoryItem.unit,
        inventoryItem.weight,
        JSON.stringify(inventoryItem.dimensions),
        inventoryItem.storageLocation,
        JSON.stringify(inventoryItem.storageRequirements),
        JSON.stringify(inventoryItem.temperatureRange),
        inventoryItem.primarySupplierId,
        JSON.stringify(inventoryItem.alternativeSupplierIds),
        inventoryItem.isControlledSubstance,
        inventoryItem.requiresPrescription,
        inventoryItem.medicalDeviceClass,
        JSON.stringify(inventoryItem.regulatoryApprovals),
        inventoryItem.hasExpiryDate,
        inventoryItem.shelfLifeDays,
        inventoryItem.requiresMaintenance,
        inventoryItem.maintenanceIntervalDays,
        inventoryItem.barcode,
        inventoryItem.manufacturerCode,
        inventoryItem.batchTracking,
        inventoryItem.serialNumberTracking,
        inventoryItem.autoReorder,
        inventoryItem.criticalItem,
        inventoryItem.status,
        inventoryItem.careHomeId,
        inventoryItem.createdAt,
        inventoryItem.updatedAt,
        inventoryItem.createdBy,
        inventoryItem.updatedBy,
        inventoryItem.version || 1,
        inventoryItem.correlationId
      ]);

      await client.query('COMMIT');
      
      return this.mapRowToInventoryItem(result.rows[0]);

    } catch (error) {
      await client.query('ROLLBACK');
      logger.error('Failed to create inventory item', { error: error.message });
      throw error;
    } finally {
      client.release();
    }
  }  asy
nc getInventoryItem(inventoryItemId: string): Promise<InventoryItem | null> {
    const query = `
      SELECT * FROM inventory_items 
      WHERE id = $1 AND deleted_at IS NULL
    `;

    const result = await this.pool.query(query, [inventoryItemId]);
    
    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToInventoryItem(result.rows[0]);
  }

  async findInventoryItemByCode(itemCode: string): Promise<InventoryItem | null> {
    const query = `
      SELECT * FROM inventory_items 
      WHERE item_code = $1 AND deleted_at IS NULL
      LIMIT 1
    `;

    const result = await this.pool.query(query, [itemCode]);
    
    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToInventoryItem(result.rows[0]);
  }

  async findInventoryItemByBarcode(barcode: string): Promise<InventoryItem | null> {
    const query = `
      SELECT * FROM inventory_items 
      WHERE barcode = $1 AND deleted_at IS NULL
      LIMIT 1
    `;

    const result = await this.pool.query(query, [barcode]);
    
    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToInventoryItem(result.rows[0]);
  }

  async searchInventoryItems(filters: InventorySearchFilters): Promise<{ items: InventoryItem[], total: number }> {
    let whereConditions = ['i.deleted_at IS NULL'];
    let queryParams: any[] = [];
    let paramIndex = 1;

    // Build WHERE conditions
    if (filters.careHomeId) {
      whereConditions.push(`i.care_home_id = $${paramIndex}`);
      queryParams.push(filters.careHomeId);
      paramIndex++;
    }

    if (filters.category) {
      whereConditions.push(`i.category = $${paramIndex}`);
      queryParams.push(filters.category);
      paramIndex++;
    }

    if (filters.subcategory) {
      whereConditions.push(`i.subcategory = $${paramIndex}`);
      queryParams.push(filters.subcategory);
      paramIndex++;
    }

    if (filters.status) {
      whereConditions.push(`i.status = $${paramIndex}`);
      queryParams.push(filters.status);
      paramIndex++;
    }

    if (filters.lowStock) {
      whereConditions.push(`i.current_stock <= i.min_stock_level`);
    }

    if (filters.outOfStock) {
      whereConditions.push(`i.current_stock = 0`);
    }

    if (filters.criticalItems) {
      whereConditions.push(`i.critical_item = true`);
    }

    if (filters.searchTerm) {
      whereConditions.push(`(
        i.name ILIKE $${paramIndex} OR 
        i.description ILIKE $${paramIndex} OR 
        i.item_code ILIKE $${paramIndex}
      )`);
      queryParams.push(`%${filters.searchTerm}%`);
      paramIndex++;
    }

    if (filters.barcode) {
      whereConditions.push(`i.barcode = $${paramIndex}`);
      queryParams.push(filters.barcode);
      paramIndex++;
    }

    const whereClause = whereConditions.join(' AND ');

    // Count query
    const countQuery = `
      SELECT COUNT(*) as total
      FROM inventory_items i
      WHERE ${whereClause}
    `;

    const countResult = await this.pool.query(countQuery, queryParams);
    const total = parseInt(countResult.rows[0].total);

    // Main query with pagination
    const limit = filters.limit || 50;
    const offset = ((filters.page || 1) - 1) * limit;
    const sortBy = filters.sortBy || 'created_at';
    const sortOrder = filters.sortOrder || 'desc';

    const mainQuery = `
      SELECT i.*
      FROM inventory_items i
      WHERE ${whereClause}
      ORDER BY i.${sortBy} ${sortOrder}
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    queryParams.push(limit, offset);

    const result = await this.pool.query(mainQuery, queryParams);
    const items = result.rows.map(row => this.mapRowToInventoryItem(row));

    return { items, total };
  }

  async updateInventoryItemStock(
    inventoryItemId: string,
    stockLevels: { currentStock: number; availableStock: number }
  ): Promise<void> {
    const query = `
      UPDATE inventory_items 
      SET current_stock = $1, available_stock = $2, updated_at = CURRENT_TIMESTAMP
      WHERE id = $3
    `;

    await this.pool.query(query, [
      stockLevels.currentStock,
      stockLevels.availableStock,
      inventoryItemId
    ]);
  }

  async updateInventoryItemLastScanned(
    inventoryItemId: string,
    scannedDate: Date,
    scannedBy: string
  ): Promise<void> {
    const query = `
      UPDATE inventory_items 
      SET last_scanned_date = $1, last_scanned_by = $2, updated_at = CURRENT_TIMESTAMP
      WHERE id = $3
    `;

    await this.pool.query(query, [scannedDate, scannedBy, inventoryItemId]);
  }

  // Supplier operations

  async createSupplier(supplier: Partial<Supplier>): Promise<Supplier> {
    const query = `
      INSERT INTO suppliers (
        id, supplier_code, name, contact_person, email, phone,
        alternative_phone, website, address, billing_address,
        company_registration_number, vat_number, tax_id, payment_terms,
        credit_limit, currency, lead_time_days, minimum_order_value,
        auto_approval_limit, supplier_categories, certifications,
        quality_rating, gdpr_compliant, iso9001_certified,
        medical_device_license, status, preferred_supplier,
        care_home_id, created_at, updated_at, created_by,
        updated_by, correlation_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
        $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26,
        $27, $28, $29, $30, $31, $32, $33
      ) RETURNING *
    `;

    const result = await this.pool.query(query, [
      supplier.id,
      supplier.supplierCode,
      supplier.name,
      supplier.contactPerson,
      supplier.email,
      supplier.phone,
      supplier.alternativePhone,
      supplier.website,
      JSON.stringify(supplier.address),
      JSON.stringify(supplier.billingAddress),
      supplier.companyRegistrationNumber,
      supplier.vatNumber,
      supplier.taxId,
      supplier.paymentTerms,
      supplier.creditLimit,
      supplier.currency,
      supplier.leadTimeDays,
      supplier.minimumOrderValue,
      supplier.autoApprovalLimit,
      JSON.stringify(supplier.supplierCategories),
      JSON.stringify(supplier.certifications),
      supplier.qualityRating,
      supplier.gdprCompliant,
      supplier.iso9001Certified,
      supplier.medicalDeviceLicense,
      supplier.status,
      supplier.preferredSupplier,
      supplier.careHomeId,
      supplier.createdAt,
      supplier.updatedAt,
      supplier.createdBy,
      supplier.updatedBy,
      supplier.correlationId
    ]);

    return this.mapRowToSupplier(result.rows[0]);
  }

  async getSupplier(supplierId: string): Promise<Supplier | null> {
    const query = `
      SELECT * FROM suppliers 
      WHERE id = $1 AND deleted_at IS NULL
    `;

    const result = await this.pool.query(query, [supplierId]);
    
    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToSupplier(result.rows[0]);
  }

  // Purchase Order operations

  async createPurchaseOrder(purchaseOrder: Partial<PurchaseOrder>): Promise<PurchaseOrder> {
    const query = `
      INSERT INTO purchase_orders (
        id, order_number, supplier_id, order_date, requested_delivery_date,
        expected_delivery_date, priority, delivery_address, subtotal,
        tax_amount, discount_amount, total_amount, currency, payment_terms,
        status, internal_reference, supplier_reference, notes,
        care_home_id, created_at, updated_at, created_by, correlation_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
        $15, $16, $17, $18, $19, $20, $21, $22, $23
      ) RETURNING *
    `;

    const result = await this.pool.query(query, [
      purchaseOrder.id,
      purchaseOrder.orderNumber,
      purchaseOrder.supplierId,
      purchaseOrder.orderDate,
      purchaseOrder.requestedDeliveryDate,
      purchaseOrder.expectedDeliveryDate,
      purchaseOrder.priority,
      JSON.stringify(purchaseOrder.deliveryAddress),
      purchaseOrder.subtotal,
      purchaseOrder.taxAmount,
      purchaseOrder.discountAmount,
      purchaseOrder.totalAmount,
      purchaseOrder.currency,
      purchaseOrder.paymentTerms,
      purchaseOrder.status,
      purchaseOrder.internalReference,
      purchaseOrder.supplierReference,
      purchaseOrder.notes,
      purchaseOrder.careHomeId,
      purchaseOrder.createdAt,
      purchaseOrder.updatedAt,
      purchaseOrder.createdBy,
      purchaseOrder.correlationId
    ]);

    return this.mapRowToPurchaseOrder(result.rows[0]);
  }

  async createPurchaseOrderItem(orderItem: Partial<PurchaseOrderItem>): Promise<PurchaseOrderItem> {
    const query = `
      INSERT INTO purchase_order_items (
        id, purchase_order_id, inventory_item_id, quantity, unit_price,
        line_total, received_quantity, remaining_quantity, specifications,
        brand_preference, expected_delivery_date, partial_delivery_accepted,
        quality_standards, certification_required, status, created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
      ) RETURNING *
    `;

    const result = await this.pool.query(query, [
      orderItem.id,
      orderItem.purchaseOrderId,
      orderItem.inventoryItemId,
      orderItem.quantity,
      orderItem.unitPrice,
      orderItem.lineTotal,
      orderItem.receivedQuantity || 0,
      orderItem.quantity, // remaining quantity initially equals ordered quantity
      orderItem.specifications,
      orderItem.brandPreference,
      orderItem.expectedDeliveryDate,
      orderItem.partialDeliveryAccepted,
      JSON.stringify(orderItem.qualityStandards),
      orderItem.certificationRequired,
      orderItem.status,
      new Date(),
      new Date()
    ]);

    return this.mapRowToPurchaseOrderItem(result.rows[0]);
  }

  // Stock Movement operations

  async createStockMovement(stockMovement: Partial<StockMovement>): Promise<StockMovement> {
    const query = `
      INSERT INTO stock_movements (
        id, inventory_item_id, movement_type, quantity, previous_stock,
        new_stock, reason, reference, batch_number, serial_numbers,
        expiry_date, from_location, to_location, unit_cost, total_cost,
        quality_status, condition_notes, purchase_order_id,
        purchase_order_item_id, document_reference, attachments,
        movement_date, care_home_id, created_at, performed_by, correlation_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
        $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
      ) RETURNING *
    `;

    const result = await this.pool.query(query, [
      stockMovement.id,
      stockMovement.inventoryItemId,
      stockMovement.movementType,
      stockMovement.quantity,
      stockMovement.previousStock,
      stockMovement.newStock,
      stockMovement.reason,
      stockMovement.reference,
      stockMovement.batchNumber,
      JSON.stringify(stockMovement.serialNumbers),
      stockMovement.expiryDate,
      stockMovement.fromLocation,
      stockMovement.toLocation,
      stockMovement.unitCost,
      stockMovement.totalCost,
      stockMovement.qualityStatus,
      stockMovement.conditionNotes,
      stockMovement.purchaseOrderId,
      stockMovement.purchaseOrderItemId,
      stockMovement.documentReference,
      JSON.stringify(stockMovement.attachments),
      stockMovement.movementDate,
      stockMovement.careHomeId,
      stockMovement.createdAt,
      stockMovement.performedBy,
      stockMovement.correlationId
    ]);

    return this.mapRowToStockMovement(result.rows[0]);
  }

  // Maintenance Record operations

  async createMaintenanceRecord(maintenanceRecord: Partial<MaintenanceRecord>): Promise<MaintenanceRecord> {
    const query = `
      INSERT INTO maintenance_records (
        id, inventory_item_id, maintenance_type, description, instructions,
        scheduled_date, estimated_duration, priority, required_skills,
        required_tools, required_parts, internal_maintenance,
        service_provider_id, estimated_cost, regulatory_requirement,
        compliance_standard, certification_required, status,
        care_home_id, created_at, updated_at, scheduled_by, correlation_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
        $15, $16, $17, $18, $19, $20, $21, $22, $23
      ) RETURNING *
    `;

    const result = await this.pool.query(query, [
      maintenanceRecord.id,
      maintenanceRecord.inventoryItemId,
      maintenanceRecord.maintenanceType,
      maintenanceRecord.description,
      maintenanceRecord.instructions,
      maintenanceRecord.scheduledDate,
      maintenanceRecord.estimatedDuration,
      maintenanceRecord.priority,
      JSON.stringify(maintenanceRecord.requiredSkills),
      JSON.stringify(maintenanceRecord.requiredTools),
      JSON.stringify(maintenanceRecord.requiredParts),
      maintenanceRecord.internalMaintenance,
      maintenanceRecord.serviceProviderId,
      maintenanceRecord.estimatedCost,
      maintenanceRecord.regulatoryRequirement,
      maintenanceRecord.complianceStandard,
      maintenanceRecord.certificationRequired,
      maintenanceRecord.status,
      maintenanceRecord.careHomeId,
      maintenanceRecord.createdAt,
      maintenanceRecord.updatedAt,
      maintenanceRecord.scheduledBy,
      maintenanceRecord.correlationId
    ]);

    return this.mapRowToMaintenanceRecord(result.rows[0]);
  }

  // Report operations

  async createInventoryReport(inventoryReport: InventoryReport): Promise<InventoryReport> {
    const query = `
      INSERT INTO inventory_reports (
        id, report_type, care_home_id, period, start_date, end_date,
        data, summary, generated_at, generated_by, format, correlation_id
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
      ) RETURNING *
    `;

    const result = await this.pool.query(query, [
      inventoryReport.id,
      inventoryReport.reportType,
      inventoryReport.careHomeId,
      inventoryReport.period,
      inventoryReport.startDate,
      inventoryReport.endDate,
      JSON.stringify(inventoryReport.data),
      JSON.stringify(inventoryReport.summary),
      inventoryReport.generatedAt,
      inventoryReport.generatedBy,
      inventoryReport.format,
      inventoryReport.correlationId
    ]);

    return this.mapRowToInventoryReport(result.rows[0]);
  }

  // Private mapping methods

  private mapRowToInventoryItem(row: any): InventoryItem {
    return {
      id: row.id,
      itemCode: row.item_code,
      name: row.name,
      description: row.description,
      category: row.category,
      subcategory: row.subcategory,
      currentStock: row.current_stock,
      reservedStock: row.reserved_stock,
      availableStock: row.available_stock,
      minStockLevel: row.min_stock_level,
      maxStockLevel: row.max_stock_level,
      reorderLevel: row.reorder_level,
      reorderQuantity: row.reorder_quantity,
      unitCost: row.unit_cost,
      unitPrice: row.unit_price,
      currency: row.currency,
      unit: row.unit,
      weight: row.weight,
      dimensions: row.dimensions ? JSON.parse(row.dimensions) : null,
      storageLocation: row.storage_location,
      storageRequirements: row.storage_requirements ? JSON.parse(row.storage_requirements) : [],
      temperatureRange: row.temperature_range ? JSON.parse(row.temperature_range) : null,
      primarySupplierId: row.primary_supplier_id,
      alternativeSupplierIds: row.alternative_supplier_ids ? JSON.parse(row.alternative_supplier_ids) : [],
      isControlledSubstance: row.is_controlled_substance,
      requiresPrescription: row.requires_prescription,
      medicalDeviceClass: row.medical_device_class,
      regulatoryApprovals: row.regulatory_approvals ? JSON.parse(row.regulatory_approvals) : [],
      hasExpiryDate: row.has_expiry_date,
      shelfLifeDays: row.shelf_life_days,
      requiresMaintenance: row.requires_maintenance,
      maintenanceIntervalDays: row.maintenance_interval_days,
      barcode: row.barcode,
      manufacturerCode: row.manufacturer_code,
      batchTracking: row.batch_tracking,
      serialNumberTracking: row.serial_number_tracking,
      autoReorder: row.auto_reorder,
      criticalItem: row.critical_item,
      status: row.status,
      lastStockCheck: row.last_stock_check,
      lastMovementDate: row.last_movement_date,
      lastScannedDate: row.last_scanned_date,
      lastScannedBy: row.last_scanned_by,
      careHomeId: row.care_home_id,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      createdBy: row.created_by,
      updatedBy: row.updated_by,
      version: row.version,
      correlationId: row.correlation_id
    };
  }

  private mapRowToSupplier(row: any): Supplier {
    return {
      id: row.id,
      supplierCode: row.supplier_code,
      name: row.name,
      contactPerson: row.contact_person,
      email: row.email,
      phone: row.phone,
      alternativePhone: row.alternative_phone,
      website: row.website,
      address: JSON.parse(row.address),
      billingAddress: row.billing_address ? JSON.parse(row.billing_address) : null,
      companyRegistrationNumber: row.company_registration_number,
      vatNumber: row.vat_number,
      taxId: row.tax_id,
      paymentTerms: row.payment_terms,
      creditLimit: row.credit_limit,
      currency: row.currency,
      leadTimeDays: row.lead_time_days,
      minimumOrderValue: row.minimum_order_value,
      autoApprovalLimit: row.auto_approval_limit,
      supplierCategories: JSON.parse(row.supplier_categories),
      certifications: row.certifications ? JSON.parse(row.certifications) : [],
      qualityRating: row.quality_rating,
      gdprCompliant: row.gdpr_compliant,
      iso9001Certified: row.iso9001_certified,
      medicalDeviceLicense: row.medical_device_license,
      status: row.status,
      preferredSupplier: row.preferred_supplier,
      careHomeId: row.care_home_id,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      createdBy: row.created_by,
      updatedBy: row.updated_by,
      correlationId: row.correlation_id
    };
  }

  private mapRowToPurchaseOrder(row: any): PurchaseOrder {
    return {
      id: row.id,
      orderNumber: row.order_number,
      supplierId: row.supplier_id,
      orderDate: row.order_date,
      requestedDeliveryDate: row.requested_delivery_date,
      expectedDeliveryDate: row.expected_delivery_date,
      actualDeliveryDate: row.actual_delivery_date,
      priority: row.priority,
      deliveryAddress: row.delivery_address ? JSON.parse(row.delivery_address) : null,
      subtotal: row.subtotal,
      taxAmount: row.tax_amount,
      discountAmount: row.discount_amount,
      totalAmount: row.total_amount,
      currency: row.currency,
      paymentTerms: row.payment_terms,
      status: row.status,
      approvalStatus: row.approval_status,
      approvedBy: row.approved_by,
      approvedAt: row.approved_at,
      internalReference: row.internal_reference,
      supplierReference: row.supplier_reference,
      notes: row.notes,
      careHomeId: row.care_home_id,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      createdBy: row.created_by,
      updatedBy: row.updated_by,
      correlationId: row.correlation_id
    };
  }

  private mapRowToPurchaseOrderItem(row: any): PurchaseOrderItem {
    return {
      id: row.id,
      purchaseOrderId: row.purchase_order_id,
      inventoryItemId: row.inventory_item_id,
      quantity: row.quantity,
      unitPrice: row.unit_price,
      lineTotal: row.line_total,
      receivedQuantity: row.received_quantity,
      remainingQuantity: row.remaining_quantity,
      specifications: row.specifications,
      brandPreference: row.brand_preference,
      expectedDeliveryDate: row.expected_delivery_date,
      partialDeliveryAccepted: row.partial_delivery_accepted,
      qualityStandards: row.quality_standards ? JSON.parse(row.quality_standards) : [],
      certificationRequired: row.certification_required,
      status: row.status,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }

  private mapRowToStockMovement(row: any): StockMovement {
    return {
      id: row.id,
      inventoryItemId: row.inventory_item_id,
      movementType: row.movement_type,
      quantity: row.quantity,
      previousStock: row.previous_stock,
      newStock: row.new_stock,
      reason: row.reason,
      reference: row.reference,
      batchNumber: row.batch_number,
      serialNumbers: row.serial_numbers ? JSON.parse(row.serial_numbers) : [],
      expiryDate: row.expiry_date,
      fromLocation: row.from_location,
      toLocation: row.to_location,
      unitCost: row.unit_cost,
      totalCost: row.total_cost,
      qualityStatus: row.quality_status,
      conditionNotes: row.condition_notes,
      purchaseOrderId: row.purchase_order_id,
      purchaseOrderItemId: row.purchase_order_item_id,
      documentReference: row.document_reference,
      attachments: row.attachments ? JSON.parse(row.attachments) : [],
      movementDate: row.movement_date,
      careHomeId: row.care_home_id,
      createdAt: row.created_at,
      performedBy: row.performed_by,
      correlationId: row.correlation_id
    };
  }

  private mapRowToMaintenanceRecord(row: any): MaintenanceRecord {
    return {
      id: row.id,
      inventoryItemId: row.inventory_item_id,
      maintenanceType: row.maintenance_type,
      description: row.description,
      instructions: row.instructions,
      scheduledDate: row.scheduled_date,
      startedAt: row.started_at,
      completedAt: row.completed_at,
      estimatedDuration: row.estimated_duration,
      actualDuration: row.actual_duration,
      priority: row.priority,
      requiredSkills: row.required_skills ? JSON.parse(row.required_skills) : [],
      requiredTools: row.required_tools ? JSON.parse(row.required_tools) : [],
      requiredParts: row.required_parts ? JSON.parse(row.required_parts) : [],
      internalMaintenance: row.internal_maintenance,
      serviceProviderId: row.service_provider_id,
      technicianId: row.technician_id,
      technicianName: row.technician_name,
      estimatedCost: row.estimated_cost,
      actualCost: row.actual_cost,
      laborCost: row.labor_cost,
      partsCost: row.parts_cost,
      findings: row.findings,
      workPerformed: row.work_performed,
      partsReplaced: row.parts_replaced ? JSON.parse(row.parts_replaced) : [],
      recommendations: row.recommendations,
      regulatoryRequirement: row.regulatory_requirement,
      complianceStandard: row.compliance_standard,
      certificationRequired: row.certification_required,
      certificateNumber: row.certificate_number,
      certificateUrl: row.certificate_url,
      nextMaintenanceDate: row.next_maintenance_date,
      nextMaintenanceType: row.next_maintenance_type,
      status: row.status,
      workOrderNumber: row.work_order_number,
      attachments: row.attachments ? JSON.parse(row.attachments) : [],
      careHomeId: row.care_home_id,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      scheduledBy: row.scheduled_by,
      completedBy: row.completed_by,
      correlationId: row.correlation_id
    };
  }

  private mapRowToInventoryReport(row: any): InventoryReport {
    return {
      id: row.id,
      reportType: row.report_type,
      careHomeId: row.care_home_id,
      period: row.period,
      startDate: row.start_date,
      endDate: row.end_date,
      data: JSON.parse(row.data),
      summary: JSON.parse(row.summary),
      generatedAt: row.generated_at,
      generatedBy: row.generated_by,
      format: row.format,
      fileUrl: row.file_url,
      fileSize: row.file_size,
      correlationId: row.correlation_id
    };
  }
}