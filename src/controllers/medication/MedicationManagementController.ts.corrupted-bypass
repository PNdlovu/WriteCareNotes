import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Comprehensive Medication Management API Controller for WriteCareNotes
 * @module MedicationManagementController
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Unified RESTful API controller for all medication management operations
 * including prescriptions, administration, safety checks, inventory, reconciliation,
 * and compliance across all British Isles healthcare jurisdictions.
 * 
 * @compliance
 * - NICE Clinical Guidelines for medication management
 * - Royal Pharmaceutical Society Guidelines
 * - CQC Regulation 12 - Safe care and treatment
 * - MHRA regulations for controlled substances
 * - GDPR and Data Protection Act 2018
 * 
 * @security
 * - Role-based access control with healthcare-specific permissions
 * - Input validation and sanitization
 * - Rate limiting protection
 * - Comprehensive audit logging
 * - Field-level encryption for sensitive data
 */

import { Request, Response } from 'express';
import Joi from 'joi';
import { PrescriptionService } from '../../services/medication/PrescriptionService';
import { MedicationAdministrationService } from '../../services/medication/MedicationAdministrationService';
import { ClinicalSafetyService } from '../../services/medication/ClinicalSafetyService';
import { MedicationInventoryService } from '../../services/medication/MedicationInventoryService';
import { MedicationReconciliationService } from '../../services/medication/MedicationReconciliationService';
import { MedicationInteractionService } from '../../services/medication/MedicationInteractionService';
import { MedicationReviewService } from '../../services/medication/MedicationReviewService';
import { MedicationSchedulingService } from '../../services/medication/MedicationSchedulingService';
import { MedicationRegulatoryComplianceService } from '../../services/medication/MedicationRegulatoryComplianceService';
import { HealthcareSystemIntegrationService } from '../../services/medication/HealthcareSystemIntegrationService';
import { logger } from '../../utils/logger';

export class MedicationManagementController {
  private prescriptionService: PrescriptionService;
  private administrationService: MedicationAdministrationService;
  private clinicalSafetyService: ClinicalSafetyService;
  private inventoryService: MedicationInventoryService;
  private reconciliationService: MedicationReconciliationService;
  private interactionService: MedicationInteractionService;
  private reviewService: MedicationReviewService;
  private schedulingService: MedicationSchedulingService;
  private complianceService: MedicationRegulatoryComplianceService;
  private integrationService: HealthcareSystemIntegrationService;

  constructor() {
    this.prescriptionService = new PrescriptionService();
    this.administrationService = new MedicationAdministrationService();
    this.clinicalSafetyService = new ClinicalSafetyService();
    this.inventoryService = new MedicationInventoryService();
    this.reconciliationService = new MedicationReconciliationService();
    this.interactionService = new MedicationInteractionService();
    this.reviewService = new MedicationReviewService();
    this.schedulingService = new MedicationSchedulingService();
    this.complianceService = new MedicationRegulatoryComplianceService();
    this.integrationService = new HealthcareSystemIntegrationService();
  }

  /**
   * @swagger
   * /api/v1/medication-management/dashboard/{residentId}:
   *   get:
   *     summary: Get comprehensive medication dashboard for a resident
   *     description: Retrieves complete medication overview including active prescriptions, recent administrations, safety alerts, and upcoming doses
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - in: path
   *         name: residentId
   *         required: true
   *         schema:
   *           type: string
   *         description: Resident ID
   *     responses:
   *       200:
   *         description: Medication dashboard retrieved successfully
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 success:
   *                   type: boolean
   *                 data:
   *                   type: object
   *                   properties:
   *                     residentInfo:
   *                       type: object
   *                     activePrescriptions:
   *                       type: array
   *                     recentAdministrations:
   *                       type: array
   *                     safetyAlerts:
   *                       type: array
   *                     upcomingDoses:
   *                       type: array
   *                     inventoryStatus:
   *                       type: object
   *                     complianceMetrics:
   *                       type: object
   */
  async getMedicationDashboard(req: Request, res: Response): Promise<void> {
    try {
      const { residentId } = req.params;
      const { organizationId } = req.user;

      // Validate resident ID
      const residentIdSchema = Joi.string().uuid().required();
      const { error } = residentIdSchema.validate(residentId);
      if (error) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_RESIDENT_ID',
            message: 'Invalid resident ID format',
            details: error.details
          }
        });
        return;
      }

      // Fetch comprehensive medication data
      const [
        activePrescriptions,
        recentAdministrations,
        safetyAlerts,
        upcomingDoses,
        inventoryStatus,
        complianceMetrics
      ] = await Promise.all([
        this.prescriptionService.getActivePrescriptions(residentId, organizationId),
        this.administrationService.getRecentAdministrations(residentId, organizationId, 7), // Last 7 days
        this.clinicalSafetyService.getActiveAlerts(residentId, organizationId),
        this.schedulingService.getUpcomingDoses(residentId, organizationId, 24), // Next 24 hours
        this.inventoryService.getResidentInventoryStatus(residentId, organizationId),
        this.complianceService.getResidentComplianceMetrics(residentId, organizationId)
      ]);

      // Get resident basic info
      const residentInfo = {
        id: residentId,
        // Additional resident info would be fetched from resident service
      };

      const dashboardData = {
        residentInfo,
        activePrescriptions,
        recentAdministrations,
        safetyAlerts,
        upcomingDoses,
        inventoryStatus,
        complianceMetrics,
        lastUpdated: new Date().toISOString()
      };

      res.status(200).json({
        success: true,
        data: dashboardData,
        meta: {
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('Medication dashboard retrieved', {
        residentId,
        userId: req.user.id,
        organizationId,
        activePrescriptions: activePrescriptions.length,
        safetyAlerts: safetyAlerts.length
      });

    } catch (error: unknown) {
      console.error('Error retrieving medication dashboard', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        residentId: req.params['residentId'],
        userId: req.user?.id,
        organizationId: req.user?.organizationId
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to retrieve medication dashboard',
          correlationId: req.correlationId
        }
      });
    }
  }

  /**
   * @swagger
   * /api/v1/medication-management/safety-check:
   *   post:
   *     summary: Perform comprehensive medication safety check
   *     description: Conducts drug interaction, allergy, and contraindication checks for medication combinations
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - residentId
   *               - medications
   *             properties:
   *               residentId:
   *                 type: string
   *                 description: Resident ID
   *               medications:
   *                 type: array
   *                 items:
   *                   type: object
   *                   properties:
   *                     medicationId:
   *                       type: string
   *                     dosage:
   *                       type: string
   *                     frequency:
   *                       type: string
   *               checkType:
   *                 type: string
   *                 enum: [comprehensive, interactions_only, allergies_only, contraindications_only]
   *                 default: comprehensive
   *     responses:
   *       200:
   *         description: Safety check completed successfully
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 success:
   *                   type: boolean
   *                 data:
   *                   type: object
   *                   properties:
   *                     overallRisk:
   *                       type: string
   *                       enum: [low, medium, high, critical]
   *                     interactions:
   *                       type: array
   *                     allergies:
   *                       type: array
   *                     contraindications:
   *                       type: array
   *                     recommendations:
   *                       type: array
   */
  async performSafetyCheck(req: Request, res: Response): Promise<void> {
    try {
      const validationSchema = Joi.object({
        residentId: Joi.string().uuid().required(),
        medications: Joi.array().items(
          Joi.object({
            medicationId: Joi.string().required(),
            dosage: Joi.string().required(),
            frequency: Joi.string().required()
          })
        ).min(1).required(),
        checkType: Joi.string().valid('comprehensive', 'interactions_only', 'allergies_only', 'contraindications_only').default('comprehensive')
      });

      const { error, value } = validationSchema.validate(req.body);
      if (error) {
        res.status(422).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid safety check request',
            details: error.details.map(detail => ({
              field: detail.path.join('.'),
              message: detail.message
            }))
          }
        });
        return;
      }

      const { residentId, medications, checkType } = value;
      const { organizationId } = req.user;

      // Perform comprehensive safety check
      const safetyResults = await this.clinicalSafetyService.performComprehensiveSafetyCheck(
        residentId,
        medications,
        organizationId,
        checkType
      );

      // Check for drug interactions if requested
      let interactions = [];
      if (checkType === 'comprehensive' || checkType === 'interactions_only') {
        interactions = await this.interactionService.checkMultipleDrugInteractions(
          medications.map(m => m.medicationId),
          organizationId
        );
      }

      const response = {
        overallRisk: safetyResults.overallRisk,
        interactions: interactions,
        allergies: safetyResults.allergies || [],
        contraindications: safetyResults.contraindications || [],
        recommendations: safetyResults.recommendations || [],
        checkPerformed: checkType,
        timestamp: new Date().toISOString()
      };

      res.status(200).json({
        success: true,
        data: response,
        meta: {
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('Medication safety check performed', {
        residentId,
        medicationCount: medications.length,
        checkType,
        overallRisk: safetyResults.overallRisk,
        interactionsFound: interactions.length,
        userId: req.user.id,
        organizationId
      });

    } catch (error: unknown) {
      console.error('Error performing medication safety check', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId: req.user?.id,
        organizationId: req.user?.organizationId,
        requestBody: req.body
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to perform safety check',
          correlationId: req.correlationId
        }
      });
    }
  }

  /**
   * @swagger
   * /api/v1/medication-management/administration/record:
   *   post:
   *     summary: Record medication administration
   *     description: Records medication administration with safety checks and witness verification
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - prescriptionId
   *               - administeredBy
   *               - administrationTime
   *               - dosageGiven
   *             properties:
   *               prescriptionId:
   *                 type: string
   *               administeredBy:
   *                 type: string
   *               administrationTime:
   *                 type: string
   *                 format: date-time
   *               dosageGiven:
   *                 type: string
   *               route:
   *                 type: string
   *               witnessId:
   *                 type: string
   *               notes:
   *                 type: string
   *               refusalReason:
   *                 type: string
   *     responses:
   *       201:
   *         description: Administration recorded successfully
   */
  async recordAdministration(req: Request, res: Response): Promise<void> {
    try {
      const validationSchema = Joi.object({
        prescriptionId: Joi.string().uuid().required(),
        administeredBy: Joi.string().required(),
        administrationTime: Joi.date().iso().required(),
        dosageGiven: Joi.string().required(),
        route: Joi.string().required(),
        witnessId: Joi.string().optional(),
        notes: Joi.string().max(1000).optional(),
        refusalReason: Joi.string().max(500).optional()
      });

      const { error, value } = validationSchema.validate(req.body);
      if (error) {
        res.status(422).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid administration data',
            details: error.details.map(detail => ({
              field: detail.path.join('.'),
              message: detail.message
            }))
          }
        });
        return;
      }

      const { organizationId } = req.user;

      // Record the administration
      const administrationRecord = await this.administrationService.recordAdministration({
        ...value,
        organizationId
      }, req.user.id);

      res.status(201).json({
        success: true,
        data: administrationRecord,
        meta: {
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('Medication administration recorded', {
        administrationId: administrationRecord.id,
        prescriptionId: value.prescriptionId,
        administeredBy: value.administeredBy,
        userId: req.user.id,
        organizationId
      });

    } catch (error: unknown) {
      console.error('Error recording medication administration', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId: req.user?.id,
        organizationId: req.user?.organizationId,
        requestBody: req.body
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to record administration',
          correlationId: req.correlationId
        }
      });
    }
  }

  /**
   * @swagger
   * /api/v1/medication-management/inventory/alerts:
   *   get:
   *     summary: Get medication inventory alerts
   *     description: Retrieves low stock, expiry, and other inventory alerts
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - in: query
   *         name: alertType
   *         schema:
   *           type: string
   *           enum: [low_stock, expiry, all]
   *         description: Type of alerts to retrieve
   *       - in: query
   *         name: severity
   *         schema:
   *           type: string
   *           enum: [low, medium, high, critical]
   *         description: Minimum severity level
   *     responses:
   *       200:
   *         description: Inventory alerts retrieved successfully
   */
  async getInventoryAlerts(req: Request, res: Response): Promise<void> {
    try {
      const { alertType = 'all', severity = 'low' } = req.query;
      const { organizationId } = req.user;

      const alerts = await this.inventoryService.getInventoryAlerts(
        organizationId,
        alertType as string,
        severity as string
      );

      res.status(200).json({
        success: true,
        data: {
          alerts,
          summary: {
            total: alerts.length,
            critical: alerts.filter(a => a.severity === 'critical').length,
            high: alerts.filter(a => a.severity === 'high').length,
            medium: alerts.filter(a => a.severity === 'medium').length,
            low: alerts.filter(a => a.severity === 'low').length
          }
        },
        meta: {
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('Inventory alerts retrieved', {
        alertType,
        severity,
        alertCount: alerts.length,
        userId: req.user.id,
        organizationId
      });

    } catch (error: unknown) {
      console.error('Error retrieving inventory alerts', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId: req.user?.id,
        organizationId: req.user?.organizationId,
        query: req.query
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to retrieve inventory alerts',
          correlationId: req.correlationId
        }
      });
    }
  }

  /**
   * @swagger
   * /api/v1/medication-management/review/schedule:
   *   post:
   *     summary: Schedule medication review
   *     description: Schedules a comprehensive medication review for a resident
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - residentId
   *               - reviewType
   *               - scheduledDate
   *             properties:
   *               residentId:
   *                 type: string
   *               reviewType:
   *                 type: string
   *                 enum: [routine, clinical_change, adverse_event, admission, discharge]
   *               scheduledDate:
   *                 type: string
   *                 format: date-time
   *               reviewerId:
   *                 type: string
   *               priority:
   *                 type: string
   *                 enum: [low, medium, high, urgent]
   *               notes:
   *                 type: string
   *     responses:
   *       201:
   *         description: Medication review scheduled successfully
   */
  async scheduleMedicationReview(req: Request, res: Response): Promise<void> {
    try {
      const validationSchema = Joi.object({
        residentId: Joi.string().uuid().required(),
        reviewType: Joi.string().valid('routine', 'clinical_change', 'adverse_event', 'admission', 'discharge').required(),
        scheduledDate: Joi.date().iso().min('now').required(),
        reviewerId: Joi.string().optional(),
        priority: Joi.string().valid('low', 'medium', 'high', 'urgent').default('medium'),
        notes: Joi.string().max(1000).optional()
      });

      const { error, value } = validationSchema.validate(req.body);
      if (error) {
        res.status(422).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid review scheduling data',
            details: error.details.map(detail => ({
              field: detail.path.join('.'),
              message: detail.message
            }))
          }
        });
        return;
      }

      const { organizationId } = req.user;

      const reviewSchedule = await this.reviewService.scheduleReview({
        ...value,
        organizationId,
        scheduledBy: req.user.id
      });

      res.status(201).json({
        success: true,
        data: reviewSchedule,
        meta: {
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('Medication review scheduled', {
        reviewId: reviewSchedule.id,
        residentId: value.residentId,
        reviewType: value.reviewType,
        scheduledDate: value.scheduledDate,
        priority: value.priority,
        userId: req.user.id,
        organizationId
      });

    } catch (error: unknown) {
      console.error('Error scheduling medication review', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId: req.user?.id,
        organizationId: req.user?.organizationId,
        requestBody: req.body
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to schedule medication review',
          correlationId: req.correlationId
        }
      });
    }
  }

  /**
   * @swagger
   * /api/v1/medication-management/compliance/summary:
   *   get:
   *     summary: Get medication compliance summary
   *     description: Retrieves comprehensive compliance metrics and regulatory status
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - in: query
   *         name: period
   *         schema:
   *           type: string
   *           enum: [daily, weekly, monthly, quarterly, yearly]
   *         description: Reporting period
   *       - in: query
   *         name: includeDetails
   *         schema:
   *           type: boolean
   *         description: Include detailed compliance breakdown
   *     responses:
   *       200:
   *         description: Compliance summary retrieved successfully
   */
  async getComplianceSummary(req: Request, res: Response): Promise<void> {
    try {
      const { period = 'monthly', includeDetails = false } = req.query;
      const { organizationId } = req.user;

      // Verify user has appropriate permissions for compliance data
      if (!req.user.roles.includes('administrator') && 
          !req.user.roles.includes('compliance_manager') &&
          !req.user.roles.includes('clinical_manager')) {
        res.status(403).json({
          success: false,
          error: {
            code: 'FORBIDDEN',
            message: 'Insufficient permissions to access compliance data'
          }
        });
        return;
      }

      const complianceSummary = await this.complianceService.generateComplianceSummary(
        organizationId,
        period as string,
        includeDetails as boolean
      );

      res.status(200).json({
        success: true,
        data: complianceSummary,
        meta: {
          period,
          includeDetails,
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('Compliance summary retrieved', {
        period,
        includeDetails,
        overallScore: complianceSummary.overallScore,
        userId: req.user.id,
        organizationId
      });

    } catch (error: unknown) {
      console.error('Error retrieving compliance summary', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId: req.user?.id,
        organizationId: req.user?.organizationId,
        query: req.query
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to retrieve compliance summary',
          correlationId: req.correlationId
        }
      });
    }
  }

  /**
   * @swagger
   * /api/v1/medication-management/integration/sync:
   *   post:
   *     summary: Synchronize with external healthcare systems
   *     description: Triggers synchronization with NHS Digital, GP systems, and pharmacy systems
   *     tags: [Medication Management]
   *     security:
   *       - bearerAuth: []
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - syncType
   *             properties:
   *               syncType:
   *                 type: string
   *                 enum: [full, prescriptions_only, residents_only, selective]
   *               residentIds:
   *                 type: array
   *                 items:
   *                   type: string
   *               systems:
   *                 type: array
   *                 items:
   *                   type: string
   *                   enum: [nhs_digital, gp_systems, pharmacy_systems]
   *     responses:
   *       202:
   *         description: Synchronization initiated successfully
   */
  async initiateSystemSync(req: Request, res: Response): Promise<void> {
    try {
      // Verify user has appropriate permissions for system integration
      if (!req.user.roles.includes('administrator') && 
          !req.user.roles.includes('system_manager')) {
        res.status(403).json({
          success: false,
          error: {
            code: 'FORBIDDEN',
            message: 'Insufficient permissions to initiate system synchronization'
          }
        });
        return;
      }

      const validationSchema = Joi.object({
        syncType: Joi.string().valid('full', 'prescriptions_only', 'residents_only', 'selective').required(),
        residentIds: Joi.array().items(Joi.string().uuid()).when('syncType', {
          is: 'selective',
          then: Joi.required(),
          otherwise: Joi.optional()
        }),
        systems: Joi.array().items(Joi.string().valid('nhs_digital', 'gp_systems', 'pharmacy_systems')).default(['nhs_digital', 'gp_systems', 'pharmacy_systems'])
      });

      const { error, value } = validationSchema.validate(req.body);
      if (error) {
        res.status(422).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid synchronization request',
            details: error.details.map(detail => ({
              field: detail.path.join('.'),
              message: detail.message
            }))
          }
        });
        return;
      }

      const { organizationId } = req.user;

      // Initiate synchronization
      const syncJob = await this.integrationService.initiateSynchronization({
        ...value,
        organizationId,
        initiatedBy: req.user.id
      });

      res.status(202).json({
        success: true,
        data: {
          syncJobId: syncJob.id,
          status: syncJob.status,
          estimatedCompletion: syncJob.estimatedCompletion,
          systems: value.systems,
          syncType: value.syncType
        },
        meta: {
          timestamp: new Date().toISOString(),
          version: '1.0.0'
        }
      });

      console.info('System synchronization initiated', {
        syncJobId: syncJob.id,
        syncType: value.syncType,
        systems: value.systems,
        residentCount: value.residentIds?.length || 0,
        userId: req.user.id,
        organizationId
      });

    } catch (error: unknown) {
      console.error('Error initiating system synchronization', {
        error: error instanceof Error ? error instanceof Error ? error.message : "Unknown error" : "Unknown error",
        userId: req.user?.id,
        organizationId: req.user?.organizationId,
        requestBody: req.body
      });

      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to initiate system synchronization',
          correlationId: req.correlationId
        }
      });
    }
  }
}