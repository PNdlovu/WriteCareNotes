import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Payment Controller for WriteCareNotes
 * @module PaymentController
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive payment processing controller with healthcare payment features,
 * reconciliation, and compliance reporting for care home operations.
 * 
 * @compliance
 * - PCI DSS (Payment Card Industry Data Security Standard)
 * - SOX (Sarbanes-Oxley Act) compliance
 * - GDPR Article 6 & 9 (Financial data processing)
 * - FCA (Financial Conduct Authority) regulations
 * - PSD2 (Payment Services Directive 2) compliance
 */

import { Controller, Get, Post, Put, Delete, Body, Param, Query, Req, Res, HttpStatus, UseGuards, ValidationPipe } from '@nestjs/common';
import { Request, Response } from 'express';
import { PaymentService, CreatePaymentRequest, ProcessPaymentRequest, PaymentFilters, PaymentListResponse, RefundPaymentRequest } from '@/services/financial/PaymentService';
import { Payment, PaymentStatus, PaymentMethod, PaymentType } from '@/entities/financial/Payment';
import { JwtAuthGuard } from '@/guards/JwtAuthGuard';
import { RoleGuard } from '@/guards/RoleGuard';
import { Roles } from '@/decorators/Roles';
import { User } from '@/decorators/User';
import { ApiTags, ApiOperation, ApiResponse, ApiParam, ApiQuery, ApiBearerAuth } from '@nestjs/swagger';
import { CreatePaymentDto, ProcessPaymentDto, RefundPaymentDto, PaymentFiltersDto } from '@/dto/financial/PaymentDto';
import { logger } from '@/utils/logger';

@ApiTags('Financial - Payments')
@ApiBearerAuth()
@Controller('financial/payments')
@UseGuards(JwtAuthGuard, RoleGuard)
export class PaymentController {
  constructor(private readonly paymentService: PaymentService) {}

  /**
   * Create a new payment
   */
  @Post()
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Create a new payment' })
  @ApiResponse({ status: 201, description: 'Payment created successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  @ApiResponse({ status: 500, description: 'Internal server error' })
  async createPayment(
    @Body(ValidationPipe) createPaymentDto: CreatePaymentDto,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Creating payment for ${createPaymentDto.paymentType}`, {
        userId: user.id,
        paymentType: createPaymentDto.paymentType,
        amount: createPaymentDto.amount,
        auditTrail: true
      });

      const request: CreatePaymentRequest = {
        ...createPaymentDto,
        processedBy: user.id,
      };

      const payment = await this.paymentService.createPayment(request);

      res.status(HttpStatus.CREATED).json({
        success: true,
        message: 'Payment created successfully',
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to create payment: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to create payment',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get payment by ID
   */
  @Get(':id')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get payment by ID' })
  @ApiParam({ name: 'id', description: 'Payment ID' })
  @ApiResponse({ status: 200, description: 'Payment retrieved successfully' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getPayment(
    @Param('id') id: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Retrieving payment: ${id}`, {
        userId: user.id,
        paymentId: id,
        auditTrail: true
      });

      const payment = await this.paymentService.getPaymentById(id);

      if (!payment) {
        res.status(HttpStatus.NOT_FOUND).json({
          success: false,
          message: 'Payment not found',
          timestamp: new Date().toISOString()
        });
        return;
      }

      res.status(HttpStatus.OK).json({
        success: true,
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve payment: ${error.message}`, {
        userId: user.id,
        paymentId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve payment',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * List payments with filters
   */
  @Get()
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'List payments with filters' })
  @ApiQuery({ name: 'status', required: false, description: 'Payment status filter' })
  @ApiQuery({ name: 'paymentMethod', required: false, description: 'Payment method filter' })
  @ApiQuery({ name: 'paymentType', required: false, description: 'Payment type filter' })
  @ApiQuery({ name: 'invoiceId', required: false, description: 'Invoice ID filter' })
  @ApiQuery({ name: 'dateFrom', required: false, description: 'Start date filter' })
  @ApiQuery({ name: 'dateTo', required: false, description: 'End date filter' })
  @ApiQuery({ name: 'amountFrom', required: false, description: 'Minimum amount filter' })
  @ApiQuery({ name: 'amountTo', required: false, description: 'Maximum amount filter' })
  @ApiQuery({ name: 'isReconciled', required: false, description: 'Reconciled payments filter' })
  @ApiQuery({ name: 'search', required: false, description: 'Search term' })
  @ApiQuery({ name: 'page', required: false, description: 'Page number' })
  @ApiQuery({ name: 'limit', required: false, description: 'Items per page' })
  @ApiQuery({ name: 'sortBy', required: false, description: 'Sort field' })
  @ApiQuery({ name: 'sortOrder', required: false, description: 'Sort order' })
  @ApiResponse({ status: 200, description: 'Payments retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async listPayments(
    @Query() query: any,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info('Listing payments with filters', {
        userId: user.id,
        filters: query,
        auditTrail: true
      });

      const filters: PaymentFilters = {
        status: query.status ? (Array.isArray(query.status) ? query.status : [query.status]) : undefined,
        paymentMethod: query.paymentMethod ? (Array.isArray(query.paymentMethod) ? query.paymentMethod : [query.paymentMethod]) : undefined,
        paymentType: query.paymentType ? (Array.isArray(query.paymentType) ? query.paymentType : [query.paymentType]) : undefined,
        invoiceId: query.invoiceId,
        dateFrom: query.dateFrom ? new Date(query.dateFrom) : undefined,
        dateTo: query.dateTo ? new Date(query.dateTo) : undefined,
        amountFrom: query.amountFrom ? parseFloat(query.amountFrom) : undefined,
        amountTo: query.amountTo ? parseFloat(query.amountTo) : undefined,
        isReconciled: query.isReconciled === 'true',
        search: query.search,
        page: query.page ? parseInt(query.page) : undefined,
        limit: query.limit ? parseInt(query.limit) : undefined,
        sortBy: query.sortBy,
        sortOrder: query.sortOrder,
      };

      const result: PaymentListResponse = await this.paymentService.listPayments(filters);

      res.status(HttpStatus.OK).json({
        success: true,
        data: result,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to list payments: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to list payments',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Process a payment
   */
  @Post(':id/process')
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Process a payment' })
  @ApiParam({ name: 'id', description: 'Payment ID' })
  @ApiResponse({ status: 200, description: 'Payment processed successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async processPayment(
    @Param('id') id: string,
    @Body(ValidationPipe) processPaymentDto: ProcessPaymentDto,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Processing payment: ${id}`, {
        userId: user.id,
        paymentId: id,
        auditTrail: true
      });

      const request: ProcessPaymentRequest = {
        paymentId: id,
        ...processPaymentDto,
        processedBy: user.id,
      };

      const payment = await this.paymentService.processPayment(request);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Payment processed successfully',
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to process payment: ${error.message}`, {
        userId: user.id,
        paymentId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to process payment',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Complete a payment
   */
  @Post(':id/complete')
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Complete a payment' })
  @ApiParam({ name: 'id', description: 'Payment ID' })
  @ApiResponse({ status: 200, description: 'Payment completed successfully' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async completePayment(
    @Param('id') id: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Completing payment: ${id}`, {
        userId: user.id,
        paymentId: id,
        auditTrail: true
      });

      const payment = await this.paymentService.completePayment(id, user.id);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Payment completed successfully',
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to complete payment: ${error.message}`, {
        userId: user.id,
        paymentId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to complete payment',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Fail a payment
   */
  @Post(':id/fail')
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Fail a payment' })
  @ApiParam({ name: 'id', description: 'Payment ID' })
  @ApiResponse({ status: 200, description: 'Payment failed successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async failPayment(
    @Param('id') id: string,
    @Body() body: { reason: string },
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Failing payment: ${id}`, {
        userId: user.id,
        paymentId: id,
        reason: body.reason,
        auditTrail: true
      });

      const payment = await this.paymentService.failPayment(id, user.id, body.reason);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Payment failed successfully',
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to fail payment: ${error.message}`, {
        userId: user.id,
        paymentId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to fail payment',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Process refund for payment
   */
  @Post(':id/refund')
  @Roles('admin', 'finance_manager')
  @ApiOperation({ summary: 'Process refund for payment' })
  @ApiParam({ name: 'id', description: 'Payment ID' })
  @ApiResponse({ status: 200, description: 'Refund processed successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async processRefund(
    @Param('id') id: string,
    @Body(ValidationPipe) refundPaymentDto: RefundPaymentDto,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Processing refund for payment: ${id}`, {
        userId: user.id,
        paymentId: id,
        amount: refundPaymentDto.amount,
        reason: refundPaymentDto.reason,
        auditTrail: true
      });

      const request: RefundPaymentRequest = {
        paymentId: id,
        ...refundPaymentDto,
        refundedBy: user.id,
      };

      const payment = await this.paymentService.processRefund(request);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Refund processed successfully',
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to process refund: ${error.message}`, {
        userId: user.id,
        paymentId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to process refund',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Reconcile payments
   */
  @Post('reconcile')
  @Roles('admin', 'finance_manager')
  @ApiOperation({ summary: 'Reconcile multiple payments' })
  @ApiResponse({ status: 200, description: 'Payments reconciled successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async reconcilePayments(
    @Body() body: { paymentIds: string[] },
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Reconciling ${body.paymentIds.length} payments`, {
        userId: user.id,
        paymentIds: body.paymentIds,
        auditTrail: true
      });

      const result = await this.paymentService.reconcilePayments(body.paymentIds, user.id);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Payments reconciled successfully',
        data: result,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to reconcile payments: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to reconcile payments',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get payment statistics
   */
  @Get('statistics/summary')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get payment statistics' })
  @ApiQuery({ name: 'period', required: false, description: 'Statistics period (month, quarter, year)' })
  @ApiResponse({ status: 200, description: 'Statistics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getPaymentStatistics(
    @Query('period') period: 'month' | 'quarter' | 'year' = 'month',
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info('Retrieving payment statistics', {
        userId: user.id,
        period,
        auditTrail: true
      });

      const statistics = await this.paymentService.getPaymentStatistics(period);

      res.status(HttpStatus.OK).json({
        success: true,
        data: statistics,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve payment statistics: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve payment statistics',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get payment by payment reference
   */
  @Get('reference/:paymentReference')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get payment by payment reference' })
  @ApiParam({ name: 'paymentReference', description: 'Payment reference' })
  @ApiResponse({ status: 200, description: 'Payment retrieved successfully' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getPaymentByReference(
    @Param('paymentReference') paymentReference: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Retrieving payment by reference: ${paymentReference}`, {
        userId: user.id,
        paymentReference,
        auditTrail: true
      });

      // This would need to be implemented in the service
      // const payment = await this.paymentService.getPaymentByReference(paymentReference);

      res.status(HttpStatus.NOT_IMPLEMENTED).json({
        success: false,
        message: 'Get payment by reference not implemented',
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve payment by reference: ${error.message}`, {
        userId: user.id,
        paymentReference,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve payment by reference',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get payments for invoice
   */
  @Get('invoice/:invoiceId')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get payments for invoice' })
  @ApiParam({ name: 'invoiceId', description: 'Invoice ID' })
  @ApiResponse({ status: 200, description: 'Payments retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getPaymentsForInvoice(
    @Param('invoiceId') invoiceId: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Retrieving payments for invoice: ${invoiceId}`, {
        userId: user.id,
        invoiceId,
        auditTrail: true
      });

      const filters: PaymentFilters = {
        invoiceId,
      };

      const result: PaymentListResponse = await this.paymentService.listPayments(filters);

      res.status(HttpStatus.OK).json({
        success: true,
        data: result,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve payments for invoice: ${error.message}`, {
        userId: user.id,
        invoiceId,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve payments for invoice',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }
}

export default PaymentController;