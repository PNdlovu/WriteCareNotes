import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Invoice Controller for WriteCareNotes
 * @module InvoiceController
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description Comprehensive invoice management controller with healthcare billing features,
 * payment tracking, and compliance reporting for care home operations.
 * 
 * @compliance
 * - PCI DSS (Payment Card Industry Data Security Standard)
 * - SOX (Sarbanes-Oxley Act) compliance
 * - GDPR Article 6 & 9 (Financial data processing)
 * - FCA (Financial Conduct Authority) regulations
 * - NHS Digital standards for healthcare billing
 */

import { Controller, Get, Post, Put, Delete, Body, Param, Query, Req, Res, HttpStatus, UseGuards, ValidationPipe } from '@nestjs/common';
import { Request, Response } from 'express';
import { InvoiceService, CreateInvoiceRequest, UpdateInvoiceRequest, InvoiceFilters, InvoiceListResponse, PaymentRequest } from '@/services/financial/InvoiceService';
import { Invoice, InvoiceStatus, InvoiceType } from '@/entities/financial/Invoice';
import { Payment } from '@/entities/financial/Payment';
import { JwtAuthGuard } from '@/guards/JwtAuthGuard';
import { RoleGuard } from '@/guards/RoleGuard';
import { Roles } from '@/decorators/Roles';
import { User } from '@/decorators/User';
import { ApiTags, ApiOperation, ApiResponse, ApiParam, ApiQuery, ApiBearerAuth } from '@nestjs/swagger';
import { CreateInvoiceDto, UpdateInvoiceDto, PaymentDto, InvoiceFiltersDto } from '@/dto/financial/InvoiceDto';
import { logger } from '@/utils/logger';

@ApiTags('Financial - Invoices')
@ApiBearerAuth()
@Controller('financial/invoices')
@UseGuards(JwtAuthGuard, RoleGuard)
export class InvoiceController {
  constructor(private readonly invoiceService: InvoiceService) {}

  /**
   * Create a new invoice
   */
  @Post()
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Create a new invoice' })
  @ApiResponse({ status: 201, description: 'Invoice created successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  @ApiResponse({ status: 500, description: 'Internal server error' })
  async createInvoice(
    @Body(ValidationPipe) createInvoiceDto: CreateInvoiceDto,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Creating invoice for ${createInvoiceDto.invoiceType}`, {
        userId: user.id,
        invoiceType: createInvoiceDto.invoiceType,
        auditTrail: true
      });

      const request: CreateInvoiceRequest = {
        ...createInvoiceDto,
        createdBy: user.id,
      };

      const invoice = await this.invoiceService.createInvoice(request);

      res.status(HttpStatus.CREATED).json({
        success: true,
        message: 'Invoice created successfully',
        data: invoice,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to create invoice: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to create invoice',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get invoice by ID
   */
  @Get(':id')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get invoice by ID' })
  @ApiParam({ name: 'id', description: 'Invoice ID' })
  @ApiResponse({ status: 200, description: 'Invoice retrieved successfully' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getInvoice(
    @Param('id') id: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Retrieving invoice: ${id}`, {
        userId: user.id,
        invoiceId: id,
        auditTrail: true
      });

      const invoice = await this.invoiceService.getInvoiceById(id);

      if (!invoice) {
        res.status(HttpStatus.NOT_FOUND).json({
          success: false,
          message: 'Invoice not found',
          timestamp: new Date().toISOString()
        });
        return;
      }

      res.status(HttpStatus.OK).json({
        success: true,
        data: invoice,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve invoice: ${error.message}`, {
        userId: user.id,
        invoiceId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve invoice',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * List invoices with filters
   */
  @Get()
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'List invoices with filters' })
  @ApiQuery({ name: 'status', required: false, description: 'Invoice status filter' })
  @ApiQuery({ name: 'invoiceType', required: false, description: 'Invoice type filter' })
  @ApiQuery({ name: 'residentId', required: false, description: 'Resident ID filter' })
  @ApiQuery({ name: 'billingEntityId', required: false, description: 'Billing entity ID filter' })
  @ApiQuery({ name: 'dateFrom', required: false, description: 'Start date filter' })
  @ApiQuery({ name: 'dateTo', required: false, description: 'End date filter' })
  @ApiQuery({ name: 'amountFrom', required: false, description: 'Minimum amount filter' })
  @ApiQuery({ name: 'amountTo', required: false, description: 'Maximum amount filter' })
  @ApiQuery({ name: 'isOverdue', required: false, description: 'Overdue invoices filter' })
  @ApiQuery({ name: 'isPaid', required: false, description: 'Paid invoices filter' })
  @ApiQuery({ name: 'search', required: false, description: 'Search term' })
  @ApiQuery({ name: 'page', required: false, description: 'Page number' })
  @ApiQuery({ name: 'limit', required: false, description: 'Items per page' })
  @ApiQuery({ name: 'sortBy', required: false, description: 'Sort field' })
  @ApiQuery({ name: 'sortOrder', required: false, description: 'Sort order' })
  @ApiResponse({ status: 200, description: 'Invoices retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async listInvoices(
    @Query() query: any,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info('Listing invoices with filters', {
        userId: user.id,
        filters: query,
        auditTrail: true
      });

      const filters: InvoiceFilters = {
        status: query.status ? (Array.isArray(query.status) ? query.status : [query.status]) : undefined,
        invoiceType: query.invoiceType ? (Array.isArray(query.invoiceType) ? query.invoiceType : [query.invoiceType]) : undefined,
        residentId: query.residentId,
        billingEntityId: query.billingEntityId,
        dateFrom: query.dateFrom ? new Date(query.dateFrom) : undefined,
        dateTo: query.dateTo ? new Date(query.dateTo) : undefined,
        amountFrom: query.amountFrom ? parseFloat(query.amountFrom) : undefined,
        amountTo: query.amountTo ? parseFloat(query.amountTo) : undefined,
        isOverdue: query.isOverdue === 'true',
        isPaid: query.isPaid === 'true',
        search: query.search,
        page: query.page ? parseInt(query.page) : undefined,
        limit: query.limit ? parseInt(query.limit) : undefined,
        sortBy: query.sortBy,
        sortOrder: query.sortOrder,
      };

      const result: InvoiceListResponse = await this.invoiceService.listInvoices(filters);

      res.status(HttpStatus.OK).json({
        success: true,
        data: result,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to list invoices: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to list invoices',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Update an existing invoice
   */
  @Put(':id')
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Update an existing invoice' })
  @ApiParam({ name: 'id', description: 'Invoice ID' })
  @ApiResponse({ status: 200, description: 'Invoice updated successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async updateInvoice(
    @Param('id') id: string,
    @Body(ValidationPipe) updateInvoiceDto: UpdateInvoiceDto,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Updating invoice: ${id}`, {
        userId: user.id,
        invoiceId: id,
        auditTrail: true
      });

      const request: UpdateInvoiceRequest = {
        ...updateInvoiceDto,
        updatedBy: user.id,
      };

      const invoice = await this.invoiceService.updateInvoice(id, request);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Invoice updated successfully',
        data: invoice,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to update invoice: ${error.message}`, {
        userId: user.id,
        invoiceId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to update invoice',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Send invoice to customer
   */
  @Post(':id/send')
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Send invoice to customer' })
  @ApiParam({ name: 'id', description: 'Invoice ID' })
  @ApiResponse({ status: 200, description: 'Invoice sent successfully' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async sendInvoice(
    @Param('id') id: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Sending invoice: ${id}`, {
        userId: user.id,
        invoiceId: id,
        auditTrail: true
      });

      const invoice = await this.invoiceService.sendInvoice(id, user.id);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Invoice sent successfully',
        data: invoice,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to send invoice: ${error.message}`, {
        userId: user.id,
        invoiceId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to send invoice',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Record payment for invoice
   */
  @Post(':id/payments')
  @Roles('admin', 'finance_manager', 'billing_staff')
  @ApiOperation({ summary: 'Record payment for invoice' })
  @ApiParam({ name: 'id', description: 'Invoice ID' })
  @ApiResponse({ status: 201, description: 'Payment recorded successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async recordPayment(
    @Param('id') id: string,
    @Body(ValidationPipe) paymentDto: PaymentDto,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Recording payment for invoice: ${id}`, {
        userId: user.id,
        invoiceId: id,
        amount: paymentDto.amount,
        auditTrail: true
      });

      const request: PaymentRequest = {
        invoiceId: id,
        ...paymentDto,
        processedBy: user.id,
      };

      const payment = await this.invoiceService.recordPayment(request);

      res.status(HttpStatus.CREATED).json({
        success: true,
        message: 'Payment recorded successfully',
        data: payment,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to record payment: ${error.message}`, {
        userId: user.id,
        invoiceId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to record payment',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Reconcile payments for invoice
   */
  @Post(':id/reconcile')
  @Roles('admin', 'finance_manager')
  @ApiOperation({ summary: 'Reconcile payments for invoice' })
  @ApiParam({ name: 'id', description: 'Invoice ID' })
  @ApiResponse({ status: 200, description: 'Payments reconciled successfully' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async reconcilePayments(
    @Param('id') id: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Reconciling payments for invoice: ${id}`, {
        userId: user.id,
        invoiceId: id,
        auditTrail: true
      });

      const invoice = await this.invoiceService.reconcilePayments(id, user.id);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Payments reconciled successfully',
        data: invoice,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to reconcile payments: ${error.message}`, {
        userId: user.id,
        invoiceId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to reconcile payments',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Cancel invoice
   */
  @Delete(':id')
  @Roles('admin', 'finance_manager')
  @ApiOperation({ summary: 'Cancel invoice' })
  @ApiParam({ name: 'id', description: 'Invoice ID' })
  @ApiResponse({ status: 200, description: 'Invoice cancelled successfully' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async cancelInvoice(
    @Param('id') id: string,
    @Body() body: { reason: string },
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Cancelling invoice: ${id}`, {
        userId: user.id,
        invoiceId: id,
        reason: body.reason,
        auditTrail: true
      });

      const invoice = await this.invoiceService.cancelInvoice(id, user.id, body.reason);

      res.status(HttpStatus.OK).json({
        success: true,
        message: 'Invoice cancelled successfully',
        data: invoice,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to cancel invoice: ${error.message}`, {
        userId: user.id,
        invoiceId: id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to cancel invoice',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get invoice statistics
   */
  @Get('statistics/summary')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get invoice statistics' })
  @ApiQuery({ name: 'period', required: false, description: 'Statistics period (month, quarter, year)' })
  @ApiResponse({ status: 200, description: 'Statistics retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getInvoiceStatistics(
    @Query('period') period: 'month' | 'quarter' | 'year' = 'month',
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info('Retrieving invoice statistics', {
        userId: user.id,
        period,
        auditTrail: true
      });

      const statistics = await this.invoiceService.getInvoiceStatistics(period);

      res.status(HttpStatus.OK).json({
        success: true,
        data: statistics,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve invoice statistics: ${error.message}`, {
        userId: user.id,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve invoice statistics',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Get invoice by invoice number
   */
  @Get('number/:invoiceNumber')
  @Roles('admin', 'finance_manager', 'billing_staff', 'viewer')
  @ApiOperation({ summary: 'Get invoice by invoice number' })
  @ApiParam({ name: 'invoiceNumber', description: 'Invoice number' })
  @ApiResponse({ status: 200, description: 'Invoice retrieved successfully' })
  @ApiResponse({ status: 404, description: 'Invoice not found' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async getInvoiceByNumber(
    @Param('invoiceNumber') invoiceNumber: string,
    @User() user: any,
    @Res() res: Response
  ): Promise<void> {
    try {
      logger.info(`Retrieving invoice by number: ${invoiceNumber}`, {
        userId: user.id,
        invoiceNumber,
        auditTrail: true
      });

      // This would need to be implemented in the service
      // const invoice = await this.invoiceService.getInvoiceByNumber(invoiceNumber);

      res.status(HttpStatus.NOT_IMPLEMENTED).json({
        success: false,
        message: 'Get invoice by number not implemented',
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      logger.error(`Failed to retrieve invoice by number: ${error.message}`, {
        userId: user.id,
        invoiceNumber,
        error: error.stack,
        auditTrail: true
      });

      res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'Failed to retrieve invoice by number',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }
}

export default InvoiceController;