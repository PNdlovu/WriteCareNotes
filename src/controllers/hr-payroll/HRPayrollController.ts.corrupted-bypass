/**
 * @fileoverview HR & Payroll Controller for WriteCareNotes
 * @module HRPayrollController
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description REST API controller for HR and payroll management operations
 * providing comprehensive endpoints for employee management, payroll processing,
 * training records, shift scheduling, and performance management with full
 * authentication, authorization, and audit support.
 * 
 * @compliance
 * - Employment Rights Act 1996
 * - Working Time Regulations 1998
 * - PAYE (Pay As You Earn) regulations
 * - GDPR data protection requirements
 * - API security and audit requirements
 */

import { 
  Controller, 
  Get, 
  Post, 
  Put, 
  Delete, 
  Body, 
  Param, 
  Query, 
  HttpStatus, 
  UseGuards,
  Request,
  ValidationPipe,
  ParseUUIDPipe
} from '@nestjs/common';
import { 
  ApiTags, 
  ApiOperation, 
  ApiResponse, 
  ApiParam, 
  ApiQuery,
  ApiBearerAuth,
  ApiBody
} from '@nestjs/swagger';
import { v4 as uuidv4 } from 'uuid';
import { HRPayrollService } from '@/services/hr-payroll/HRPayrollService';
import { AuthGuard } from '@/guards/AuthGuard';
import { RolesGuard } from '@/guards/RolesGuard';
import { Roles } from '@/decorators/Roles';
import { AuditLog } from '@/decorators/AuditLog';
import { RateLimit } from '@/decorators/RateLimit';
import { logger } from '@/utils/logger';
import {
  CreateEmployeeRequest,
  UpdateEmployeeRequest,
  ProcessPayrollRequest,
  CreateTrainingRecordRequest,
  CreateShiftRequest,
  CreatePerformanceReviewRequest,
  EmployeeSearchFilters,
  PayrollReportRequest,
  HRMetricsRequest
} from '@/services/hr-payroll/interfaces/HRPayrollInterfaces';
import {
  Employee,
  PayrollSummary,
  TrainingRecord,
  Shift,
  PerformanceReview,
  HRMetrics
} from '@/entities/hr-payroll/HRPayrollEntities';

@ApiTags('HR & Payroll')
@Controller('api/v1/hr-payroll')
@UseGuards(AuthGuard, RolesGuard)
@ApiBearerAuth()
export class HRPayrollController {
  constructor(private readonly hrPayrollService: HRPayrollService) {}

  // Employee Management Endpoints

  @Post('employees')
  @Roles('hr_manager', 'admin', 'care_home_manager')
  @AuditLog('EMPLOYEE_CREATE_ATTEMPT')
  @RateLimit({ requests: 10, windowMs: 60000 }) // 10 requests per minute
  @ApiOperation({ 
    summary: 'Create new employee',
    description: 'Creates a new employee record with comprehensive validation and compliance checks'
  })
  @ApiResponse({ 
    status: HttpStatus.CREATED, 
    description: 'Employee created successfully',
    type: Employee
  })
  @ApiResponse({ 
    status: HttpStatus.BAD_REQUEST, 
    description: 'Invalid employee data or validation errors'
  })
  @ApiResponse({ 
    status: HttpStatus.CONFLICT, 
    description: 'Employee with same number or NI number already exists'
  })
  @ApiBody({ type: CreateEmployeeRequest })
  async createEmployee(
    @Body(ValidationPipe) createEmployeeDto: CreateEmployeeRequest,
    @Request() req: any
  ): Promise<{ success: boolean; data: Employee; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Creating employee', { 
      employeeNumber: createEmployeeDto.employeeNumber,
      userId: req.user.id,
      correlationId 
    });

    try {
      const employee = await this.hrPayrollService.createEmployee(
        {
          ...createEmployeeDto,
          createdBy: req.user.id
        },
        correlationId
      );

      return {
        success: true,
        data: employee,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to create employee', { 
        error: error.message,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Get('employees/:id')
  @Roles('hr_manager', 'admin', 'care_home_manager', 'supervisor')
  @AuditLog('EMPLOYEE_VIEW')
  @RateLimit({ requests: 100, windowMs: 60000 }) // 100 requests per minute
  @ApiOperation({ 
    summary: 'Get employee by ID',
    description: 'Retrieves detailed employee information including compliance status'
  })
  @ApiParam({ name: 'id', description: 'Employee UUID' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'Employee retrieved successfully',
    type: Employee
  })
  @ApiResponse({ 
    status: HttpStatus.NOT_FOUND, 
    description: 'Employee not found'
  })
  async getEmployee(
    @Param('id', ParseUUIDPipe) employeeId: string,
    @Request() req: any
  ): Promise<{ success: boolean; data: Employee; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Retrieving employee', { 
      employeeId,
      userId: req.user.id,
      correlationId 
    });

    try {
      const employee = await this.hrPayrollService.getEmployee(employeeId, correlationId);

      return {
        success: true,
        data: employee,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to retrieve employee', { 
        error: error.message,
        employeeId,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Get('employees')
  @Roles('hr_manager', 'admin', 'care_home_manager', 'supervisor')
  @AuditLog('EMPLOYEE_SEARCH')
  @RateLimit({ requests: 50, windowMs: 60000 }) // 50 requests per minute
  @ApiOperation({ 
    summary: 'Search employees',
    description: 'Search and filter employees with pagination and sorting'
  })
  @ApiQuery({ name: 'careHomeId', required: false, description: 'Care home UUID filter' })
  @ApiQuery({ name: 'department', required: false, description: 'Department filter' })
  @ApiQuery({ name: 'position', required: false, description: 'Position filter' })
  @ApiQuery({ name: 'status', required: false, description: 'Employment status filter' })
  @ApiQuery({ name: 'searchTerm', required: false, description: 'Search in name, employee number, email' })
  @ApiQuery({ name: 'page', required: false, description: 'Page number (default: 1)' })
  @ApiQuery({ name: 'limit', required: false, description: 'Items per page (default: 50)' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'Employees retrieved successfully'
  })
  async searchEmployees(
    @Query() filters: EmployeeSearchFilters,
    @Request() req: any
  ): Promise<{ success: boolean; data: any; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Searching employees', { 
      filters,
      userId: req.user.id,
      correlationId 
    });

    try {
      const result = await this.hrPayrollService.searchEmployees(filters, correlationId);

      return {
        success: true,
        data: result,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to search employees', { 
        error: error.message,
        filters,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Put('employees/:id')
  @Roles('hr_manager', 'admin', 'care_home_manager')
  @AuditLog('EMPLOYEE_UPDATE')
  @RateLimit({ requests: 20, windowMs: 60000 }) // 20 requests per minute
  @ApiOperation({ 
    summary: 'Update employee',
    description: 'Updates employee information with validation and audit trail'
  })
  @ApiParam({ name: 'id', description: 'Employee UUID' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'Employee updated successfully',
    type: Employee
  })
  @ApiBody({ type: UpdateEmployeeRequest })
  async updateEmployee(
    @Param('id', ParseUUIDPipe) employeeId: string,
    @Body(ValidationPipe) updateEmployeeDto: UpdateEmployeeRequest,
    @Request() req: any
  ): Promise<{ success: boolean; data: Employee; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Updating employee', { 
      employeeId,
      userId: req.user.id,
      correlationId 
    });

    try {
      const employee = await this.hrPayrollService.updateEmployee(
        {
          ...updateEmployeeDto,
          employeeId,
          updatedBy: req.user.id
        },
        correlationId
      );

      return {
        success: true,
        data: employee,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to update employee', { 
        error: error.message,
        employeeId,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  // Payroll Management Endpoints

  @Post('payroll/process')
  @Roles('hr_manager', 'admin', 'payroll_administrator')
  @AuditLog('PAYROLL_PROCESS_ATTEMPT')
  @RateLimit({ requests: 5, windowMs: 300000 }) // 5 requests per 5 minutes
  @ApiOperation({ 
    summary: 'Process payroll',
    description: 'Processes payroll for specified period with tax and pension calculations'
  })
  @ApiResponse({ 
    status: HttpStatus.CREATED, 
    description: 'Payroll processed successfully',
    type: PayrollSummary
  })
  @ApiResponse({ 
    status: HttpStatus.BAD_REQUEST, 
    description: 'Invalid payroll request or validation errors'
  })
  @ApiBody({ type: ProcessPayrollRequest })
  async processPayroll(
    @Body(ValidationPipe) processPayrollDto: ProcessPayrollRequest,
    @Request() req: any
  ): Promise<{ success: boolean; data: PayrollSummary; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Processing payroll', { 
      payrollPeriod: processPayrollDto.payrollPeriod,
      userId: req.user.id,
      correlationId 
    });

    try {
      const payrollSummary = await this.hrPayrollService.processPayroll(
        {
          ...processPayrollDto,
          processedBy: req.user.id
        },
        correlationId
      );

      return {
        success: true,
        data: payrollSummary,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to process payroll', { 
        error: error.message,
        payrollPeriod: processPayrollDto.payrollPeriod,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Get('payroll/summaries')
  @Roles('hr_manager', 'admin', 'payroll_administrator', 'care_home_manager')
  @AuditLog('PAYROLL_SUMMARY_VIEW')
  @RateLimit({ requests: 50, windowMs: 60000 }) // 50 requests per minute
  @ApiOperation({ 
    summary: 'Get payroll summaries',
    description: 'Retrieves payroll summaries with filtering and pagination'
  })
  @ApiQuery({ name: 'careHomeId', required: false, description: 'Care home UUID filter' })
  @ApiQuery({ name: 'period', required: false, description: 'Payroll period filter' })
  @ApiQuery({ name: 'status', required: false, description: 'Payroll status filter' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'Payroll summaries retrieved successfully'
  })
  async getPayrollSummaries(
    @Query() filters: any,
    @Request() req: any
  ): Promise<{ success: boolean; data: any; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Retrieving payroll summaries', { 
      filters,
      userId: req.user.id,
      correlationId 
    });

    try {
      const summaries = await this.hrPayrollService.getPayrollSummaries(filters, correlationId);

      return {
        success: true,
        data: summaries,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to retrieve payroll summaries', { 
        error: error.message,
        filters,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  // Training Management Endpoints

  @Post('training/records')
  @Roles('hr_manager', 'admin', 'care_home_manager', 'supervisor')
  @AuditLog('TRAINING_RECORD_CREATE')
  @RateLimit({ requests: 20, windowMs: 60000 }) // 20 requests per minute
  @ApiOperation({ 
    summary: 'Create training record',
    description: 'Creates a training record for an employee with compliance tracking'
  })
  @ApiResponse({ 
    status: HttpStatus.CREATED, 
    description: 'Training record created successfully',
    type: TrainingRecord
  })
  @ApiBody({ type: CreateTrainingRecordRequest })
  async createTrainingRecord(
    @Body(ValidationPipe) createTrainingDto: CreateTrainingRecordRequest,
    @Request() req: any
  ): Promise<{ success: boolean; data: TrainingRecord; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Creating training record', { 
      employeeId: createTrainingDto.employeeId,
      trainingType: createTrainingDto.trainingType,
      userId: req.user.id,
      correlationId 
    });

    try {
      const trainingRecord = await this.hrPayrollService.createTrainingRecord(
        {
          ...createTrainingDto,
          recordedBy: req.user.id
        },
        correlationId
      );

      return {
        success: true,
        data: trainingRecord,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to create training record', { 
        error: error.message,
        employeeId: createTrainingDto.employeeId,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Get('training/compliance/:careHomeId')
  @Roles('hr_manager', 'admin', 'care_home_manager', 'supervisor')
  @AuditLog('TRAINING_COMPLIANCE_VIEW')
  @RateLimit({ requests: 30, windowMs: 60000 }) // 30 requests per minute
  @ApiOperation({ 
    summary: 'Get training compliance report',
    description: 'Retrieves comprehensive training compliance report for care home'
  })
  @ApiParam({ name: 'careHomeId', description: 'Care home UUID' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'Training compliance report retrieved successfully'
  })
  async getTrainingCompliance(
    @Param('careHomeId', ParseUUIDPipe) careHomeId: string,
    @Request() req: any
  ): Promise<{ success: boolean; data: any; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Retrieving training compliance', { 
      careHomeId,
      userId: req.user.id,
      correlationId 
    });

    try {
      const compliance = await this.hrPayrollService.getTrainingCompliance(careHomeId, correlationId);

      return {
        success: true,
        data: compliance,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to retrieve training compliance', { 
        error: error.message,
        careHomeId,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  // Shift Management Endpoints

  @Post('shifts')
  @Roles('hr_manager', 'admin', 'care_home_manager', 'supervisor')
  @AuditLog('SHIFT_CREATE')
  @RateLimit({ requests: 50, windowMs: 60000 }) // 50 requests per minute
  @ApiOperation({ 
    summary: 'Create shift',
    description: 'Creates a shift schedule with conflict detection and compliance checks'
  })
  @ApiResponse({ 
    status: HttpStatus.CREATED, 
    description: 'Shift created successfully',
    type: Shift
  })
  @ApiBody({ type: CreateShiftRequest })
  async createShift(
    @Body(ValidationPipe) createShiftDto: CreateShiftRequest,
    @Request() req: any
  ): Promise<{ success: boolean; data: Shift; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Creating shift', { 
      employeeId: createShiftDto.employeeId,
      shiftType: createShiftDto.shiftType,
      userId: req.user.id,
      correlationId 
    });

    try {
      const shift = await this.hrPayrollService.createShift(
        {
          ...createShiftDto,
          createdBy: req.user.id
        },
        correlationId
      );

      return {
        success: true,
        data: shift,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to create shift', { 
        error: error.message,
        employeeId: createShiftDto.employeeId,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Get('shifts/schedule')
  @Roles('hr_manager', 'admin', 'care_home_manager', 'supervisor')
  @AuditLog('SHIFT_SCHEDULE_VIEW')
  @RateLimit({ requests: 100, windowMs: 60000 }) // 100 requests per minute
  @ApiOperation({ 
    summary: 'Get shift schedule',
    description: 'Retrieves shift schedule with conflict detection and staffing analysis'
  })
  @ApiQuery({ name: 'careHomeId', required: true, description: 'Care home UUID' })
  @ApiQuery({ name: 'startDate', required: true, description: 'Schedule start date' })
  @ApiQuery({ name: 'endDate', required: true, description: 'Schedule end date' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'Shift schedule retrieved successfully'
  })
  async getShiftSchedule(
    @Query() filters: any,
    @Request() req: any
  ): Promise<{ success: boolean; data: any; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Retrieving shift schedule', { 
      filters,
      userId: req.user.id,
      correlationId 
    });

    try {
      const schedule = await this.hrPayrollService.getShiftSchedule(filters, correlationId);

      return {
        success: true,
        data: schedule,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to retrieve shift schedule', { 
        error: error.message,
        filters,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  // HR Metrics and Reporting Endpoints

  @Get('metrics/:careHomeId')
  @Roles('hr_manager', 'admin', 'care_home_manager')
  @AuditLog('HR_METRICS_VIEW')
  @RateLimit({ requests: 20, windowMs: 60000 }) // 20 requests per minute
  @ApiOperation({ 
    summary: 'Get HR metrics',
    description: 'Retrieves comprehensive HR metrics and analytics for reporting'
  })
  @ApiParam({ name: 'careHomeId', description: 'Care home UUID' })
  @ApiQuery({ name: 'period', required: false, description: 'Reporting period' })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'HR metrics retrieved successfully',
    type: HRMetrics
  })
  async getHRMetrics(
    @Param('careHomeId', ParseUUIDPipe) careHomeId: string,
    @Query() query: any,
    @Request() req: any
  ): Promise<{ success: boolean; data: HRMetrics; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Retrieving HR metrics', { 
      careHomeId,
      period: query.period,
      userId: req.user.id,
      correlationId 
    });

    try {
      const metrics = await this.hrPayrollService.getHRMetrics(
        {
          careHomeId,
          period: query.period || 'current_month',
          ...query
        },
        correlationId
      );

      return {
        success: true,
        data: metrics,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to retrieve HR metrics', { 
        error: error.message,
        careHomeId,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }

  @Post('reports/generate')
  @Roles('hr_manager', 'admin', 'care_home_manager')
  @AuditLog('HR_REPORT_GENERATE')
  @RateLimit({ requests: 10, windowMs: 300000 }) // 10 requests per 5 minutes
  @ApiOperation({ 
    summary: 'Generate HR report',
    description: 'Generates comprehensive HR reports in various formats'
  })
  @ApiResponse({ 
    status: HttpStatus.CREATED, 
    description: 'Report generation initiated successfully'
  })
  @ApiBody({ type: PayrollReportRequest })
  async generateReport(
    @Body(ValidationPipe) reportRequest: PayrollReportRequest,
    @Request() req: any
  ): Promise<{ success: boolean; data: any; meta: any }> {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    
    logger.info('Generating HR report', { 
      reportType: reportRequest.reportType,
      careHomeId: reportRequest.careHomeId,
      userId: req.user.id,
      correlationId 
    });

    try {
      const report = await this.hrPayrollService.generateReport(reportRequest, correlationId);

      return {
        success: true,
        data: report,
        meta: {
          timestamp: new Date().toISOString(),
          correlationId,
          version: 'v1'
        }
      };

    } catch (error) {
      logger.error('Failed to generate HR report', { 
        error: error.message,
        reportType: reportRequest.reportType,
        userId: req.user.id,
        correlationId 
      });
      throw error;
    }
  }
}