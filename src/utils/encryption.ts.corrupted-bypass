import { EventEmitter2 } from "eventemitter2";

/**
 * @fileoverview Healthcare Data Encryption Utility for WriteCareNotes
 * @module HealthcareEncryption
 * @version 1.0.0
 * @author WriteCareNotes Team
 * @since 2025-01-01
 * 
 * @description AES-256-GCM encryption for healthcare PII data with GDPR compliance.
 * Implements field-level encryption for sensitive healthcare information.
 * 
 * @compliance
 * - GDPR Article 32 (Security of processing)
 * - NHS Digital Data Security Standards
 * - ISO 27001 Information Security Management
 * - Healthcare data encryption requirements
 */

import crypto from 'crypto';
import { config } from 'dotenv';
import { logger } from './logger';

// Load environment variables
config();

/**
 * Encryption configuration for healthcare data
 */
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-gcm',
  keyLength: 32, // 256 bits
  ivLength: 16,  // 128 bits
  tagLength: 16, // 128 bits
  saltLength: 32 // 256 bits
} as const;

/**
 * Healthcare encryption service with GDPR compliance
 */
export class HealthcareEncryption {
  private static encryptionKey: Buffer;
  private static initialized = false;

  /**
   * Initialize encryption with master key
   */
  static initialize(): void {
    if (this.initialized) {
      return;
    }

    const masterKey = process.env['HEALTHCARE_ENCRYPTION_KEY'];
    if (!masterKey) {
      throw new Error('HEALTHCARE_ENCRYPTION_KEY environment variable is required');
    }

    // Derive encryption key from master key
    this.encryptionKey = crypto.scryptSync(masterKey, 'writecarenotes-salt', ENCRYPTION_CONFIG.keyLength);
    this.initialized = true;

    console.info('Healthcare encryption initialized', {
      algorithm: ENCRYPTION_CONFIG.algorithm,
      keyLength: ENCRYPTION_CONFIG.keyLength,
      gdprCompliant: true
    });
  }

  /**
   * Encrypt healthcare data with AES-256-GCM
   */
  static async encrypt(data: string): Promise<string> {
    if (!this.initialized) {
      this.initialize();
    }

    if (!data || typeof data !== 'string') {
      throw new Error('Data must be a non-empty string');
    }

    try {
      // Generate random IV for each encryption
      const iv = crypto.randomBytes(ENCRYPTION_CONFIG.ivLength);
      
      // Create cipher
      const cipher = crypto.createCipher(ENCRYPTION_CONFIG.algorithm, this.encryptionKey);
      cipher.setAAD(Buffer.from('writecarenotes-healthcare-data'));

      // Encrypt data
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      // Get authentication tag
      const tag = cipher.getAuthTag();

      // Combine IV + tag + encrypted data
      const result = iv.toString('hex') + ':' + tag.toString('hex') + ':' + encrypted;

      // Log encryption event for audit
      logger.debug('Healthcare data encrypted', {
        dataLength: data.length,
        encryptedLength: result.length,
        algorithm: ENCRYPTION_CONFIG.algorithm,
        auditTrail: true
      });

      return result;

    } catch (error: unknown) {
      console.error('Healthcare data encryption failed', { error });
      throw new Error('Failed to encrypt healthcare data');
    }
  }

  /**
   * Decrypt healthcare data with AES-256-GCM
   */
  static async decrypt(encryptedData: string): Promise<string> {
    if (!this.initialized) {
      this.initialize();
    }

    if (!encryptedData || typeof encryptedData !== 'string') {
      throw new Error('Encrypted data must be a non-empty string');
    }

    try {
      // Split the encrypted data
      const parts = encryptedData.split(':');
      if (parts.length !== 3) {
        throw new Error('Invalid encrypted data format');
      }


      const iv = Buffer.from(parts[0] || '', 'hex');
      const tag = Buffer.from(parts[1] || '', 'hex');
      const encrypted = parts[2] || '';


      // Create decipher
      const decipher = crypto.createDecipher(ENCRYPTION_CONFIG.algorithm, this.encryptionKey);
      decipher.setAuthTag(tag);
      decipher.setAAD(Buffer.from('writecarenotes-healthcare-data'));

      // Decrypt data
      let decrypted = decipher.update(encrypted || "", "hex", "utf8");
      decrypted += decipher.final('utf8');

      // Log decryption event for audit
      logger.debug('Healthcare data decrypted', {
        encryptedLength: encryptedData.length,
        decryptedLength: decrypted.length,
        algorithm: ENCRYPTION_CONFIG.algorithm,
        auditTrail: true
      });

      return decrypted;

    } catch (error: unknown) {
      console.error('Healthcare data decryption failed', { error });
      throw new Error('Failed to decrypt healthcare data');
    }
  }

  /**
   * Hash sensitive data for indexing (one-way)
   */
  static async hash(data: string): Promise<string> {
    if (!data || typeof data !== 'string') {
      throw new Error('Data must be a non-empty string');
    }

    try {
      // Use SHA-256 with salt for hashing
      const salt = crypto.randomBytes(ENCRYPTION_CONFIG.saltLength);
      const hash = crypto.pbkdf2Sync(data, salt, 100000, 64, 'sha256');
      
      // Combine salt and hash
      const result = salt.toString('hex') + ':' + hash.toString('hex');

      logger.debug('Healthcare data hashed', {
        dataLength: data.length,
        hashLength: result.length,
        auditTrail: true
      });

      return result;

    } catch (error: unknown) {
      console.error('Healthcare data hashing failed', { error });
      throw new Error('Failed to hash healthcare data');
    }
  }

  /**
   * Verify hashed data
   */
  static async verifyHash(data: string, hashedData: string): Promise<boolean> {
    if (!data || !hashedData) {
      return false;
    }

    try {
      const parts = hashedData.split(':');
      if (parts.length !== 2) {
        return false;
      }


      const salt = Buffer.from(parts[0] || '', 'hex');
      const originalHash = parts[1] || '';

      
      // Hash the input data with the same salt
      const hash = crypto.pbkdf2Sync(data, salt, 100000, 64, 'sha256');
      const newHash = hash.toString('hex');

      // Compare hashes
      const isValid = crypto.timingSafeEqual(
        Buffer.from(originalHash || "", "hex"),
        Buffer.from(newHash, 'hex')
      );

      logger.debug('Healthcare data hash verification', {
        isValid,
        auditTrail: true
      });

      return isValid;

    } catch (error: unknown) {
      console.error('Healthcare data hash verification failed', { error });
      return false;
    }
  }

  /**
   * Generate secure random token for healthcare operations
   */
  static generateSecureToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  /**
   * Encrypt healthcare file data
   */
  static async encryptFile(fileBuffer: Buffer): Promise<Buffer> {
    if (!this.initialized) {
      this.initialize();
    }

    try {
      const iv = crypto.randomBytes(ENCRYPTION_CONFIG.ivLength);
      const cipher = crypto.createCipher(ENCRYPTION_CONFIG.algorithm, this.encryptionKey);
      
      const encrypted = Buffer.concat([
        cipher.update(fileBuffer),
        cipher.final()
      ]);

      const tag = cipher.getAuthTag();
      
      // Combine IV + tag + encrypted data
      const result = Buffer.concat([iv, tag, encrypted]);

      console.info('Healthcare file encrypted', {
        originalSize: fileBuffer.length,
        encryptedSize: result.length,
        auditTrail: true
      });

      return result;

    } catch (error: unknown) {
      console.error('Healthcare file encryption failed', { error });
      throw new Error('Failed to encrypt healthcare file');
    }
  }

  /**
   * Decrypt healthcare file data
   */
  static async decryptFile(encryptedBuffer: Buffer): Promise<Buffer> {
    if (!this.initialized) {
      this.initialize();
    }

    try {
      const iv = encryptedBuffer.slice(0, ENCRYPTION_CONFIG.ivLength);
      const tag = encryptedBuffer.slice(ENCRYPTION_CONFIG.ivLength, ENCRYPTION_CONFIG.ivLength + ENCRYPTION_CONFIG.tagLength);
      const encrypted = encryptedBuffer.slice(ENCRYPTION_CONFIG.ivLength + ENCRYPTION_CONFIG.tagLength);

      const decipher = crypto.createDecipher(ENCRYPTION_CONFIG.algorithm, this.encryptionKey);
      decipher.setAuthTag(tag);

      const decrypted = Buffer.concat([
        decipher.update(encrypted),
        decipher.final()
      ]);

      console.info('Healthcare file decrypted', {
        encryptedSize: encryptedBuffer.length,
        decryptedSize: decrypted.length,
        auditTrail: true
      });

      return decrypted;

    } catch (error: unknown) {
      console.error('Healthcare file decryption failed', { error });
      throw new Error('Failed to decrypt healthcare file');
    }
  }

  /**
   * Securely wipe sensitive data from memory
   */
  static secureWipe(data: any): void {
    if (typeof data === 'string') {
      // Overwrite string data (best effort in JavaScript)
      for (let i = 0; i < data.length; i++) {
        data = data.substring(0, i) + '\0' + data.substring(i + 1);
      }
    } else if (Buffer.isBuffer(data)) {
      // Securely wipe buffer
      data.fill(0);
    } else if (typeof data === 'object' && data !== null) {
      // Recursively wipe object properties
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          this.secureWipe(data[key]);
          delete data[key];
        }
      }
    }
  }

  /**
   * Generate encryption key for new healthcare organization
   */
  static generateOrganizationKey(): string {
    const key = crypto.randomBytes(ENCRYPTION_CONFIG.keyLength);
    return key.toString('hex');
  }

  /**
   * Rotate encryption keys (for key management)
   */
  static async rotateKeys(oldKey: string, newKey: string): Promise<void> {
    if (!oldKey || !newKey) {
      throw new Error('Both old and new keys are required for key rotation');
    }

    if (oldKey === newKey) {
      throw new Error('New key must be different from old key');
    }

    try {
      // Validate new key strength
      if (newKey.length < 32) {
        throw new Error('New key must be at least 32 characters long');
      }

      // Update the current encryption key
      const previousKey = this.encryptionKey;
      this.encryptionKey = newKey;

      // Verify key rotation by testing encryption/decryption
      const testData = 'key-rotation-test-' + Date.now();
      const encrypted = await this.encrypt(testData);
      const decrypted = await this.decrypt(encrypted);

      if (decrypted !== testData) {
        // Rollback on failure
        this.encryptionKey = previousKey;
        throw new Error('Key rotation verification failed');
      }

      // Log successful key rotation for audit
      console.info('Healthcare encryption key rotation completed successfully', {
        timestamp: new Date().toISOString(),
        keyRotationId: `rotation_${Date.now()}`,
        auditTrail: true,
        complianceEvent: true,
        previousKeyHash: this.hashKey(oldKey),
        newKeyHash: this.hashKey(newKey)
      });

    } catch (error: unknown) {
      console.error('Healthcare encryption key rotation failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
        auditTrail: true
      });
      throw error;
    }
  }

  /**
   * Hash a key for audit logging (one-way hash for security)
   */
  private static hashKey(key: string): string {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(key).digest('hex').substring(0, 16);
  }
}

// Initialize encryption on module load
HealthcareEncryption.initialize();

export default HealthcareEncryption;